<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android Studio连接真机没反应</title>
    <url>/post/Android%20Studio%E8%BF%9E%E6%8E%A5%E7%9C%9F%E6%9C%BA%E6%B2%A1%E5%8F%8D%E5%BA%94/</url>
    <content><![CDATA[<p>刚好遇到这个问题，在网上百度了一下，看到有人分享了引起该问题的几个原因：</p>
<ol>
<li>手机设置问题。开USB调试 方法： 手机设置 - 开发人员选项 - USB调试 - 勾选</li>
<li>数据线问题。 有的数据线只能用来充电，有的可以连接存储。识别方法很简单。。插上机器有USB存储设备的提示的就可以用。另外数据线如果都露线皮了。。就赶紧扔了。十块八块的总比你为这个破问题纠结一下午的好。</li>
<li>是否下载了对应手机版本的SDK，以Android Studio为例，点开 SDK Manager 之后。看你手机所使用的系统版本号对应的SDK是否已下载。。没有就赶紧下。。手机对应的Android版本查看方法是 手机设置 - 关于手机 - Android 版本。<br>（链接：<span class="exturl" data-url="aHR0cDovL3d3dy5tYW1pY29kZS5jb20vaW5mby1kZXRhaWwtNDcxNzc2Lmh0bWwlRUYlQkMlODk=">http://www.mamicode.com/info-detail-471776.html）<i class="fa fa-external-link-alt"></i></span><br>我将上面的三个原因都排除后，仍然连不上。后来发现手机驱动安装失败了，我的手机是MX4 Pro，看到好多人都有这个问题也没看到好的解决办法。我突然想起以前在学校的时候用的豌豆荚，可以帮助手机安装驱动，就下了一个豌豆荚，连上手机后自动安装好了驱动，我看到驱动安装成功，也连上豌豆荚了。然后关闭豌豆荚，重启了AS，居然一切正常了。这个问题困扰了几个小时了，希望这个回到能帮到遇到此问题的人。</li>
</ol>
<blockquote>
<p>PS：本文最先发表于知乎（链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzMwNTg4MDI0L2Fuc3dlci83MDM1Mjk1Mj9ncm91cF9pZD02OTEwMjE2NDc5OTc1ODMzNjAjY29tbWVudC0xMjM1MjQyNzUlRUYlQkMlODklRUYlQkMlOEMlRTUlOTAlOEUlRTYlOUQlQTUlRTYlOUMlODklRTclOUYlQTUlRTUlOEYlOEIlRTUlQkIlQkElRTglQUUlQUUlRTUlOEYlOTElRTglQTElQTglRTUlODglQjAlRTUlOEQlOUElRTUlQUUlQTIlRTQlQjglOEElRUYlQkMlOEMlRTglQkYlOTklRTYlQTAlQjclRTglODMlQkQlRTUlQjglQUUlRTUlOEElQTklRTYlOUIlQjQlRTUlQTQlOUElRTQlQkElQkElRTMlODAlODIlRTUlOTAlOEMlRTYlOTclQjYlRUYlQkMlOEMlRTQlQjklOUYlRTUlOEYlOTElRTclOEUlQjAlRTUlQkUlODglRTUlQTQlOUElRTUlODglOUElRTclOTQlQThBbmRyb2lk">https://www.zhihu.com/question/30588024/answer/70352952?group_id=691021647997583360#comment-123524275），后来有知友建议发表到博客上，这样能帮助更多人。同时，也发现很多刚用Android<i class="fa fa-external-link-alt"></i></span> Studio的朋友或者刚学Android的朋友都有遇到这样的问题。所以，决定将这个问题的解决办法发到博客来，希望能帮到更多的人。</p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>C#命名规则和编码规范</title>
    <url>/post/C_Sharp%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E5%92%8C%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h3 id="1-用-Pascal-规则来命名属性、方法、事件和类名"><a href="#1-用-Pascal-规则来命名属性、方法、事件和类名" class="headerlink" title="1. 用 Pascal 规则来命名属性、方法、事件和类名"></a>1. 用 Pascal 规则来命名属性、方法、事件和类名</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HelloWorld</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Pascal规则是指名称中单词的首字母大写 ,如EmployeeSalary、 ConfimationDialog、PlainTextEncoding。</p>
</blockquote>
<h3 id="2-用-Camel-规则来命名成员变量、局部变量和方法的参数"><a href="#2-用-Camel-规则来命名成员变量、局部变量和方法的参数" class="headerlink" title="2. 用 Camel 规则来命名成员变量、局部变量和方法的参数"></a>2. 用 Camel 规则来命名成员变量、局部变量和方法的参数</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">string</span> productId;</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">string</span> productName;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddProduct</span>(<span class="params"><span class="built_in">string</span> productId,<span class="built_in">string</span> productName</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Camel规则类似于Pascal规则 ,但名称中第一个单词的首字母不大写 ,如employeeSalary、 confimationDialog、plainTextEncoding。 </p>
</blockquote>
<h3 id="3-不要使用匈牙利命名法"><a href="#3-不要使用匈牙利命名法" class="headerlink" title="3. 不要使用匈牙利命名法"></a>3. 不要使用匈牙利命名法</h3><p>不要给成员变量加任何前缀（如_、m_、s_等等）。如果想要区分局部变量和成员变量，可以使用 <code>this</code> 关键字。</p>
<h3 id="4-不要将常量或者只读变量的变量名全部大写，而使用-Pascal-规则来命名"><a href="#4-不要将常量或者只读变量的变量名全部大写，而使用-Pascal-规则来命名" class="headerlink" title="4. 不要将常量或者只读变量的变量名全部大写，而使用 Pascal 规则来命名"></a>4. 不要将常量或者只读变量的变量名全部大写，而使用 Pascal 规则来命名</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> ShippingType = <span class="string">&quot;DropShip&quot;</span>;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// Avoid</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">string</span> SHIPPINGTYPE = <span class="string">&quot;DropShip&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-接口的名称一般以大写-I-作前缀"><a href="#5-接口的名称一般以大写-I-作前缀" class="headerlink" title="5. 接口的名称一般以大写 I 作前缀"></a>5. 接口的名称一般以大写 <code>I</code> 作前缀</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IConvertible</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="built_in">byte</span> <span class="title">ToByte</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-自定义的属性以-Attribute-结尾"><a href="#6-自定义的属性以-Attribute-结尾" class="headerlink" title="6. 自定义的属性以 Attribute 结尾"></a>6. 自定义的属性以 <code>Attribute</code> 结尾</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TableAttribute</span>:<span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-自定义的异常以-Exception-结尾"><a href="#7-自定义的异常以-Exception-结尾" class="headerlink" title="7. 自定义的异常以 Exception 结尾"></a>7. 自定义的异常以 Exception 结尾</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NullEmptyException</span>:<span class="title">Exception</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-类的命名。用名词或名词短语来命名类名"><a href="#8-类的命名。用名词或名词短语来命名类名" class="headerlink" title="8. 类的命名。用名词或名词短语来命名类名"></a>8. 类的命名。用名词或名词短语来命名类名</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BusinessLocation</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DocumentCollection</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-方法的命名。一般将其命名为动宾短语"><a href="#9-方法的命名。一般将其命名为动宾短语" class="headerlink" title="9. 方法的命名。一般将其命名为动宾短语"></a>9. 方法的命名。一般将其命名为动宾短语</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">File</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateFile</span>(<span class="params"><span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetPath</span>(<span class="params"><span class="built_in">string</span> path</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-局部变量的名称要有意义"><a href="#10-局部变量的名称要有意义" class="headerlink" title="10. 局部变量的名称要有意义"></a>10. 局部变量的名称要有意义</h3><p>不要直接用用<code>i</code>,<code>j</code>,<code>k</code>,<code>l</code>,<code>m</code>,<code>n</code>,<code>x</code>,<code>y</code>,<code>z</code>等做变量名，但for循环除外</p>
<h3 id="11-代码分块"><a href="#11-代码分块" class="headerlink" title="11. 代码分块"></a>11. 代码分块</h3><p>所有的成员变量声明在类的顶端，用一个换行把它和方法分开。同时可以使用成对的<code>#region...#endregion</code>标记，方便折叠。</p>
<h3 id="12-布尔型变量或者方法一般可以用-is、can、has-或者-should-做前缀。如，isFinished-canWork-等。"><a href="#12-布尔型变量或者方法一般可以用-is、can、has-或者-should-做前缀。如，isFinished-canWork-等。" class="headerlink" title="12. 布尔型变量或者方法一般可以用 is、can、has 或者 should 做前缀。如，isFinished, canWork 等。"></a>12. 布尔型变量或者方法一般可以用 <code>is</code>、<code>can</code>、<code>has</code> 或者 <code>should </code>做前缀。如，isFinished, canWork 等。</h3><h3 id="13-一般-C-的编码风格要求花括号-另起一行，不要直接跟在类名和方法后面。"><a href="#13-一般-C-的编码风格要求花括号-另起一行，不要直接跟在类名和方法后面。" class="headerlink" title="13.  一般 C# 的编码风格要求花括号{另起一行，不要直接跟在类名和方法后面。"></a>13.  一般 C# 的编码风格要求花括号<code>&#123;</code>另起一行，不要直接跟在类名和方法后面。</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Sample</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 在此处添加构造函数逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-可以用缩写作为-UI-元素的前缀"><a href="#14-可以用缩写作为-UI-元素的前缀" class="headerlink" title="14. 可以用缩写作为 UI 元素的前缀"></a>14. 可以用缩写作为 UI 元素的前缀</h3><p>常见UI组件的一般缩写形式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Label --&gt; lbl、Text --&gt; txt、Button --&gt; btn</span><br><span class="line">Image --&gt; img、 Widget --&gt; wgt、 List --&gt; lst、CheckBox --&gt; chk</span><br><span class="line">Hyperlink --&gt; lnk、Panel --&gt; pnl、Table --&gt; tab</span><br><span class="line">ImageButton --&gt; imb</span><br></pre></td></tr></table></figure>

<h3 id="15-判断条件是一个布尔变量时不要使用-进行条件判断"><a href="#15-判断条件是一个布尔变量时不要使用-进行条件判断" class="headerlink" title="15. 判断条件是一个布尔变量时不要使用 == 进行条件判断"></a>15. 判断条件是一个布尔变量时不要使用 <code>==</code> 进行条件判断</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不友好的写法</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> isFinished = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(isFinished == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> isFinished = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(isFinished)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-慎用缩写"><a href="#16-慎用缩写" class="headerlink" title="16. 慎用缩写"></a>16. 慎用缩写</h3><p>变量名是一个单词的尽量不要缩写，多单词组成的变量名可适当缩写。</p>
<h3 id="17-在类的顶部声明所有的成员变量，静态变量声明在最前面"><a href="#17-在类的顶部声明所有的成员变量，静态变量声明在最前面" class="headerlink" title="17. 在类的顶部声明所有的成员变量，静态变量声明在最前面"></a>17. 在类的顶部声明所有的成员变量，静态变量声明在最前面</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Account</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> BankName;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">decimal</span> Reserves;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> Number &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">	<span class="keyword">public</span> DateTime DateOpened &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">	<span class="keyword">public</span> DateTime DateClosed &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">decimal</span> Balance &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Constructor</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Account</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-方法的书写规范"><a href="#18-方法的书写规范" class="headerlink" title="18. 方法的书写规范"></a>18. 方法的书写规范</h3><p>如果一个方法超过25行，就需要考虑是否可以重构和拆分成多个方法。方法命名要见名知意，好的方法名可以省略多余的注释。方法功能尽量单一。</p>
<h3 id="19-变量名中的反义词"><a href="#19-变量名中的反义词" class="headerlink" title="19. 变量名中的反义词"></a>19. 变量名中的反义词</h3><p><code>add</code>&#x2F;<code>remove</code>、 <code>begin</code>&#x2F;<code>end</code>、 <code>create</code>&#x2F;<code>destroy</code><br><code>insert</code>&#x2F;<code>delete</code>、 <code>first</code>&#x2F;<code>last</code>、 <code>get</code>&#x2F;<code>release</code><br><code>increment</code>&#x2F;<code>decrement</code>、 <code>put</code>&#x2F;<code>get</code>、 <code>up</code>&#x2F;<code>down</code><br><code>lock</code>&#x2F;<code>unlock</code>、 <code>min</code>&#x2F;<code>max</code>、 <code>next</code>&#x2F;<code>previous</code><br><code>old</code>&#x2F;<code>new</code>、 <code>open</code>&#x2F;<code>close</code>、 <code>show</code>&#x2F;<code>hide</code><br><code>source</code>&#x2F;<code>destination</code>、 <code>source</code>&#x2F;<code>target</code>、 <code>start</code>&#x2F;<code>stop</code></p>
<h3 id="20-其他"><a href="#20-其他" class="headerlink" title="20. 其他"></a>20. 其他</h3><p>补充两条：</p>
<ol>
<li>方法名中尽量少用 get，表示取数据的函数直接描述行为，如 MsgFromFile()</li>
<li>尽量少用 set，应用属性替代</li>
</ol>
<h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><ol>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5kb2ZhY3RvcnkuY29tL3JlZmVyZW5jZS9jc2hhcnAtY29kaW5nLXN0YW5kYXJkcw==">C# Coding Standards and Naming Conventions<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9ncy5tc2RuLm1pY3Jvc29mdC5jb20vYnJhZGEvMjAwNS8wMS8yNi9pbnRlcm5hbC1jb2RpbmctZ3VpZGVsaW5lcy8=">Internal Coding Guidelines<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Git快速入门</title>
    <url>/post/Git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/git.jpg" alt="Git Logo"></p>
<p>如果你不想看长篇的Git教程，想快速了解Git的使用，那么本文可能会对你入门Git有所帮助。由于笔者用的是Windows系统，所以本文只写Git在Windows上的使用。</p>
<p><strong>一、Git安装</strong></p>
<hr>
<p>去<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS8=">Git官网<i class="fa fa-external-link-alt"></i></span>下载Git的安装程序，安装的过程我就不多说了，没啥好说的。</p>
<p><strong>二、创建本地仓库</strong></p>
<hr>
<p>Git安装完成后有一个Git Bash，打开Git Bash。输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd d:</span><br><span class="line">mkdir learngit</span><br><span class="line">cd learngit</span><br></pre></td></tr></table></figure>
<p>上述命令表示切换到电脑D盘，然后创建一个learngit的文件夹并将目录切换到该文件夹下。不确定自己是否已切换到指定目录，可以使用<code>pwd</code>命令显示当前路径。<br>最后，输入<code>git init</code>命令创建并初始化版本库。初始化完后会在当前目录下生成一个<code>.git</code>的隐藏目录，一般情况下，Windows是默认隐藏带有隐藏属性的目录和文件的，但是可以通过设置让隐藏文件可见。使用<code>ls -ah</code>命令也可以直接看生成的<code>.git</code>目录</p>
<p><strong>三、提交文件</strong></p>
<hr>
<p>在learngit文件夹下新建一个README.txt的文本文件，然后内容输入<code>This is a README file.</code>。然后输入<code> git add README.txt</code>命令将文本文件添加进仓库，如果有多个文件，直接用空格隔开一次列出就可以了。接着使用<code>git commit -m &quot;add README file&quot;</code>提交操作。</p>
<p><strong>四、提交修改</strong></p>
<hr>
<p>修改README.txt文件，将文件内容中的<code>This</code>改为<code>It</code>，使用<code>git status</code>查看仓库状态，显示绿色的文件已修改的状态，表示添加修改成功，接着使用<code>git diff</code>查看修改的内容，然后使用<code>git add README.txt</code>添加修改。最后使用<code>git commit -m &quot;modify README file&quot;</code>提交修改。<br>如果想查看提交记录，则可以使用<code>git log</code>命令。</p>
<p><strong>五、创建SSH Key</strong></p>
<hr>
<p>在Git Bash中输入<code>cd ~/.ssh</code>命令查看根目录下有没有<code>.ssh</code>文件夹。如果能进入该文件夹，继续输入<code>ls</code>命令查看该目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可以不用创建SSH Key了。如果都没有，则用<code>cd ~</code>命令切回用户主目录，然后在Git Bash输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>然后一路回车。完了，在用户主目录下会生成<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件。可以用<code>cat ~/.ssh/id_rsa</code>和<code>cat ~/.ssh/id_rsa.pub</code>查看文件的内容。</p>
<p><strong>六、在代码托管平台添加公钥</strong></p>
<hr>
<p>为了便于多人协作开发，一般我们会在远程服务器上建立一个远程仓库用来同步不同开发者的代码。这个远程仓库可以放在某一台电脑上，也可以直接使用第三方的代码托管平台。这里我们选择名气比较大的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==">GitHub<i class="fa fa-external-link-alt"></i></span>来做实验。<br>登陆你的GitHub帐户。然后点击头像 -&gt; Settings -&gt; 左边栏SSH and GPG Keys -&gt; New SSH key。然后复制上面<code>id_rsa.pub</code>文件中的内容，粘贴进Key文本域内。 Title域，随便填一个都行。<br>最后，使用<code>ssh -T git@github.com</code>命令来验证这个Key是不是正常工作。如果命令输入后，Key是正常工作的，则打印如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hi username! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>

<p>如果输出的是如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The authenticity of host &#x27;github.com (192.30.253.112)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>
<p>则一定不要直接回车跳过，不然同步代码（pull&#x2F;push）会一直报 <code>Host key verification failed</code> 的问题。正确的操作是输入 <code>yes</code> 然后回车。</p>
<blockquote>
<p>GitHub官方提供了一个非常好用的Git图形化客户端<span class="exturl" data-url="aHR0cHM6Ly9kZXNrdG9wLmdpdGh1Yi5jb20v">GitHub Desktop<i class="fa fa-external-link-alt"></i></span>。</p>
</blockquote>
<p><strong>七、关联远程仓库</strong></p>
<hr>
<ol>
<li>在GitHub<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==">首页<i class="fa fa-external-link-alt"></i></span>，点击New repository创建一个仓库，具体创建步骤这里不做展开说明。</li>
<li>创建完成后，在该仓库的首页点击Clone or download-&gt;Use SSH-&gt;拷贝仓库SSH地址。我的创建的仓库地址是<code>git@github.com:DavidSheh/learngit.git</code></li>
<li>在Git Bash中切换到本地仓库目录，然后输入<code>git remote add origin git@github.com:DavidSheh/learngit.git</code>。实际操作时请将命令中的远程仓库SSH地址替换成你自己的。如果没有打印任何信息说明关联成功。</li>
<li>推送本地仓库内容到远程仓库。第一次推送master分支的所有内容可以使用<code>git push -u origin master</code>命令。成功后，以后每次有修改后，可以直接用<code>git push origin master</code>命令推送了。</li>
</ol>
<p><strong>八、克隆远程仓库</strong></p>
<hr>
<p>如果本地没有远程仓库的项目，想从远程仓库克隆一个仓库到本地应该怎么做呢？<br>其实很简单，只需要用<code>cd</code>命令切换到想要存放项目的路径，然后直接执行<code>git clone</code>命令就行了，注意命令后面跟的是项目的URL地址。项目在GitHub上的SSH和HTTPS地址均测试成功。<br>到此为止，Git的操作环境已经熟悉的差不多了，只要能成功的在GitHub上提交代码，那么在国内的代码托管平台（如<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmNzZG4ubmV0Lw==">CSDN Code平台<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9pZGUuY29kaW5nLm5ldC8=">Coding.Net<i class="fa fa-external-link-alt"></i></span>）托管代码也是很容易的事。</p>
<p><strong>九、克隆远程仓库和子仓库</strong></p>
<hr>
<blockquote>
<p>git clone <repository_url><br>git submodule update –init –recursive</p>
</blockquote>
<p><strong>十、Git 常用命令</strong></p>
<hr>
<p>熟悉了上面的操作后，通过举一反三，Git的其他操作都可以通过查命令文档来操作。下面附上一份常用的命令清单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init                                                  # 初始化本地git仓库（创建新仓库）</span><br><span class="line">git config --global user.name &quot;xxx&quot;                       # 配置用户名</span><br><span class="line">git config --global user.email &quot;xxx@xxx.com&quot;              # 配置邮件</span><br><span class="line">git config --global color.ui true                         # git status等命令自动着色</span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line">git config --global --unset http.proxy                    # remove  proxy configuration on git</span><br><span class="line">git clone git+ssh://git@192.168.53.168/VT.git             # clone远程仓库</span><br><span class="line">git status                                                # 查看当前版本状态（是否修改）</span><br><span class="line">git add xyz                                               # 添加xyz文件至index</span><br><span class="line">git add .                                                 # 增加当前子目录下所有更改过的文件至index</span><br><span class="line">git commit -m &#x27;xxx&#x27;                                       # 提交</span><br><span class="line">git commit --amend -m &#x27;xxx&#x27;                               # 合并上一次提交（用于反复修改）</span><br><span class="line">git commit -am &#x27;xxx&#x27;                                      # 将add和commit合为一步</span><br><span class="line">git rm xxx                                                # 删除index中的文件</span><br><span class="line">git rm -r *                                               # 递归删除</span><br><span class="line">git log                                                   # 显示提交日志</span><br><span class="line">git log -1                                                # 显示1行日志 -n为n行</span><br><span class="line">git log -5</span><br><span class="line">git log --stat                                            # 显示提交日志及相关变动文件</span><br><span class="line">git log -p -m</span><br><span class="line">git show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容</span><br><span class="line">git show dfb02                                            # 可只用commitid的前几位</span><br><span class="line">git show HEAD                                             # 显示HEAD提交日志</span><br><span class="line">git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</span><br><span class="line">git tag                                                   # 显示已存在的tag</span><br><span class="line">git tag -a v2.0 -m &#x27;xxx&#x27;                                  # 增加v2.0的tag</span><br><span class="line">git show v2.0                                             # 显示v2.0的日志及详细内容</span><br><span class="line">git log v2.0                                              # 显示v2.0的日志</span><br><span class="line">git diff                                                  # 显示所有未添加至index的变更</span><br><span class="line">git diff --cached                                         # 显示所有已添加index但还未commit的变更</span><br><span class="line">git diff HEAD^                                            # 比较与上一个版本的差异</span><br><span class="line">git diff HEAD -- ./lib                                    # 比较与HEAD版本lib目录的差异</span><br><span class="line">git diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的</span><br><span class="line">git diff origin/master..master --stat                     # 只显示差异的文件，不显示具体内容</span><br><span class="line">git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）</span><br><span class="line">git branch                                                # 显示本地分支</span><br><span class="line">git branch --contains 50089                               # 显示包含提交50089的分支</span><br><span class="line">git branch -a                                             # 显示所有分支</span><br><span class="line">git branch -r                                             # 显示所有原创分支</span><br><span class="line">git branch --merged                                       # 显示所有已合并到当前分支的分支</span><br><span class="line">git branch --no-merged                                    # 显示所有未合并到当前分支的分支</span><br><span class="line">git branch -m master master_copy                          # 本地分支改名</span><br><span class="line">git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出</span><br><span class="line">git checkout -b master master_copy                        # 上面的完整版</span><br><span class="line">git checkout features/performance                         # 检出已存在的features/performance分支</span><br><span class="line">git checkout --track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</span><br><span class="line">git checkout v2.0                                         # 检出版本v2.0</span><br><span class="line">git checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出</span><br><span class="line">git checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）</span><br><span class="line">git merge origin/master                                   # 合并远程master分支至当前分支</span><br><span class="line">git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改</span><br><span class="line">git push origin master                                    # 将当前分支push到远程master分支</span><br><span class="line">git push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支</span><br><span class="line">git push --tags                                           # 把所有tag推送到远程仓库</span><br><span class="line">git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）</span><br><span class="line">git fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支</span><br><span class="line">git pull origin master                                    # 获取远程分支master并merge到当前分支</span><br><span class="line">git mv README README2                                     # 重命名文件README为README2</span><br><span class="line">git reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）</span><br><span class="line">git rebase</span><br><span class="line">git branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</span><br><span class="line">git branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933</span><br><span class="line">git ls-files                                              # 列出git index包含的文件</span><br><span class="line">git show-branch                                           # 图示当前分支历史</span><br><span class="line">git show-branch --all                                     # 图示所有分支历史</span><br><span class="line">git whatchanged                                           # 显示提交历史对应的文件修改</span><br><span class="line">git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</span><br><span class="line">git ls-tree HEAD                                          # 内部命令：显示某个git对象</span><br><span class="line">git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASH</span><br><span class="line">git reflog                                                # 显示所有提交，包括孤立节点</span><br><span class="line">git show HEAD@&#123;5&#125;</span><br><span class="line">git show master@&#123;yesterday&#125;                               # 显示master分支昨天的状态</span><br><span class="line">git log --pretty=format:&#x27;%h %s&#x27; --graph                   # 图示提交日志</span><br><span class="line">git show HEAD~3</span><br><span class="line">git show -s --pretty=raw 2be7fcb476</span><br><span class="line">git stash                                                 # 暂存当前修改，将所有至为HEAD状态</span><br><span class="line">git stash list                                            # 查看所有暂存</span><br><span class="line">git stash show -p stash@&#123;0&#125;                               # 参考第一次暂存</span><br><span class="line">git stash apply stash@&#123;0&#125;                                 # 应用第一次暂存</span><br><span class="line">git grep &quot;delete from&quot;                                    # 文件中搜索文本“delete from”</span><br><span class="line">git grep -e &#x27;#define&#x27; --and -e SORT_DIRENT</span><br><span class="line">git gc</span><br><span class="line">git fsck</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>十、参考资料</strong></p>
<ol>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5saWFveHVlZmVuZy5jb20vd2lraS8wMDEzNzM5NTE2MzA1OTI5NjA2ZGQxODM2MTI0ODU3OGM2N2I4MDY3YzhjMDE3YjAwMA==">廖雪峰Git教程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ3V3ZWlnYW5nLzk4NDgyNzE=">Git命令大全<i class="fa fa-external-link-alt"></i></span></li>
<li>这里还有两篇整理得不错的介绍Git常用命令的文章也介绍个大家：</li>
</ol>
<ul>
<li>阮一峰老师的<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTUvMTIvZ2l0LWNoZWF0LXNoZWV0Lmh0bWw=">常用 Git 命令清单<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3JvYmJpbmZhbi5jb20vYmxvZy8zNC9naXQtY29tbW9uLWNvbW1hbmQ=">Git常用命令备忘<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<blockquote>
<p>本文是笔者的学习记录，分享给大家，如有错误之处请多多指教。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown快速入门</title>
    <url>/post/Markdown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Markdown快速入门中文文档对于非编程人员来说理解有一定的难度。笔者写这篇文章的目的有两个，一个是尝试用更加简单的方式来讲解Markdown语法；二是对自己学习的一个总结。</p>
<h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><p>Markdown 的目标是实现「易读易写」。Markdown 语法的目标是：成为一种适用于网络的书写语言。<br>Markdown可以用来写文档、做笔记和写博客，让你更专注于内容而不是排版。它的语法易记，掌握后你会发现使用简单的标记就可以实现简洁大方的排版。本博客的所有排版都是用的Markdown语言实现的。</p>
<span id="more"></span>

<h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>Markdown 支持两种标题的语法，Setext 和 atx 形式。Setext 形式是用底线的形式，利用 &#x3D; （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。</p>
<h4 id="1-Setext形式标题"><a href="#1-Setext形式标题" class="headerlink" title="1. Setext形式标题"></a>1. Setext形式标题</h4><pre><code>内容
=== （最高阶标题）

内容
--- （第二阶标题）
</code></pre>
<blockquote>
<p>注释：上面的<code>最高阶标题</code>和<code>第二阶标题</code>分别用了三个连续的<code>=</code>和<code>-</code>，实际上都只需要一个就可以了。由于个人习惯，笔者喜欢用三到五个符号。</p>
</blockquote>
<h4 id="2-atx-形式形式标题"><a href="#2-atx-形式形式标题" class="headerlink" title="2. atx 形式形式标题"></a>2. atx 形式形式标题</h4><pre><code># 内容 （一级标题）
## 内容 （二级标题）
### 内容 （三级标题）
#### 内容 （四级标题）
##### 内容 （五级标题）
###### 内容 （六级标题）   
</code></pre>
<blockquote>
<p>注释：上面语法中的最后一个<code>#</code>和内容之间一般需要一个空格。</p>
</blockquote>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><pre><code>- 内容
- 内容
- 内容
</code></pre>
<blockquote>
<p>注释：可以把上面无序列表语法中的<code>-</code>号换成<code>+</code>或者<code>*</code>,还可以嵌套使用。</p>
</blockquote>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><pre><code>1. 内容
2. 内容
3. 内容
</code></pre>
<blockquote>
<p>注释：有序列表可以和无序列表相互嵌套使用。</p>
</blockquote>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Markdown 支援两种形式的链接语法：行内和参考两种形式，两种都是使用角括号来把文字转成连结。行内形式是直接在后面用括号直接接上链接，你也可以选择性的加上 title 属性（也就是鼠标Tips）；参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容。</p>
<h4 id="1-行内链接"><a href="#1-行内链接" class="headerlink" title="1. 行内链接"></a>1. 行内链接</h4><pre><code>[百度](http://www.baidu.com &quot;这是百度链接&quot;)
</code></pre>
<blockquote>
<p> 注释：上面行内链接语法中，引号部分类容是鼠标移到链接文字上是显示的Tips，这部分可以省略。</p>
</blockquote>
<h4 id="2-参考链接"><a href="#2-参考链接" class="headerlink" title="2. 参考链接"></a>2. 参考链接</h4><pre><code>[Google][1]、[GitHub][2]和[百度][3]都是程序猿经常访问的网页。

[1]: http://google.com/ &quot;Google首页&quot;
[2]: https://github.com/ &quot;GitHub首页&quot;
[3]: http://www.baidu.com/ &quot;百度首页&quot;
</code></pre>
<blockquote>
<p> 注释：上面参考链接语法中，引号部分类容也表示鼠标移到链接文字上是显示的Tips，这部分可以省略。</p>
</blockquote>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>图片的语法和链接很像，也分为行内形式和参考形式。插入图片只是在插入链接的语法的前面多加了一个感叹号。所以，这里只写出行内形式的语法，参考形式自己举一反三。</p>
<h4 id="行内形式"><a href="#行内形式" class="headerlink" title="行内形式"></a>行内形式</h4><pre><code>![百度Logo](https://www.baidu.com/img/bdlogo.png &quot;百度&quot;)
</code></pre>
<h3 id="引入代码"><a href="#引入代码" class="headerlink" title="引入代码"></a>引入代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">``` 语言类型	（代码引入开始）</span><br><span class="line">	代码片段</span><br><span class="line">``` 		（代码引入结束）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注释：用三个“&#96;”（英文反引号，~键下面的符号，也就是Esc键下方的那个键）引入代码，三个英文反引号后可以加语言类型（可加可不加），用三个单引号结束代码引入。</p>
</blockquote>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><pre><code>&gt; 内容
</code></pre>
<h3 id="粗体和斜体"><a href="#粗体和斜体" class="headerlink" title="粗体和斜体"></a>粗体和斜体</h3><pre><code>粗体语法：**内容**
斜体语法：*内容*
</code></pre>
<h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p>
<blockquote>
<p>注释：段落可以在行首用一个Tab或者四个空格来实现，笔者一般喜欢用在行首输入一个制表符（点击一下Tab键）来实现。</p>
</blockquote>
<h3 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h3><p>三个或三个以上的减号、星号或者下划线。</p>
<blockquote>
<p>注释：因为减号也是第二阶标题的标记符号，所以如果使用减号表示分割线时，要保证减号的前一行没有内容，也就是要保持至少一行的空行。</p>
</blockquote>
<h3 id="在行内引入代码"><a href="#在行内引入代码" class="headerlink" title="在行内引入代码"></a>在行内引入代码</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`行内代码`</span><br></pre></td></tr></table></figure>
<p>效果：<br>这是<code>行内代码</code>效果</p>
<blockquote>
<p>注释：这个标记可以用来在正文的某一行中引入一句代码或者代码关键词。</p>
</blockquote>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| 学号		| 姓名		| 年龄 |</span><br><span class="line">| --------- |:---------:| ----:|</span><br><span class="line">| 1001		| 张三		|18 |</span><br><span class="line">| 1002		| 李四		|	17 |</span><br><span class="line">| 1003		| 王五		| 20 |</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th align="center">姓名</th>
<th align="right">年龄</th>
</tr>
</thead>
<tbody><tr>
<td>1001</td>
<td align="center">张三</td>
<td align="right">18</td>
</tr>
<tr>
<td>1002</td>
<td align="center">李四</td>
<td align="right">17</td>
</tr>
<tr>
<td>1003</td>
<td align="center">王五</td>
<td align="right">20</td>
</tr>
</tbody></table>
<blockquote>
<p>注释：有的Markdown解释器不支持表格语法。用减号表示表头分割线，冒号表示内容对齐方式。没有冒号表示默认左对齐，冒号在表头分割线左边表示左对齐，在右边表示右对齐，左右两边都有表示居中对齐。</p>
</blockquote>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>
<p>效果：<br>这是<del>删除线</del>效果</p>
<hr>
<h3 id="快速掌握"><a href="#快速掌握" class="headerlink" title="快速掌握"></a>快速掌握</h3><p>Markdown语法有很多标签，对于初学者来说，可以先从下面这个八个基本标签开始。实际上，这八个基本标签也是最经常使用到的标签，掌握这几个标签，基本上就可以胜任大部分的排版需求。</p>
<ul>
<li>标题 —&gt; <code>#</code></li>
<li>加粗 —&gt; <code>**加粗**</code></li>
<li>斜体 —&gt; <code>*斜体*</code></li>
<li>块引用 —&gt; <code>&gt;</code></li>
<li>链接 —&gt; <code>[]()</code></li>
<li>图片 —&gt; <code>![]()</code></li>
<li>列表 —&gt; <code>+</code></li>
<li>分割线 —&gt; <code>---</code></li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>发现一个比较系统的介绍 Markdown 写作的开源项目[Markdown for Science]（<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2thcnRoaWsvbWFya2Rvd25fc2NpZW5jZS93aWtpJUVGJUJDJTg5">https://github.com/karthik/markdown_science/wiki）<i class="fa fa-external-link-alt"></i></span> 。其中有一篇 Markdown 的入门教程 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NjaG9sbWQvc2Nob2xtZC93aWtpL0xlYXJuLW1hcmtkb3duLWluLTMtbWludXRlcw==">Learn markdown in 3 minutes<i class="fa fa-external-link-alt"></i></span> 写得通俗易懂。</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><span class="exturl" data-url="aHR0cDovL3dvd3VidW50dS5jb20vbWFya2Rvd24vaW5kZXguaHRtbA==">Markdown 语法说明 (简体中文版)<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>小提示：一般初学者可以先看Markdown语法的<span class="exturl" data-url="aHR0cDovL3dvd3VidW50dS5jb20vbWFya2Rvd24vYmFzaWMuaHRtbA==">快速入门<i class="fa fa-external-link-alt"></i></span>。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>TextMeshPro插件使用备忘</title>
    <url>/post/TextMeshPro%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/</url>
    <content><![CDATA[<h2 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h2><p>TextMeshPro 插件版本：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXNzZXRzdG9yZS51bml0eTNkLmNvbS9jbi8j">1.0.55.0b8<i class="fa fa-external-link-alt"></i></span> (Mar 31, 2017)</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>TextMeshPro字体的制作需要字体文件和字库文件。这里我用到的是黑体常规字体，这种字体可以直接去 Windows 系统的 <code>C:\Windows\Fonts</code> 目录下找。Unity开发中常用的有两种字库文件，一种是3500常用字库，一种是7000常用字库。如果应用中没有聊天功能，一般来说3500常用字库就够用了，出现个别不包含的文字，可以单独加进字库。这两种字库文件我都上传到了Github（<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0RhdmlkU2hlaC9Db21tb25DaGluZXNlQ2hhcmFjdGVy">字库链接点我<i class="fa fa-external-link-alt"></i></span>），有需要的可以自取。</p>
<h2 id="字体的制作"><a href="#字体的制作" class="headerlink" title="字体的制作"></a>字体的制作</h2><ol>
<li>将字体文件拖入到 Font Source 选项。接着设置Atlas Resolution 为2048 x 2048，设置 Character Set 选项为 Characters from File，其他选项保持默认就行。</li>
<li>设置完成后，点击 Generate Font Atlas 按钮，耐心等待程序处理完毕。稍等一会，按钮的下面会有个进度条开始走进度。</li>
<li>进度走完后， Save TextMeshPro Font Asset 按钮状态变为可点状态，点击按钮将生成的文件保存到 <code>TextMesh Pro/Resources/Fonts &amp; Materials</code>文件夹下。<blockquote>
<p>3500常用字和7000常用字的图集分辨率都建议设置为2048 x 2048，这种分辨率对这两种字库的显示效果是比较合适的。如果字库比较小的话，可以考虑其他分辨率，这个需要根据实际情况来定。</p>
</blockquote>
</li>
</ol>
<h2 id="替换插件默认设置"><a href="#替换插件默认设置" class="headerlink" title="替换插件默认设置"></a>替换插件默认设置</h2><p>字体制作完成后，使用菜单创建 TextMeshPro 组件，发现字体不是指定的字体，但是可以手动改变 Font Asset ， 这也太不智能了！能不能自动将默认的字体换成指定的字体呢？答案是肯定的。<br>在<code>TextMesh Pro/Resources</code> 目录下找到 TMP Settings 文件，然后选中该文件，在 Inspector 面板中有个 Default Font Asset 选项，接着将生成的字体文件拖入到该选项后，重新创建 TextMeshPro 组件时的字体就成了指定的字体了。</p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>TextMeshPro</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D安卓出包报错</title>
    <url>/post/Unity3D%E5%AE%89%E5%8D%93%E5%87%BA%E5%8C%85%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>今天又遇到了在安卓出包时，直接报错了两个错误，报错信息分别如下：</p>
<p>Installation failed with the following output:<br>    pkg: &#x2F;data&#x2F;local&#x2F;tmp&#x2F;Package.apk</p>
<p>UnityException: Unable to install APK!<br>Installation failed. See the Console for details.</p>
<p>两个错误信息的详细描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Installation failed with the following output:</span><br><span class="line">	pkg: /data/local/tmp/Package.apk</span><br><span class="line"></span><br><span class="line">Failure [INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE]</span><br><span class="line"></span><br><span class="line">5194 KB/s (24217926 bytes in 4.553s)</span><br><span class="line"></span><br><span class="line">UnityEditor.HostView:OnGUI()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UnityException: Unable to install APK!</span><br><span class="line">Installation failed. See the Console for details.</span><br><span class="line">UnityEditor.Android.PostProcessAndroidPlayer.ShowErrDlgAndThrow (System.String title, System.String message, System.Exception ex)</span><br><span class="line">UnityEditor.Android.PostProcessAndroidPlayer.ShowErrDlgAndThrow (System.String title, System.String message)</span><br><span class="line">UnityEditor.Android.PostProcessAndroidPlayer.UploadAndStartPlayer (System.String manifestName, System.String stagingArea, UnityEditor.Android.AndroidDevice device, System.String packageName, Boolean developmentPlayer, Boolean retryUpload)</span><br><span class="line">UnityEditor.Android.PostProcessAndroidPlayer.PostProcessInternal (System.String stagingAreaData, System.String stagingArea, System.String playerPackage, System.String installPath, System.String companyName, System.String productName, BuildOptions options, UnityEditor.RuntimeClassRegistry usedClassRegistry)</span><br><span class="line">UnityEditor.Android.PostProcessAndroidPlayer.PostProcess (BuildTarget target, System.String stagingAreaData, System.String stagingArea, System.String playerPackage, System.String installPath, System.String companyName, System.String productName, BuildOptions options, UnityEditor.RuntimeClassRegistry usedClassRegistry)</span><br><span class="line">UnityEditor.Android.AndroidBuildPostprocessor.PostProcess (BuildPostProcessArgs args)</span><br><span class="line">UnityEditor.PostprocessBuildPlayer.Postprocess (BuildTarget target, System.String installPath, System.String companyName, System.String productName, Int32 width, Int32 height, System.String downloadWebplayerUrl, System.String manualDownloadWebplayerUrl, BuildOptions options, UnityEditor.RuntimeClassRegistry usedClassRegistry) (at C:/buildslave/unity/build/Editor/Mono/BuildPipeline/PostprocessBuildPlayer.cs:316)</span><br><span class="line">UnityEditor.HostView:OnGUI()</span><br></pre></td></tr></table></figure>

<p>安卓出包时出现这个bug的原因，是因为当前项目的包名和手机上已安装的某个app包名相同，导致了冲突。解决办法就是直接将手机上导致冲突的app直接卸载掉就OK了。<br>这个bug已经遇到过多次了，是因为我在真机测试时装了一个测试程序，然后过了一段时间后，PlayerSettings中的某些设置被改变了，没有删除安装的测试包，就直接<code>Build And Run</code>，然后就报上述的错误了。<br>把这个Bug在博客里记录一下，加深点印象，顺便分享出去，希望能帮到遇到同样问题的朋友。</p>
<blockquote>
<p>如果本文有错误之处还请帮忙指出。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D集成腾讯语音GVoiceSDK</title>
    <url>/post/Unity3D%E9%9B%86%E6%88%90%E8%85%BE%E8%AE%AF%E8%AF%AD%E9%9F%B3GVoiceSDK/</url>
    <content><![CDATA[<blockquote>
<p>友情提示：最近发现腾讯GVoice有另一个官网，叫做<span class="exturl" data-url="aHR0cDovL2djbG91ZC5xcS5jb20vcHJvZHVjdC82">腾讯游戏服务<i class="fa fa-external-link-alt"></i></span>，经过对比发现这个网站才是最新的，下面我介绍的那个估计是已经废弃的，但不知道为啥老的网站没有直接链接到新网址而是仍然保留了。不过新官网的文档更加详细，SDK也有所更新，所以建议去新官网下载SDK和Demo，接入流程基本没有啥大变化。</p>
</blockquote>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>我们项目中用到了实时语音功能，在最初语音 SDK 技术选型的时候测试过融云、声网和腾讯的 GVoice 。融云和声网我都在我们项目中使用过，但是效果都不如王者荣耀游戏中的实时语音效果，这两天好好研究了一下腾讯的 GVoice，终于成功集成。由于腾讯 GVoice 官网的接入流程并不是很详细，如果只懂 Unity3D 不懂 Android 基础知识的朋友，可能接入过程不会一帆风顺。我虽了解一点点 Android 基础，但仍趟过了好几个坑，下面我就分享一下我在 Android 平台接入 GVoice 的过程。</p>
<h2 id="资源准备"><a href="#资源准备" class="headerlink" title="资源准备"></a>资源准备</h2><p>进入<span class="exturl" data-url="aHR0cHM6Ly93d3cucWNsb3VkLmNvbS9kb2N1bWVudC9wcm9kdWN0LzU1Ni83Njcz">腾讯GVoice官网<i class="fa fa-external-link-alt"></i></span>下载 GVoice SDK 和 Unity3D Demo。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/gvoice_1.jpg" alt="GVoice SDK.png"></p>
<h2 id="接入流程"><a href="#接入流程" class="headerlink" title="接入流程"></a>接入流程</h2><h3 id="1-导入SDK"><a href="#1-导入SDK" class="headerlink" title="1. 导入SDK"></a>1. 导入SDK</h3><p>先创建一个空的 Unity 项目 GVoiceDemo，按照官网的接入流程，我们直接将下载的SDK压缩包解压后将其中的 Plugins 和 Scripts 两个文件夹都拷贝到 Unity 项目中。</p>
<h3 id="2-创建-Jar-包"><a href="#2-创建-Jar-包" class="headerlink" title="2. 创建 Jar 包"></a>2. 创建 Jar 包</h3><p>将Unity项目导出成安卓项目，导出路径选择某个指定的文件夹，我这里在桌面新建了一个叫 unity_gvoicedemo 的文件夹，将项目导出到该文件夹中，操作如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/gvoice_2.jpg" alt="Export Project.png"><br>导出成功后会生成 GCloudVoice 和 GVoiceDemo 两个文件夹，用 eclipse 将这两个项目一起导入，如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/gvoice_3.jpg" alt="Import Projects.png"></p>
<p>导入成功后，在 UnityPlayerActivity 项目下新建一个 MainActivity 类，继承自 UnityPlayerActivity，详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shehweiwei.gvoicedemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tencent.gcloud.voice.GCloudVoiceEngine;</span><br><span class="line"><span class="comment">// 注意：下面这句代码必须有，如果没有可能会导致闪退</span></span><br><span class="line"><span class="keyword">import</span> com.unity3d.player.UnityPlayerActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">UnityPlayerActivity</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		GCloudVoiceEngine.getInstance().init(getApplicationContext(), <span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：代码中一定要引入<code>com.unity3d.player.UnityPlayerActivity</code>这个包，如果没有引入则进入应用就闪退，这里是个大坑，我好不容易才爬出来。</strong><br>然后，选中 MainActivity.java 文件，右键选择 Export -&gt; Java -&gt; JAR file， 然后点击 Next 按钮， 接下来操作如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/gvoice_4.jpg" alt="JAR Export.png"></p>
<p>最后，生成一个 GVoiceDemo.jar 文件。</p>
<h3 id="3-导入其他文件"><a href="#3-导入其他文件" class="headerlink" title="3. 导入其他文件"></a>3. 导入其他文件</h3><p>将下载的 unity_demo.zip 压缩包解压后将其中的 <code>unity_demo\Assets\Plugins\Android</code> 目录下的 AndroidManifest.xml 和 android-support-v4.jar 两个文件拷贝到项目的 <code>Plugins\Android</code> 目录下。注意还有个GCloudVoiceDemo.jar 文件我们没有拷贝，这里我们使用上一步创建的 GVoiceDemo.jar 文件来替代。注意 jar 包中的包名必须与 AndroidManifest.xml 文件和 Unity 编辑器中PlayerSettings的 Bundle Identifier 包名保持一致。所以，要把 AndroidManifest.xml 文件中的 <code>package=&quot;com.example.gcloudu3ddemo&quot;</code> 这一句代码修改成 <code>package=&quot;com.shehweiwei.gvoicedemo&quot;</code>。</p>
<p><strong>注意：</strong>AndroidManifest.xml 文件中的入口 Activity 的名字必须和创建的 Jar 包中的新建的 Activity 名字保持一致。这里的入口 Activity 叫 MainActivity，所以 AndroidManifest.xml  文件中的代码为<code>android:name=&quot;.MainActivity&quot;</code>，当然也可以写成 <code>android:name=&quot;com.example.gcloudu3ddemo.MainActivity&quot;</code></p>
<h3 id="4-构建Unity场景"><a href="#4-构建Unity场景" class="headerlink" title="4. 构建Unity场景"></a>4. 构建Unity场景</h3><p>这里我用uGUI搭建了一个简单的界面，有六个按钮分别调用 GVoice SDK 的六个 API ，然后一个 Text 用来显示回调结果。界面效果如下图：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/gvoice_5.jpg" alt="Create UI.png"><br>然后新建一个 GVoiceDemo 的 C# 脚本，脚本代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> gcloud_voice;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GVoiceDemo</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用来显示调用API返回的结果</span></span><br><span class="line">    <span class="keyword">public</span> Text result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IGCloudVoice m_voiceengine = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 这里的appId和appKey使用的是官方提供的测试值，正式项目中可使用申请的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> appId = <span class="string">&quot;932849489&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">string</span> appKey = <span class="string">&quot;d94749efe9fce61333121de84123ef9b&quot;</span>;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 这里使用的是测试账号，所以房间名使用默认的100，正式项目中可根据实际情况赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> roomName = <span class="string">&quot;100&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_voiceengine == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_voiceengine = GCloudVoice.GetEngine();</span><br><span class="line">            TimeSpan ts = DateTime.UtcNow - <span class="keyword">new</span> DateTime(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">string</span> strTime = System.Convert.ToInt64(ts.TotalSeconds).ToString();</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 这里用时间模拟了一个openId，在正式项目中应该把这里的strTime换成用户唯一ID</span></span><br><span class="line">            m_voiceengine.SetAppInfo(appId, appKey, strTime);</span><br><span class="line">            m_voiceengine.Init();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册SDK常用回调监听</span></span><br><span class="line">            m_voiceengine.OnJoinRoomComplete += OnJoinRoom;</span><br><span class="line">            m_voiceengine.OnQuitRoomComplete += OnExitRoom;</span><br><span class="line">            m_voiceengine.OnMemberVoice += OnMemberVoice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_voiceengine != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不断检测GVoice引擎回调</span></span><br><span class="line">            m_voiceengine.Poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnApplicationPause</span>(<span class="params"><span class="built_in">bool</span> pauseStatus</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_voiceengine == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应用暂停时GVoice引擎也暂停，应用重新开始时引擎继续</span></span><br><span class="line">        <span class="keyword">if</span> (pauseStatus)</span><br><span class="line">        &#123;</span><br><span class="line">            m_voiceengine.Pause();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_voiceengine.Resume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 加入房间，BtnJoin按钮点击调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">JoinRoom</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_voiceengine.SetMode(GCloudVoiceMode.RealTime);</span><br><span class="line">        <span class="built_in">int</span> ret = m_voiceengine.JoinTeamRoom(roomName, <span class="number">15000</span>);</span><br><span class="line"></span><br><span class="line">        result.text += <span class="string">&quot;\nJoinRoom:&quot;</span> + ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 退出房间，BtnExit按钮点击调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExitRoom</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> ret = m_voiceengine.QuitRoom(roomName, <span class="number">6000</span>);</span><br><span class="line">        result.text += <span class="string">&quot;\nExitRoom:&quot;</span> + ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 打开麦克风，BtnOpenMic按钮点击调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OpenMic</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> ret = m_voiceengine.OpenMic();</span><br><span class="line">        result.text += <span class="string">&quot;\nOpenMic:&quot;</span> + ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 关闭麦克风，BtnCloseMic按钮点击调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CloseMic</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> ret = m_voiceengine.CloseMic();</span><br><span class="line">        result.text += <span class="string">&quot;\nCloseMic:&quot;</span> + ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 打开扬声器，BtnOpenSpeaker按钮点击调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OpenSpeaker</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> ret = m_voiceengine.OpenSpeaker();</span><br><span class="line">        result.text += <span class="string">&quot;\nOpenSpeaker:&quot;</span> + ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 关闭扬声器，BtnCloseSpeaker按钮点击调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CloseSpeaker</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> ret = m_voiceengine.CloseSpeaker();</span><br><span class="line">        result.text += <span class="string">&quot;\nCloseSpeaker:&quot;</span> + ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 加入房间回调</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;code&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;roomName&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;memberID&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnJoinRoom</span>(<span class="params">IGCloudVoice.GCloudVoiceCompleteCode code, <span class="built_in">string</span> roomName, <span class="built_in">int</span> memberID</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        result.text += <span class="built_in">string</span>.Format(<span class="string">&quot;\nOnJoinRoom ---&gt; code: &#123;0&#125;, roomName: &#123;1&#125;, memberID: &#123;2&#125;&quot;</span>, code, roomName, memberID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 退出房间回调</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;code&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;roomName&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;memberID&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnExitRoom</span>(<span class="params">IGCloudVoice.GCloudVoiceCompleteCode code, <span class="built_in">string</span> roomName, <span class="built_in">int</span> memberID</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        result.text += <span class="built_in">string</span>.Format(<span class="string">&quot;\nOnExitRoom ---&gt; code: &#123;0&#125;, roomName: &#123;1&#125;, memberID: &#123;2&#125;&quot;</span>, code, roomName, memberID);</span><br><span class="line"></span><br><span class="line">        m_voiceengine.OnJoinRoomComplete -= OnJoinRoom;</span><br><span class="line">        m_voiceengine.OnQuitRoomComplete -= OnExitRoom;</span><br><span class="line">        m_voiceengine.OnMemberVoice -= OnMemberVoice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 有成员说话时回调</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;members&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;count&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnMemberVoice</span>(<span class="params"><span class="built_in">int</span>[] members, <span class="built_in">int</span> count</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        result.text += <span class="built_in">string</span>.Format(<span class="string">&quot;\nOnMemberVoice ---&gt; count: &#123;0&#125;, roomName: &#123;1&#125;, memberID: &#123;2&#125;&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 GVoiceDemo 脚本添加到Canvas对象上，然后将脚本中对应的方法注册到对应的按钮的OnClick事件上，保存场景，然后运行到手机上，使用两个手机就可以语音聊天了，效果如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/gvoice_6.jpg" alt="App.png"></p>
<h2 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h2><p>按照上面的流程集成完的项目并不能在PC上运行，如果要在PC上运行不报错，可以将下载的 unity_demo.zip 文件解压后的 <code>unity_demo\Assets\Plugins</code> 目录下的 X86 和 x86_64 两个文件夹拷贝到项目的 Plugins 文件夹下，这样PC上运行就不会报错。因为我这里没有麦克风设备，不知道在PC上能不能使用语音聊天，有条件的朋友可以试试，有结果了可以反馈给我，先谢过了！</p>
<h2 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h2><p>我把项目的源码托管在了Github上了， 有需要的朋友自取。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0RhdmlkU2hlaC9HVm9pY2VEZW1vLw==">项目链接点这里<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>GVoice</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity插件之Unity调用C#编译的DLL</title>
    <url>/post/Unity%E6%8F%92%E4%BB%B6%E4%B9%8BUnity%E8%B0%83%E7%94%A8C_Sharp%E7%BC%96%E8%AF%91%E7%9A%84DLL/</url>
    <content><![CDATA[<p>Unity插件分为两种：托管插件（Managed Plugins）和本地插件（Native Plugins）。本文先来说说Unity中的托管插件，本地插件的文章留到下一篇文章再说。<br>有时候我们会有这样的需求：给第三方公司提供Unity插件，而又不希望第三方看到具体代码，这时就可以将核心代码编译成dll文件供第三方调用。或者说，同一个公司多个项目都用到某个模块，则可以把该模块封装成dll，方便在不同项目之间共用和维护。</p>
<blockquote>
<p>关于dll加密的问题，以后有机会了可以考虑写点东西分享出来。</p>
</blockquote>
<p><strong>一、创建DLL</strong></p>
<hr>
<p>打开VS，选择文件 -&gt; 新建 -&gt; 项目后打开新建项目对话框。接着操作如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/unity_csharp_dll_1.jpg" alt="新建项目.png"></p>
<p>点击确定后，编写如下代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyLib</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetBlogName</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Sheh伟伟的个人博客&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TimeSpan <span class="title">GetBlogTime</span>(<span class="params">DateTime time</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (time - DateTime.Parse(<span class="string">&quot;2016/11/14&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后生成dll文件，操作如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/unity_csharp_dll_2.jpg" alt="build.png"></p>
<blockquote>
<p>提示：也可以用MonoDeveloper创建并生成dll，至于操作步骤可以查看<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9Vc2luZ0RMTC5odG1s">官网手册<i class="fa fa-external-link-alt"></i></span>。</p>
</blockquote>
<p><strong>二、导入DLL</strong></p>
<hr>
<p>将MyLib项目目录下的bin&#x2F;Debug目录下的MyLib.dll文件拷贝到Unity项目的Plugins目录下。这时，Unity控制台报Unhandled Exception: System.Reflection.ReflectionTypeLoadException: The classes in the module cannot be loaded的错误，报错详细信息如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/unity_csharp_dll_3.jpg" alt="error.png"></p>
<p>这是因为我用的Unity版本是5.3.4f1，支持的.NET Framework的版本为3.5。而我创建的MyLib项目的默认.NET Framework 版本为4.5.2。<br>选择项目，然后右键选择属性 -&gt; 应用程序，将目标框架改为 .NET Framework 3.5或以下 ，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/unity_csharp_dll_4.jpg"><br>接着重新生成一下dll文件，重新导入到Unity就行了。</p>
<p><strong>三、调用DLL</strong></p>
<hr>
<p>在Unity新建一个TestDll的脚本，并挂到主摄像机上，脚本代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> MyLib; <span class="comment">// 导入dll</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDll</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> blogUrl = <span class="string">&quot;https://davidsheh.github.io/&quot;</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> myBlog = <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125;:&#123;1&#125;&quot;</span>, MyClass.GetBlogName(), blogUrl);</span><br><span class="line">        Debug.Log(myBlog);</span><br><span class="line"></span><br><span class="line">        TimeSpan span = MyClass.GetBlogTime(DateTime.Now);</span><br><span class="line">        Debug.Log(<span class="string">&quot;写这篇博客到现在的时间间隔：&quot;</span> + span.TotalDays);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，调用Dll中的方法一定要使用using语句引入导入到unity中的dll类库。</p>
<p><strong>四、导入Unity DLL</strong></p>
<hr>
<p>怎么导入Unity原生类库呢？别急，接下来就说说怎么在自定义的dll类库中调用Unity中的类。<br>首先选中项目，接着右键选择添加 -&gt; 引用后，弹出引用管理器，如下图：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/unity_csharp_dll_5.jpg" alt="添加引用.png"></p>
<p>在应用管理器界面点击浏览按钮，找到UnityEngine.dll文件点击确认按钮导入，如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/unity_csharp_dll_6.jpg" alt="引用管理器.png"></p>
<blockquote>
<p>Unity类库在Mac上的路径为<code>Applications/Unity.app/Contents/Frameworks/Managed/UnityEngine.dll</code>；在Windows上的路径为<code>Program Files\Unity\Editor\Data\Managed\UnityEngine.dll</code>。</p>
</blockquote>
<p>接着，将项目中无用的类库都移除掉，只保留用到的System和UnityEngine两个类库，如下图：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/unity_csharp_dll_7.jpg" alt="引用.png"></p>
<p>然后，修改MyClass脚本，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyLib</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetBlogName</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Sheh伟伟的个人博客&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TimeSpan <span class="title">GetBlogTime</span>(<span class="params">DateTime time</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (time - DateTime.Parse(<span class="string">&quot;2016/11/13&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateCube</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            GameObject go = GameObject.CreatePrimitive(PrimitiveType.Cube);</span><br><span class="line">            <span class="built_in">int</span> random = UnityEngine.Random.Range(<span class="number">-5</span>, <span class="number">5</span>);</span><br><span class="line">            go.transform.position = <span class="keyword">new</span> Vector3(random, random, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码编写完成后，重新生成一下dll，然后导入到Unity中，接着修改Unity脚本TesDll，具体代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> MyLib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDll</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> blogUrl = <span class="string">&quot;https://davidsheh.github.io/&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> myBlog;</span><br><span class="line">    <span class="built_in">double</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span></span><br><span class="line">    &#123;</span><br><span class="line">        myBlog = <span class="built_in">string</span>.Format(<span class="string">&quot;&#123;0&#125;:&#123;1&#125;&quot;</span>, MyClass.GetBlogName(), blogUrl);</span><br><span class="line">        Debug.Log(myBlog);</span><br><span class="line"></span><br><span class="line">        TimeSpan span = MyClass.GetBlogTime(DateTime.Now);</span><br><span class="line">        time = span.TotalDays;</span><br><span class="line">        Debug.Log(<span class="string">&quot;写这篇博客到现在的时间间隔：&quot;</span> + time);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GUILayout.Label(myBlog);</span><br><span class="line">        GUILayout.Label(time.ToString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(GUILayout.Button(<span class="string">&quot;Create Cube&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            MyClass.CreateCube();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后的效果图如下：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/unity_csharp_dll_8.jpg" alt="效果图.png"></p>
<blockquote>
<p>源代码放在了群共享中，想要源码的可以加群：253999688</p>
</blockquote>
<p><strong>四、参考资料</strong></p>
<hr>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9Vc2luZ0RMTC5odG1s">Managed Plugins<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<blockquote>
<p>如果本文有错误之处还请帮忙指出。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity路径的相关总结</title>
    <url>/post/Unity%E8%B7%AF%E5%BE%84%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="Unity中的路径变量"><a href="#Unity中的路径变量" class="headerlink" title="Unity中的路径变量"></a>Unity中的路径变量</h3><table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">属性</th>
<th align="left">使用情景</th>
<th align="left">其他说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Application.dataPath</td>
<td align="left">只读</td>
<td align="left">应用数据文件夹的路径</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Application.streamingAssetsPath</td>
<td align="left">只读</td>
<td align="left">资源跟随App发布时使用</td>
<td align="left">Android下不存在物理文件，不要用System.IO.File 访问</td>
</tr>
<tr>
<td align="left">Application.temporaryCachePath</td>
<td align="left">读写</td>
<td align="left">下载临时资源时使用</td>
<td align="left">设备的临时数据缓存目录。存储空间不足时，会被操作系统清理</td>
</tr>
<tr>
<td align="left">Application.persistentDataPath</td>
<td align="left">读写</td>
<td align="left">资源热更新时使用</td>
<td align="left">iOS&#x2F;Android设备中的持久化数据存储目录，可以在此路径下存储一些持久化的数据文件，该目录下的文件不会因为App升级而删除。iOS下注意关闭 iClound 同步，否则可能提审被拒</td>
</tr>
</tbody></table>
<h3 id="不同平台下的路径"><a href="#不同平台下的路径" class="headerlink" title="不同平台下的路径"></a>不同平台下的路径</h3><table>
<thead>
<tr>
<th align="left">路径变量</th>
<th align="left">Windows</th>
<th align="left">Android</th>
<th align="left">iOS</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Application.dataPath</td>
<td align="left">应用的路径&#x2F;appname _Data</td>
<td align="left">&#x2F;data&#x2F;app&#x2F;package name-1&#x2F;base.apk</td>
<td align="left">&#x2F;var&#x2F;containers&#x2F;Bundle&#x2F;Application&#x2F;app sandbox&#x2F;xxx.app&#x2F;Data</td>
</tr>
<tr>
<td align="left">Application.streamingAssetsPath</td>
<td align="left">应用路径&#x2F;appname _Data &#x2F;StreamingAssets</td>
<td align="left">jar:file:&#x2F;&#x2F;&#x2F;data&#x2F;app&#x2F;package name-1&#x2F;base.apk!&#x2F;assets</td>
<td align="left">&#x2F;var&#x2F;containers&#x2F;Bundle&#x2F;Application&#x2F;app sandbox&#x2F;test.app&#x2F;Data&#x2F;Raw</td>
</tr>
<tr>
<td align="left">Application.temporaryCachePath</td>
<td align="left">C:\Users\username\AppData\Local\Temp\company name\product name</td>
<td align="left"><strong>Internal Only:</strong> &#x2F;data&#x2F;user&#x2F;0&#x2F;package name&#x2F;cache <strong>External(SDCard):</strong>  &#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;package name&#x2F;cache</td>
<td align="left">&#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;app sandbox&#x2F;Library&#x2F;Caches</td>
</tr>
<tr>
<td align="left">Application.persistentDataPath</td>
<td align="left">C:\Users\username\AppData\LocalLow\company name\product name</td>
<td align="left"><strong>Internal Only:</strong> &#x2F;data&#x2F;user&#x2F;0&#x2F; package name&#x2F;files            <strong>External(SDCard):</strong>  &#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;package name&#x2F;files</td>
<td align="left">&#x2F;var&#x2F;mobile&#x2F;Containers&#x2F;Data&#x2F;Application&#x2F;app sandbox&#x2F;Documents</td>
</tr>
</tbody></table>
<blockquote>
<p>说明：Android平台下的路径会根据SD卡的访问权限不同而不同。至于iOS有没有类似的情况，由于没有相关设备，暂时没有测试。有条件的朋友可以帮我测试一下，我用5.3.4f1版本的Unity写了个简单的测试程序，项目链接：<span class="exturl" data-url="aHR0cDovL3Bhbi5iYWlkdS5jb20vcy8xZ2ZxbU9SaCVFMyU4MCU4Mg==">http://pan.baidu.com/s/1gfqmORh。<i class="fa fa-external-link-alt"></i></span> 欢迎测试反馈，不胜感激！</p>
</blockquote>
<h3 id="常用工具方法"><a href="#常用工具方法" class="headerlink" title="常用工具方法"></a>常用工具方法</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取不同平台的流式加载路径</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;filename&quot;&gt;</span>文件名<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetStreamingFilePath</span>(<span class="params"><span class="built_in">string</span> filename</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> path = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Application.platform == RuntimePlatform.OSXEditor || Application.platform == RuntimePlatform.OSXPlayer ||</span><br><span class="line">            Application.platform == RuntimePlatform.WindowsEditor || Application.platform == RuntimePlatform.WindowsPlayer)</span><br><span class="line">        &#123;</span><br><span class="line">            path = Application.dataPath + <span class="string">&quot;/StreamingAssets/&quot;</span> + filename;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Application.platform == RuntimePlatform.IPhonePlayer)</span><br><span class="line">        &#123;</span><br><span class="line">            path = Application.dataPath + <span class="string">&quot;/Raw/&quot;</span> + filename;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Application.platform == RuntimePlatform.Android)</span><br><span class="line">        &#123;</span><br><span class="line">            path = <span class="string">&quot;jar:file://&quot;</span> + Application.dataPath + <span class="string">&quot;!/assets/&quot;</span> + filename;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            path = Application.dataPath + <span class="string">&quot;/config/&quot;</span> + filename;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取不同平台的持久化数据存储路径</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;filename&quot;&gt;</span>文件名<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetPersistentFilePath</span>(<span class="params"><span class="built_in">string</span> filename</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> filepath = Application.persistentDataPath + <span class="string">&quot;/&quot;</span> + filename;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_IPHONE</span></span><br><span class="line">        <span class="comment">// Set file flag to be excluded from iCloud/iTunes backup.</span></span><br><span class="line">        UnityEngine.iOS.Device.SetNoBackupFlag(filepath);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> filepath;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Resources-VS-StreamingAssets"><a href="#Resources-VS-StreamingAssets" class="headerlink" title="Resources VS. StreamingAssets"></a>Resources VS. StreamingAssets</h3><ol>
<li>Resources文件夹</li>
</ol>
<p>Resources文件夹是一个只读的文件夹，通过Resources.Load()来读取对象。因为这个文件夹下的所有资源都可以运行时来加载，所以Resources文件夹下的所有东西都会被无条件的打到发布包中。建议这个文件夹下只放Prefab或者一些Object对象，因为Prefab会自动过滤掉对象上不需要的资源。举个例子我把模型文件还有贴图文件都放在了Resources文件夹下，但是我有两张贴图是没有在模型上用的，那么此时这两张没用的贴图也会被打包到发布包中。假如这里我用Prefab，那么Prefab会自动过滤到这两张不被用的贴图，这样发布包就会小一些了。 </p>
<ol start="2">
<li>StreamingAssets</li>
</ol>
<p>StreamingAssets文件夹也是一个只读的文件夹，但是它和Resources有点区别，Resources文件夹下的资源会进行一次压缩，而且也会加密，不使用点特殊办法是拿不到原始资源的。但是StreamingAssets文件夹就不一样了，它下面的所有资源不会被加密，然后是原封不动的打包到发布包中，这样很容易就拿到里面的文件。所以StreamingAssets适合放一些二进制文件，而Resources更适合放一些GameObject和Object文件。StreamingAssets 只能用过www类来读取！！</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQveW5ubW5tL2FydGljbGUvZGV0YWlscy81MjI1MzY3NA==">Unity3D各平台Application.xxxPath的路径<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9tdXJvbmd4aWFvcGlmdS9wLzQxOTk1NDEuaHRtbA==">Unity3D移动平台动态读取外部文件全解析<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy50dWljb29sLmNvbS9hcnRpY2xlcy9JTjdSWmZ6">Unity各种路径<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9BcHBsaWNhdGlvbi5odG1s">Unity官方文档<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建免费稳定的个人博客图床</title>
    <url>/post/blog-pic-bed/</url>
    <content><![CDATA[<p>免费的图床有很多，比如说 <span class="exturl" data-url="aHR0cHM6Ly9zbS5tcy8=">sm.ms<i class="fa fa-external-link-alt"></i></span>、微博图床、七牛云，这几个图床在个人微博中用的是比较多的。虽然它们都是免费的，但是有很多限制，网上看到的资料说是后面两个托管的图片地址可能会变化，这对于个人博客来说就很要命了。有一次灵光一闪，既然 GitHub 上可以托管博客，那么博客图片能不能也托管到 GitHub 呢？百度一下，果然有人这么做。然后，我也尝试了一下使用 GitHub 作为个人博客的图床，以下是用 GitHub 搭建图床的过程以及遇到的问题。</p>
<h2 id="为什么要选择-GitHub-作为博客图床？"><a href="#为什么要选择-GitHub-作为博客图床？" class="headerlink" title="为什么要选择 GitHub 作为博客图床？"></a>为什么要选择 GitHub 作为博客图床？</h2><ol>
<li>免费无限制。GitHub 的公共仓库是免费的，没有广告，没有流量限制也不产生流量费用，没有图片多少限制。</li>
<li>稳定。GitHub 是全球最大的开源平台，仓库稳定，没有防盗链，图片 URL 固定不变。（ GFW 导致的图片链接失效除外，下面会说到这个问题）</li>
<li>对程序员友好。让图片可以像代码一样版本控制。</li>
</ol>
<h2 id="如何搭建-GitHub-图床？"><a href="#如何搭建-GitHub-图床？" class="headerlink" title="如何搭建 GitHub 图床？"></a>如何搭建 GitHub 图床？</h2><ol>
<li>注册 GitHub 账号。</li>
<li>创建一个公共仓库。我的图床仓库叫 <code>BlogPictures</code>。</li>
<li>用 Git 将仓库克隆到本地。什么？你不会 Git，玩笑开大了吧？<span class="exturl" data-url="aHR0cHM6Ly9kYXZpZHNoZWguZ2l0aHViLmlvL3Bvc3QvR2l0JUU1JUJGJUFCJUU5JTgwJTlGJUU1JTg1JUE1JUU5JTk3JUE4Lw==">Git快速入门<i class="fa fa-external-link-alt"></i></span>了解一下。</li>
<li>上传图片。将需要上传的图片放到仓库中，用 Git Push 到远程仓库。可以在仓库中建一个文件夹专门放图片，也可以直接放在仓库根目录。我的博客图片都放在图床仓库的 <code>pictures</code> 文件夹下。</li>
</ol>
<p>以上四步完成后，图床就创建好了，是不是非常简单？跟代码仓库的操作一样。</p>
<h2 id="如何使用-GitHub-图床中的图片？"><a href="#如何使用-GitHub-图床中的图片？" class="headerlink" title="如何使用 GitHub 图床中的图片？"></a>如何使用 GitHub 图床中的图片？</h2><p>用浏览器打开刚刚的仓库，然后点击刚刚上传的图片后，会在浏览器的地址栏里面显示一个 URL，比如说笔者图床里面的一张图片的浏览器地址栏显示的 URL 是 <code>https://github.com/DavidSheh/BlogPictures/blob/master/pictures/DoodleJump.jpeg</code>。在博客中使用 <code>![DoodleJump](https://github.com/DavidSheh/BlogPictures/blob/master/pictures/DoodleJump.jpeg)</code> 的语法插入这张图片时，发现图片显示不了。其实图片的真实地址是 <code>https://raw.githubusercontent.com/DavidSheh/BlogPictures/master/pictures/DoodleJump.jpeg</code>，把上面 Markdown 中的地址换成这个就能正常显示了。这个地址是怎么来的呢？可以点击 Download 按钮，这时的浏览器地址栏显示的地址才是图片的真实地址。如下图：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/github_download_btn.png" alt="github_download_btn"></p>
<h2 id="怎么解决-GitHub-图床图片被墙的问题？"><a href="#怎么解决-GitHub-图床图片被墙的问题？" class="headerlink" title="怎么解决 GitHub 图床图片被墙的问题？"></a>怎么解决 GitHub 图床图片被墙的问题？</h2><p>由于众所周知的原因，虽然国内目前大多数时候可以访问 GitHub，但仓库里面的图片可能一直没法加载出来。所以，博客中插入的 GitHub 仓库中的图片肯定也没法显示。遇到这种情况怎么办呢？答案是上 CDN。但是 CDN 大部分都是要钱的，有没有免费又稳定的 CDN 呢？当然也是有的，那就是 <span class="exturl" data-url="aHR0cHM6Ly93d3cuanNkZWxpdnIuY29tLw==">jsDelivr<i class="fa fa-external-link-alt"></i></span>——开源、快速、可信赖和自动化的免费CDN。因为我所用的博客主题 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0">NexT<i class="fa fa-external-link-alt"></i></span> 中的很多 js 组件就是用的这个 CDN 来加速的。<br>使用方法也超级简单，只需要把图片地址中的 <code>https://raw.githubusercontent.com/DavidSheh/BlogPictures/master</code> 的部分替换成 <code>https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures</code> 就搞定了。使用 CDN 加速后，国内用户访问博客也会很快。</p>
<h2 id="图床工具"><a href="#图床工具" class="headerlink" title="图床工具"></a>图床工具</h2><p>如果按照上面的步骤，每次都要手动上传图片，然后用浏览器打开仓库找到图片的真实地址，然后插入文章中，这个流程无疑是很繁琐的。这里推荐一款开源软件 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01vbHVuZXJmaW5uL1BpY0dv">PicGo<i class="fa fa-external-link-alt"></i></span>，我使用的是它的 VS Code 插件。使用步骤如下：</p>
<ol>
<li>安装 PicGo 插件。</li>
<li>打开插件的 Settings 界面。如下图：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/picgo-settings.png" alt="picgo-settings"></li>
<li>配置参数。具体参考 <span class="exturl" data-url="aHR0cHM6Ly9waWNnby5naXRodWIuaW8vUGljR28tRG9jL3poL2d1aWRlL2NvbmZpZy5odG1sI2dpdGh1YiVFNSU5QiVCRSVFNSVCQSU4QQ==">PicGo 配置手册中的 GitHub 图床配置<i class="fa fa-external-link-alt"></i></span>.<ol>
<li>Pic Bed 选 <code>github</code>。</li>
<li>Custom Url 填<code>https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures</code>。因为图床图片需要 CDN 加速，所以这里需要填 CDN 地址，这样就能自动替换 GitHub 原始地址。</li>
<li>Branch 填 <code>master</code>。如果图床图片放在其他分支，这里就不能填 <code>mater</code> 了，而要填对应分支的名称。</li>
<li>Path 填 <code>pictures/</code>。如果图片放在仓库根目录，这里留空就行。</li>
<li>Repo 填 <code>DavidSheh/BlogPictures</code>。这里要填自己的 <code>账户名/仓库名</code>。</li>
<li>Token 填 GitHub 中生成的。GitHub 账号 -&gt; Settings -&gt; Developer Settings -&gt; Personal Access tokens -&gt; Generate new token -&gt; 勾选 repo -&gt; Generate token -&gt; 拷贝 token。<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/picgo-config.png" alt="picgo-config"></li>
</ol>
</li>
<li>上传图片并自动插入到文章。打开一个 Markdown 文件，使用快捷键 <code>Ctrl + Alt + E</code> 打开 Windows 文件浏览器选中要上传的图片，然后等待上传完毕后，会自动在 Markdown 文件中的光标处插入一句 Markdown 语法。</li>
</ol>
<h2 id="优化博客图片访问速度"><a href="#优化博客图片访问速度" class="headerlink" title="优化博客图片访问速度"></a>优化博客图片访问速度</h2><p>已经使用了 CDN 来加速图片的显示了，还有没有优化空间呢？这里还有一种手段可以优化，那就是压缩图片。本来以 MB 为单位的图片可以优化到以 KB 为单位。这里推荐一个在线压缩图片的工具：<span class="exturl" data-url="aHR0cHM6Ly90aW55cG5nLmNvbS8=">TinyPng<i class="fa fa-external-link-alt"></i></span>。将图片上传到图床仓库前，可以先用这款工具压缩一下。</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>图床</tag>
        <tag>GitHub</tag>
        <tag>PicGo</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 中常见的易混淆概念</title>
    <url>/post/csharp-some-confused/</url>
    <content><![CDATA[<h2 id="虚方法和抽象方法的区别"><a href="#虚方法和抽象方法的区别" class="headerlink" title="虚方法和抽象方法的区别"></a>虚方法和抽象方法的区别</h2><ul>
<li>抽象方法在抽象类中定义，并且没有方法体，要求派生的非抽象子类必须重写抽象方法。</li>
<li>虚方法在抽象类和非抽象类中都可以定义，有默认方法体，派生子类可以使用 <code>override</code> 关键字覆盖父类虚方法，但也可以不重写父类的虚方法。</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQ3Mjg3NjEvZGlmZmVyZW5jZS1iZXR3ZWVuLXZpcnR1YWwtYW5kLWFic3RyYWN0LW1ldGhvZHM=">Difference between virtual and abstract methods [duplicate]
<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><ul>
<li>抽象类中可以包含抽象方法和其他方法，接口中只能包含抽象方法。</li>
<li>一个类只能继承一个抽象类，但是可以实现多个接口。</li>
<li>抽象类和接口都不能实例化。</li>
<li>抽象类可以有构造函数，而接口没有</li>
</ul>
<h3 id="抽象类使用情景"><a href="#抽象类使用情景" class="headerlink" title="抽象类使用情景"></a>抽象类使用情景</h3><p>当我们需要一个包含一些公共属性的类或具有某些公共属性的方法时，这些属性的实现对于不同的类是不同的，在这种情况下，最好使用抽象类而不是接口。</p>
<p>使用抽象类来限制用户创建父类的对象，因为创建父类对象就无法调用子类方法。因此，开发人员必须通过将父类对象定义为抽象类来限制其意外创建。</p>
<h3 id="接口使用情景"><a href="#接口使用情景" class="headerlink" title="接口使用情景"></a>接口使用情景</h3><p>接口可以提供多重继承的解决方案。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYy1zaGFycGNvcm5lci5jb20vYXJ0aWNsZS93aGVuLXRvLXVzZS1hYnN0cmFjdC1jbGFzcy1hbmQtaW50ZXJmYWNlLWluLXJlYWwtdGltZS1wcm9qZWN0cy8=">When To Use Abstract Class and Interface In Real Projects<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="值类型和引用类型的区别"><a href="#值类型和引用类型的区别" class="headerlink" title="值类型和引用类型的区别"></a>值类型和引用类型的区别</h2><ol>
<li>值类型在栈上分配内存，引用类型在堆上分配内存。如果值类型是引用类型的成员（例如字段或保留在数组中），则它将在堆上分配内存。在方法范围中声明值类型变量（即局部变量）时，它们将在堆栈上分配内存。</li>
<li>值类型继承自 System.ValueType，引用类型继承自 System.Object。</li>
<li>值类型表示实际数据，引用类型表示对象实例在堆中分配好内存以后，需要在栈中保存一个4字节的堆内存地址，用来定位该对象实例在堆中的位置，便于找到该对象实例。</li>
<li>栈由系统自动分配，不需要垃圾回收，速度较快。但程序员是无法控制的；而堆是由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片且需要 GC 回收内存，不过用起来最方便。</li>
</ol>
<blockquote>
<p>尽管在当前的实现中，引用类型总是分配在堆上，但是值类型可以分配在堆栈上，但不一定。仅当值类型是未装箱的，未转义的局部或临时变量且未包含在引用类型中且未在寄存器中分配时，才在堆栈上分配值类型。</p>
<ul>
<li>如果值类型是类的一部分（如您的示例所示），它将最终出现在堆上。</li>
<li>如果装箱，它将最终放在堆上。</li>
<li>如果在数组中，它将最终在堆上。</li>
<li>如果它是一个静态变量，它将最终在堆上。</li>
<li>如果被闭包捕获，它将最终在堆上。</li>
<li>如果在迭代器或异步块中使用它，它将最终出现在堆上。</li>
<li>如果它是由不安全或不受管理的代码创建的，则可以在任何类型的数据结构（不一定是堆栈或堆）中分配它。<br>参考：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ0ODczMjAvNjI4OTAyOA==">https://stackoverflow.com/a/4487320/6289028<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</blockquote>
<h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><ul>
<li>浅拷贝是指将对象中的数值类型的字段拷贝到新的对象中，而对象中的引用型字段则指复制它的一个引用到目标对象。如果改变目标对象中引用型字段的值他将反映在原始对象中，也就是说原始对象中对应的字段也会发生变化。</li>
<li>深拷贝与浅拷贝不同的是对于引用的处理，深拷贝将会在新对象中创建一个新的和原始对象中对应字段相同（内容相同）的字段，也就是说这个引用和原始对象的引用是不同的，我们在改变新对象中的这个字段的时候是不会影响到原始对象中对应字段的内容。</li>
<li>参考链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcGVyc29uYmxvZy9wLzExMzA4ODMxLmh0bWw=">https://www.cnblogs.com/personblog/p/11308831.html<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="强引用和弱引用"><a href="#强引用和弱引用" class="headerlink" title="强引用和弱引用"></a>强引用和弱引用</h2><ul>
<li>强引用最终导致的结果就是被引用的对象的被引用次数+1。</li>
<li>弱引用不会对被引用对象的被引用次数有任何影响。</li>
<li>弱引用允许垃圾收集器收集对象，同时仍允许应用程序访问该对象。如果需要该对象，仍然可以对其进行强引用并防止其被收集。</li>
<li>避免对小对象使用弱引用，因为指针可能比小对象还大。</li>
<li>参考链接：<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvZG90bmV0L2FwaS9zeXN0ZW0ud2Vha3JlZmVyZW5jZT9yZWRpcmVjdGVkZnJvbT1NU0ROJnZpZXc9bmV0LTUuMA==">WeakReference Class<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvZG90bmV0L3N0YW5kYXJkL2dhcmJhZ2UtY29sbGVjdGlvbi93ZWFrLXJlZmVyZW5jZXM=">Weak References<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
<h2 id="修饰符-ref-和-out-的区别"><a href="#修饰符-ref-和-out-的区别" class="headerlink" title="修饰符 ref 和 out 的区别"></a>修饰符 <code>ref</code> 和 <code>out</code> 的区别</h2><ul>
<li><code>ref</code> 表示变量进入方法前已经被初始化了，而且方法可以读取和修改变量。</li>
<li><code>out</code> 表示变量值未被初始化，将在方法内初始化，且变量在方法 <code>return</code> 前必须初始化。</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzg4NDY0L3doYXRzLXRoZS1kaWZmZXJlbmNlLWJldHdlZW4tdGhlLXJlZi1hbmQtb3V0LWtleXdvcmRz">What’s the difference between the ‘ref’ and ‘out’ keywords?<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="struct-和-class-的区别"><a href="#struct-和-class-的区别" class="headerlink" title="struct 和 class 的区别"></a>struct 和 class 的区别</h2><ul>
<li>struct 是值类型，而 class 是引用类型</li>
<li>使用结构类型来设计以数据为中心的较小类型，这些类型只有很少的行为或没有行为。 例如，<code>.NET</code> 使用结构类型来表示数字（整数和实数）、布尔值、<code>Unicode</code> 字符以及时间实例。 如果侧重于类型的行为，请考虑定义一个类。类类型具有引用语义。也就是说，类类型的变量包含的是对类型的实例的引用，而不是实例本身。<br>由于结构类型具有值语义，因此建议定义不可变的结构类型。</li>
<li>在 <code>struct</code> 中使用引用类型字段要特别注意。因为 <code>struct</code> 是值类型，不可变，引用类型是可变的，将一个 <code>struct</code> 类型的变量赋值给另一个变量时，更改引用类型的变量会导致两个变量都变化了，这是很危险的。所以一般不建议在 <code>struct</code> 中使用引用类型变量，如果一定要使用的话，建议给变量加上 <code>readonly</code> 关键字。具体解释请参考：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTQ1NjY0L2Nhbi1zdHJ1Y3RzLWNvbnRhaW4tZmllbGRzLW9mLXJlZmVyZW5jZS10eXBlcw==">https://stackoverflow.com/questions/945664/can-structs-contain-fields-of-reference-types<i class="fa fa-external-link-alt"></i></span> 。</li>
</ul>
<h2 id="用-struct-enum-类型作字典的键"><a href="#用-struct-enum-类型作字典的键" class="headerlink" title="用 struct&#x2F;enum 类型作字典的键"></a>用 struct&#x2F;enum 类型作字典的键</h2><p>用自定义 struct&#x2F;enum 类型作为 Dictionary 的 key，即使使用了泛型，也有可能会产生大量 GC。原因是：</p>
<ol>
<li>Dictionary 在索引的时候，先会获取哈希值，再去相同的哈希值链表里找对应的元素，这个过程需要调用GetHashCode和Equals方法，如果struct没有重写GetHashCode和实现IEquatable接口，那么这两个过程就会触发装箱操作，所以，准确的说，自定义值类型当然可以用作泛型集合的类型参数，这往往是性能提升的一大优势，但自定义值类型要记得重写GetHashCode和实现IEquatable接口，正确使用值类型才能发挥性能优势。</li>
<li>泛型不是单纯为避免装箱拆箱设计的，避免拆箱装箱是.Net类库在泛型设计上的一个额外优势，泛型设计的初始目的或主要目的是解决代码的重复设计，提供通用的代码模板。</li>
<li>struct 需要实现 IEquatable 的 Equals() 和 GetHashCode() 方法来避免 GC。</li>
</ol>
<h2 id="Equals-和-的区别"><a href="#Equals-和-的区别" class="headerlink" title="Equals 和 == 的区别"></a><code>Equals</code> 和 <code>==</code> 的区别</h2><ul>
<li><code>==</code> 比较对象引用；<code>Equals</code> 比较对象内容。</li>
<li><code>Equals</code><ol>
<li>如果操作数是引用类型，则它执行对象的 <code>Equals</code> 方法来返回结果。一般地，需要重写类的 <code>Equals</code> 方法。</li>
<li>如果操作数是值类型，则与 <code>==</code> 运算符不同，它首先检查其类型，如果它们的类型相同，则执行 <code>==</code> 运算符，否则返回 <code>false</code>。</li>
</ol>
</li>
<li><code>==</code><ol>
<li>如果操作数是值类型并且它们的值相等，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li>如果操作数是引用类型（字符串除外），并且都引用同一实例（同一对象），则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li>如果操作数是字符串类型且它们的值相等，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ol>
</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODE0ODc4L2Mtc2hhcnAtZGlmZmVyZW5jZS1iZXR3ZWVuLWFuZC1lcXVhbHM=">C# difference between &#x3D;&#x3D; and Equals()<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="IComparable-和-IComparer-两个比较接口的区别和用法"><a href="#IComparable-和-IComparer-两个比较接口的区别和用法" class="headerlink" title="IComparable 和 IComparer 两个比较接口的区别和用法"></a><code>IComparable</code> 和 <code>IComparer</code> 两个比较接口的区别和用法</h2><p><code>IComparable</code> 和 <code>IComparer</code> 是.NET Framework中用于对象比较和排序的接口。它们之间的区别和用法如下：</p>
<h4 id="IComparable"><a href="#IComparable" class="headerlink" title="IComparable"></a><code>IComparable</code></h4><p><code>IComparable</code> 是一个用于比较单个对象不同状态的接口，它定义了一个方法 <code>int CompareTo(object obj)</code>，接受一个参数 <code>obj</code>，并返回一个整数，指示该对象与 <code>obj</code> 的相对顺序。该方法返回一个负整数、零或正整数，分别表示当前对象小于、等于或大于 <code>obj</code>。</p>
<p>如果一个类实现了 <code>IComparable</code> 接口，那么它就可以使用 <code>Array.Sort、List&lt;T&gt;.Sort</code> 等静态方法对其对象进行排序。</p>
<h4 id="IComparer"><a href="#IComparer" class="headerlink" title="IComparer"></a><code>IComparer</code></h4><p><code>IComparer</code> 是一个用于比较两个对象之间的差异的接口，它定义了一个方法<code>int Compare(object x, object y)</code>，接受两个参数 <code>x</code> 和 <code>y</code>，并返回一个整数，指示它们的相对顺序。该方法返回一个负整数、零或正整数，分别表示 <code>x</code> 小于、等于或大于 <code>y</code>。</p>
<p>如果一个类没有实现 <code>IComparable</code> 接口，但是需要进行排序，可以通过实现 <code>IComparer</code> 接口来实现排序。在这种情况下，可以使用 <code>Array.Sort</code>、<code>List&lt;T&gt;.Sort</code> 等静态方法的重载方法之一，并将该类的实例作为第二个参数传递。</p>
<p>使用示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用IComparable进行排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">IComparable</span>&lt;<span class="title">Person</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params">Person other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 按照年龄从小到大排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.Age.CompareTo(other.Age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; people = <span class="keyword">new</span> List&lt;Person&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;Tom&quot;</span>, Age = <span class="number">25</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;Bob&quot;</span>, Age = <span class="number">30</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;Alice&quot;</span>, Age = <span class="number">20</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">people.Sort(); <span class="comment">// 使用IComparable接口进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用IComparer进行排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">PersonComparer</span> : <span class="title">IComparer</span>&lt;<span class="title">Person</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Compare</span>(<span class="params">Person x, Person y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 按照名字从A到Z排序</span></span><br><span class="line">        <span class="keyword">return</span> x.Name.CompareTo(y.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">people.Sort(<span class="keyword">new</span> PersonComparer()); <span class="comment">// 使用IComparer接口进行排序</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/post/hello-world/</url>
    <content><![CDATA[<h1 id="欢迎来到Sheh伟伟的个人博客！"><a href="#欢迎来到Sheh伟伟的个人博客！" class="headerlink" title="欢迎来到Sheh伟伟的个人博客！"></a>欢迎来到Sheh伟伟的个人博客！</h1><hr>
<p>一直想折腾一个自己的博客，用来记录工作中学习到的点点滴滴。今天终于选定了一款博客主题——yilia，并成功发布了。</p>
<p>本博客采用的是<span class="exturl" data-url="aHR0cDovL2hleG8uaW8v">Hexo<i class="fa fa-external-link-alt"></i></span>——一个开源的静态博客生成器。感谢Hexo的作者tommy351。采用的主题是<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpdHRlbi9oZXhvLXRoZW1lLXlpbGlh">yilia<i class="fa fa-external-link-alt"></i></span>，感谢yilia的作者litten。</p>
<p>从上周六就开始倒腾这个博客了，期间遇到各种问题，差点半途放弃了，最后还是查资料，请教成功发布个人博客的人，把所有问题都解决了。其中，遇到最坑爹的一个问题是接入多说评论系统。搞不懂，为什么多说主页上不说明白点，搞得我走了好多弯路。一开始以为用QQ登录多说就可以了，最后才发现要点击多说主页的<strong>我要安装</strong>按钮注册多说才行。为什么是<strong>我要安装</strong>而不是<strong>我要注册</strong>呢？</p>
<span id="more"></span>
<blockquote>
<p>为什么要话这么多时间精力倒腾这个博客呢？</p>
</blockquote>
<blockquote>
<ul>
<li>记录学习笔记，分享学习心得</li>
<li>宣传自己的一个小平台，认识一些志同道合的朋友</li>
<li>好像很酷的样子，可以装X</li>
<li>还有…也许的也许呢…</li>
</ul>
</blockquote>
<p>好了，开篇就写这么多吧，博客开通第一天，留个纪念。以后会都抽时间写点技术笔记。</p>
<blockquote>
<p><strong>ps:</strong><br>我是程序猿一枚，开篇的文章名字就取<strong>Hello World</strong>吧，哈哈。。。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>yilia</tag>
      </tags>
  </entry>
  <entry>
    <title>用Hexo搭建个人博客</title>
    <url>/post/hexo-blog/</url>
    <content><![CDATA[<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><h3 id="1-安装Homebrew"><a href="#1-安装Homebrew" class="headerlink" title="1. 安装Homebrew"></a>1. 安装Homebrew</h3><p>Mac建议使用 Homebrew 安装必要的插件，Windows用户可以跳过这一步。关于 Homebrew 的介绍请看我的这篇博文 <span class="exturl" data-url="aHR0cHM6Ly9kYXZpZHNoZWguZ2l0aHViLmlvLzIwMTcvMDgvMjYvbWFjLWhvbWVicmV3Lw==">Mac开发必备工具（一）—— Homebrew<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="2-安装Git和Node-js"><a href="#2-安装Git和Node-js" class="headerlink" title="2. 安装Git和Node.js"></a>2. 安装Git和Node.js</h3><p>Node.js 可以通过 Homebrew 安装，安装命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure>

<h3 id="3-安装-Hexo-博客框架"><a href="#3-安装-Hexo-博客框架" class="headerlink" title="3. 安装 Hexo 博客框架"></a>3. 安装 Hexo 博客框架</h3><p>Hexo 框架可以使用下面的 npm 命令来安装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h2 id="使用Hexo建站"><a href="#使用Hexo建站" class="headerlink" title="使用Hexo建站"></a>使用Hexo建站</h2><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建站步骤可参考<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mvc2V0dXAuaHRtbA==">Hexo官方文档<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>接着执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>命令执行完毕后，在浏览器输入<code>localhost:4000</code>就可以预览本地博客效果。</p>
<h3 id="将Hexo部署到GitHub"><a href="#将Hexo部署到GitHub" class="headerlink" title="将Hexo部署到GitHub"></a>将Hexo部署到GitHub</h3><p>在 GitHub 上新建一个仓库，然后修改 Hexo 的配置文件<code>_config.yml</code>中的 Deployment 配置项，修改内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/xxx/xxx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> 上面的的 <code>repository</code> 项要换成自己新建完成的 GitHub 仓库地址，也就是把上面的xxx换成你 GitHub 的用户名。</p>
</blockquote>
<p>配置完后，接着执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>这样就将博客部署到GitHub上了。可以在浏览器中输入<code>https://xxx.github.io</code>查看博客效果。我的博客效果可以<span class="exturl" data-url="aHR0cHM6Ly9kYXZpZHNoZWguZ2l0aHViLmlvLw==">点这里查看<i class="fa fa-external-link-alt"></i></span>。</p>
<blockquote>
<p>如果部署报错<code>ERROR Deployer not found: git</code> 或者 <code>ERROR Deployer not found: github</code>，就先执行<code>npm install hexo-deployer-git --save</code>安装部署插件后再运行<code>hexo deploy</code>命令</p>
</blockquote>
<h2 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h2><p>你可以执行下列命令来创建一篇新文章:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>命令执行完后，会在 Hexo 项目的<code>\source\_posts</code>目录下生成一个对应名称的<code>.md</code>文件。用编辑器打开就可以开始写文章了，注意文章得使用 Markdown 编写。文章写完后执行上面的清理、生成和部署命令将文章发布到GitHub仓库。<br>当让也可以不使用上面的生成命令，直接将事先编辑好的<code>.md</code> 文件复制到对应的目录，也是可以的。只不过用命令生成的<code>.md</code>文件会带一个<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvZnJvbnQtbWF0dGVyLmh0bWw=">Front-matter<i class="fa fa-external-link-alt"></i></span>，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 创建时间</span><br><span class="line">tags: 文章标签</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>所以，事先编辑好的<code>.md</code>文件里也应该包含相应的<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvZnJvbnQtbWF0dGVyLmh0bWw=">Front-matter<i class="fa fa-external-link-alt"></i></span>。</p>
<h2 id="Hexo-CI-CD"><a href="#Hexo-CI-CD" class="headerlink" title="Hexo CI&#x2F;CD"></a>Hexo CI&#x2F;CD</h2><p>为了博客的安全，以及版本控制，可以在 GitHub 上建立一个私有仓库用来存储 Hexo 博客源码。GitHub 支持使用 Action 来进行 CI&#x2F;CD，可以给 Hexo 源码仓库添加一个 GitHub Action 来实现全自动化部署。这样每次写完文章，只需要提交到仓库就行了，不用手动敲命令部署了。</p>
<h3 id="Hexo-Action"><a href="#Hexo-Action" class="headerlink" title="Hexo Action"></a>Hexo Action</h3><p>使用 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hcmtldHBsYWNlL2FjdGlvbnMvaGV4by1hY3Rpb24jJUYwJTlGJThEJThDZXhhbXBsZS13b3JrZmxvdy0tLWhleG8tZGVwbG95">Hexo Action<i class="fa fa-external-link-alt"></i></span> 来给仓库添加 GitHub Action。具体步骤可以参考说明文档中的使用说明。Hexo Action 主要步骤如下：</p>
<h4 id="生成-SSH-Key"><a href="#生成-SSH-Key" class="headerlink" title="生成 SSH-Key"></a>生成 SSH-Key</h4><p>如果 Hexo 博客源码的仓库使用的 SSH-Key 的公钥已经添加到 GitHub 账号中了，那么 GitHub Pages 仓库就不需要再添加 <code>Deploy Keys</code>, 只需要把私钥添加到 Hexo 博客源码仓库中的 <code>Settings &gt; Secrets</code> 中，并命名为 <code>DEPLOY_KEY</code>。如果还没有 SSH-Key，则需要使用 <code>ssh-keygen -t rsa -C &quot;username@example.com&quot;</code> 命令生成 SSH-key，更多 SSH-Key 的内容可以参考<span class="exturl" data-url="aHR0cHM6Ly9kYXZpZHNoZWguZ2l0aHViLmlvL3Bvc3QvR2l0JUU1JUJGJUFCJUU5JTgwJTlGJUU1JTg1JUE1JUU5JTk3JUE4Lw==">Git快速入门<i class="fa fa-external-link-alt"></i></span>。</p>
<h4 id="创建-GitHub-工作流"><a href="#创建-GitHub-工作流" class="headerlink" title="创建 GitHub 工作流"></a>创建 GitHub 工作流</h4><p>在 Hexo 博客源码仓库中，创建一个文件夹 <code>.github/workflows</code>，并在该文件夹下创建一个 <code>hexo_CI.yml</code> (.yml 文件的名称可以自己取)。最后 <code>.yml</code> 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: Deploy</span><br><span class="line"></span><br><span class="line">on: [push]</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    name: A job to deploy blog.</span><br><span class="line">    steps:</span><br><span class="line">    - name: Checkout</span><br><span class="line">      uses: actions/checkout@v1</span><br><span class="line">      with:</span><br><span class="line">        submodules: true # Checkout private submodules(themes or something else).</span><br><span class="line">    </span><br><span class="line">    # Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.)</span><br><span class="line">    - name: Cache node modules</span><br><span class="line">      uses: actions/cache@v1</span><br><span class="line">      id: cache</span><br><span class="line">      with:</span><br><span class="line">        path: node_modules</span><br><span class="line">        key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125;</span><br><span class="line">        restore-keys: |</span><br><span class="line">          $&#123;&#123; runner.os &#125;&#125;-node-</span><br><span class="line">    - name: Install Dependencies</span><br><span class="line">      if: steps.cache.outputs.cache-hit != &#x27;true&#x27;</span><br><span class="line">      run: npm ci</span><br><span class="line">    </span><br><span class="line">    # Deploy hexo blog website.</span><br><span class="line">    - name: Deploy</span><br><span class="line">      id: deploy</span><br><span class="line">      uses: sma11black/hexo-action@v1.0.2</span><br><span class="line">      with:</span><br><span class="line">        deploy_key: $&#123;&#123; secrets.DEPLOY_KEY &#125;&#125;</span><br><span class="line">        user_name: DavidSheh  # (or delete this input setting to use bot account)</span><br><span class="line">        user_email: davidsheh1015@gmail.com  # (or delete this input setting to use bot account)</span><br><span class="line">        commit_msg: $&#123;&#123; github.event.head_commit.message &#125;&#125;  # (or delete this input setting to use hexo default settings)</span><br><span class="line">    # Use the output from the `deploy` step(use for test action)</span><br><span class="line">    - name: Get the output</span><br><span class="line">      run: |</span><br><span class="line">        echo &quot;$&#123;&#123; steps.deploy.outputs.notify &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>其中 <code>user_name</code> 和 <code>user_email</code> 两个条目可以直接删除，也可以填写自己的信息。</p>
<h2 id="更换博客主题"><a href="#更换博客主题" class="headerlink" title="更换博客主题"></a>更换博客主题</h2><h3 id="更换默认主题"><a href="#更换默认主题" class="headerlink" title="更换默认主题"></a>更换默认主题</h3><p>可以去<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=">官网主题页<i class="fa fa-external-link-alt"></i></span>选择喜欢的主题，下载主题包。然后将主题文件夹放到 Hexo 项目的 <strong>themes</strong> 文件夹下。但是为了更好的进行主题的同步和更新，建议使用 submodule 的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Add submodule</span><br><span class="line">$ git submodule add https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class="line"></span><br><span class="line"># Get tags list</span><br><span class="line">$ cd themes/next</span><br><span class="line">$ git tag -l</span><br><span class="line">…</span><br><span class="line">v6.0.0</span><br><span class="line">v6.0.1</span><br><span class="line">v6.0.2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># Switch on v6.0.1 tagged release version</span><br><span class="line">$ git checkout tags/v6.0.1</span><br><span class="line">Note: checking out &#x27;tags/v6.0.1&#x27;.</span><br><span class="line">…</span><br><span class="line">HEAD is now at da9cdd2... Release v6.0.1</span><br><span class="line"></span><br><span class="line"># If you want to switch on latest release version without defining tag (optional)</span><br><span class="line">$ git checkout $(git describe --tags $(git rev-list --tags --max-count=1))</span><br></pre></td></tr></table></figure>

<h3 id="主题更新和同步"><a href="#主题更新和同步" class="headerlink" title="主题更新和同步"></a>主题更新和同步</h3><p>主题的更新和同步推荐使用 <code>Hexo-Way</code> 的方式，先在 Hexo 根目录下新建一个 <code>_config.next.yml</code> 的文件（其中的 next 要跟主题的文件夹名保持一致）。然后将需要改动的配置都配置在该文件夹中，只需要将主题的 <code>_config.yml</code> 文件中需要改动的部分拷贝一份然后在 <code>_config.next.yml</code> 文件中改动就行。具体步骤请参考官网的<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvY29uZmlndXJhdGlvbi5odG1s">配置说明<i class="fa fa-external-link-alt"></i></span> 中的关于“独立的 _config.[theme].yml 文件”的说明。</p>
<h3 id="NexT-主题设置"><a href="#NexT-主题设置" class="headerlink" title="NexT 主题设置"></a>NexT 主题设置</h3><p>首先，修改 Hexo 站点配置文件 <code>_config.yml</code> 中的 Extensions 配置项，修改内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<blockquote>
<p>博主使用的是 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lpc3NuYW4vaGV4by10aGVtZS1uZXh0">NexT主题<i class="fa fa-external-link-alt"></i></span>，所以 theme 项配置的是<code>next</code>，这里配置的字段一定要和 <strong>themes</strong> 文件夹下主题包的文件夹名称相同。下文关于主题的配置均是针对于 NexT 主题，主题的具体使用说明可以参考 <span class="exturl" data-url="aHR0cDovL3RoZW1lLW5leHQuaWlzc25hbi5jb20v">NexT 官方网站<i class="fa fa-external-link-alt"></i></span>。</p>
</blockquote>
<p>然后，NexT 主题的设置在官网的<span class="exturl" data-url="aHR0cDovL3RoZW1lLW5leHQuaWlzc25hbi5jb20vZ2V0dGluZy1zdGFydGVkLmh0bWw=">开始使用<i class="fa fa-external-link-alt"></i></span>中说的很详细，我这里就不画蛇添足了，不清楚的可以直接看官网。</p>
<p>关于 NexT 主题的文档是我见过的所有 Hexo 主题中最完善的，你所能想到大部分配置都集成到主题了，基本实现了傻瓜式配置。</p>
<h3 id="第三方插件"><a href="#第三方插件" class="headerlink" title="第三方插件"></a>第三方插件</h3><ol>
<li><p>本站搜索插件。使用 <code>npm install hexo-generator-searchdb</code> 安装插件，并在 <code>_config.next.yml</code> 中添加如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Local Search</span><br><span class="line"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # If auto, trigger search by changing input.</span><br><span class="line">  # If manual, trigger search by pressing enter key or search button.</span><br><span class="line">  trigger: auto</span><br><span class="line">  # Show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # Unescape html strings to the readable one.</span><br><span class="line">  unescape: false</span><br><span class="line">  # Preload the search data when the page loads.</span><br><span class="line">  preload: false</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动摘录插件。在主页显示文章概要，需要手动添加 <code>&lt;!--more--&gt;</code> 标签，使用 hexo-auto-excerpt 插件可以实现自动化摘录。安装命令为：<code>npm install --save hexo-auto-excerpt</code>。</p>
</li>
<li><p>分享插件。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by1uZXh0LXNoYXJl">hexo-next-share<i class="fa fa-external-link-alt"></i></span>，安装命令：<code>npm install theme-next/hexo-next-share</code>，并在 <code>_config.next.yml</code> 中添加如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Share</span><br><span class="line"># Likely Share</span><br><span class="line"># See: https://ilyabirman.net/projects/likely/, https://github.com/ilyabirman/Likely</span><br><span class="line"># Likely supports four looks, nine social networks, any button text.</span><br><span class="line"># You are free to modify the text value and order of any network.</span><br><span class="line">likely:</span><br><span class="line">  enable: true</span><br><span class="line">  cdn:</span><br><span class="line">    js: //cdn.jsdelivr.net/npm/ilyabirman-likely@2/release/likely.min.js</span><br><span class="line">    css: //cdn.jsdelivr.net/npm/ilyabirman-likely@2/release/likely.min.css</span><br><span class="line">  look: normal # available values: normal, light, small, big</span><br><span class="line">  networks:</span><br><span class="line">    twitter: Tweet</span><br><span class="line">    facebook: Share</span><br><span class="line">    linkedin: Link</span><br><span class="line">    #gplus: Plus</span><br><span class="line">    vkontakte: Share</span><br><span class="line">    odnoklassniki: Class</span><br><span class="line">    telegram: Send</span><br><span class="line">    whatsapp: Send</span><br><span class="line">    pinterest: Pin</span><br><span class="line"></span><br><span class="line"># NeedMoreShare2</span><br><span class="line"># Dependencies: https://github.com/theme-next/theme-next-needmoreshare2</span><br><span class="line"># For more information: https://github.com/revir/need-more-share2</span><br><span class="line"># iconStyle: default | box</span><br><span class="line"># boxForm: horizontal | vertical</span><br><span class="line"># position: top / middle / bottom + Left / Center / Right</span><br><span class="line"># networks:</span><br><span class="line"># Weibo | Wechat | Douban | QQZone | Twitter | Facebook | Linkedin | Mailto | Reddit | Delicious | StumbleUpon | Pinterest</span><br><span class="line"># GooglePlus | Tumblr | GoogleBookmarks | Newsvine | Evernote | Friendfeed | Vkontakte | Odnoklassniki | Mailru</span><br><span class="line">needmoreshare:</span><br><span class="line">  enable: true</span><br><span class="line">  cdn:</span><br><span class="line">    js: //cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js</span><br><span class="line">    css: //cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css</span><br><span class="line">  postbottom:</span><br><span class="line">    enable: false</span><br><span class="line">    options:</span><br><span class="line">      iconStyle: default</span><br><span class="line">      boxForm: horizontal</span><br><span class="line">      position: bottomCenter</span><br><span class="line">      networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook,Linkedin,Mailto,Reddit</span><br><span class="line">  float:</span><br><span class="line">    enable: true</span><br><span class="line">    options:</span><br><span class="line">      iconStyle: box</span><br><span class="line">      boxForm: vertical</span><br><span class="line">      position: middleRight</span><br><span class="line">      networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成站点地图。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvLWdlbmVyYXRvci1zaXRlbWFw">hexo-generator-sitemap<i class="fa fa-external-link-alt"></i></span>，安装命令：<code>npm install hexo-generator-sitemap --save</code>。并在 <code>_config.next.yml</code> 中添加如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">  template: ./sitemap_template.xml</span><br><span class="line">  rel: false</span><br><span class="line">  tags: true</span><br><span class="line">  categories: true</span><br></pre></td></tr></table></figure>
</li>
<li><p><del>提交 URL 到搜索引擎。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2NqaDA2MTMvaGV4by1zdWJtaXQtdXJscy10by1zZWFyY2gtZW5naW5l">hexo-submit-urls-to-search-engine<i class="fa fa-external-link-alt"></i></span>，安装命令：<code>npm install --save hexo-submit-urls-to-search-engine</code>。</del></p>
</li>
<li><p><del><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JvemJvL2hleG8tbmVhdA==">hexo-neat<i class="fa fa-external-link-alt"></i></span>，安装命令：<code>npm install hexo-neat --save</code>，并在 <code>_config.next.yml</code> 中添加如下设置：</del></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文件压缩，设置一些需要跳过的文件 </span><br><span class="line"># hexo-neat</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩 html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  # 一些百度、Google 的验证文件需要排除掉</span><br><span class="line">  exclude:</span><br><span class="line">    - &#x27;**/baidu*.html&#x27;</span><br><span class="line">    - &#x27;**/google*.html&#x27;</span><br><span class="line"># 压缩 css</span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &#x27;**/*.min.css&#x27;</span><br><span class="line"># 压缩 js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - &#x27;**/*.min.js&#x27;</span><br><span class="line">    - &#x27;**/jquery.fancybox.pack.js&#x27;</span><br><span class="line">    - &#x27;**/index.js&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p><del><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1aXdhbmcvaGV4by1yZWNvbW1lbmRlZC1wb3N0cw==">Hexo跨博客文章推荐插件<i class="fa fa-external-link-alt"></i></span>，安装命令：<code>npm install hexo-recommended-posts --save</code>。</del></p>
</li>
<li><p><del><span class="exturl" data-url="aHR0cHM6Ly96aGFuZ3p3LmNvbS9wb3N0cy8yMDE5MDgzMC5odG1s">Hexo 给文章中英文添加空格<i class="fa fa-external-link-alt"></i></span></del></p>
</li>
</ol>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 将类别和标签进行映射</title>
    <url>/post/hexo-mapping-categories-tags/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>如果个人博客使用的是 Hexo 框架，分类和标签遇到特殊情况可能会链接不正确，比如说博客分类或者标签里面有 <code>C#</code> 的话，生成博客网站后，点击 <code>C#</code> 分类或者标签后，发现并没有正常显示 <code>C#</code> 相关的文章，而且 <code>C++</code> 也有类似的问题。产生这个问题的原因是 Hexo 在生成博客后，每个标签会单独生成一个文件夹，而文件夹名称里面不能包含一些非法字符，同时网页地址里面也不能包含 <code>#</code> 等非法字符。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在 Hexo 默认的 <code>_config.yml</code> 文件中，定义了两个空的映射属性：<code>category_map</code> 和 <code>tag_map</code>。只需要在这两个属性下面设置合法的映射就能解决问题。下面是我的映射配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">category_map:</span><br><span class="line">  C++: c-plus-plus</span><br><span class="line">  C#: c-sharp</span><br><span class="line">  .NET: dot-net</span><br><span class="line">tag_map:</span><br><span class="line">  C++: c-plus-plus</span><br><span class="line">  C#: c-sharp</span><br><span class="line">  .NET: dot-net</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmJpdGJhZGdlci5zb2x1dGlvbnMvMjAxNy9tYXBwaW5nLWNhdGVnb3JpZXMtYW5kLXRhZ3Mtd2l0aC1oZXhvLmh0bWw=">Mapping Categories and Tags with Hexo<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins 使用备忘</title>
    <url>/post/jenkins-usage/</url>
    <content><![CDATA[<h2 id="安装-Jenkins"><a href="#安装-Jenkins" class="headerlink" title="安装 Jenkins"></a>安装 Jenkins</h2><p>使用 Homebrew 安装Jenkins。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install jenkins</span><br></pre></td></tr></table></figure>

<h2 id="启动-Jenkins"><a href="#启动-Jenkins" class="headerlink" title="启动 Jenkins"></a>启动 Jenkins</h2><p>直接在终端输入如下命令启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jenkins</span><br></pre></td></tr></table></figure>
<p>当终端输出的日志最后显示如下所示，表示启动成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">信息:</span><br><span class="line"></span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line"></span><br><span class="line">Jenkins initial setup is required. An admin user has been created and a password generated.</span><br><span class="line">Please use the following password to proceed to installation:</span><br><span class="line"></span><br><span class="line">8c3545925a714342acb94cdad830fcdc</span><br><span class="line"></span><br><span class="line">This may also be found at: /Users/davidsheh/.jenkins/secrets/initialAdminPassword</span><br><span class="line"></span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line">*************************************************************</span><br><span class="line">信息: Jenkins is fully up and running</span><br></pre></td></tr></table></figure>
<p>这里只拷贝了部分日志，注意<code>*</code>号之间的内容里包含一个默认的密码，下面会用到。</p>
<h2 id="进入-Jenkins"><a href="#进入-Jenkins" class="headerlink" title="进入 Jenkins"></a>进入 Jenkins</h2><p>当启动 Jenkins 后，打开浏览器，在地址栏输入 <code>localhost:8080</code> 后进入 Jenkins 图形界面。然后在 <code>Administrator password</code> 输入终端打印的那个密码。</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>如果遇到插件列表无法安装或更新，可以进入到<br>Jenkins -&gt; Manage Jenkins -&gt; Configure Global Security 管理页面，找到 <code>Plugin Manager</code> 选项下的 <code>Use browser for metadata download</code> 并勾选。</p>
<h2 id="安装插件-1"><a href="#安装插件-1" class="headerlink" title="安装插件"></a>安装插件</h2><p>如果遇到插件列表无法安装或更新，可以进入到<br>Jenkins -&gt; Manage Jenkins -&gt; Configure System 管理页面，找到 <code>Locale</code> 选项，在输入框中输入 <code>zh_CN</code> ，并勾选 <code>Ignore browser preference and force this language to all users</code>。</p>
<h2 id="停止-Jenkins"><a href="#停止-Jenkins" class="headerlink" title="停止 Jenkins"></a>停止 Jenkins</h2><p>进入终端，使用快捷键 <code>Ctrl + C</code> 可以停止 Jenkins。</p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="启动-Jenkins-时有警告出现，警告信息如下："><a href="#启动-Jenkins-时有警告出现，警告信息如下：" class="headerlink" title="启动 Jenkins 时有警告出现，警告信息如下："></a>启动 Jenkins 时有警告出现，警告信息如下：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">三月 11, 2018 8:43:57 下午 hudson.model.AsyncPeriodicWork$1 run</span><br><span class="line">信息: Finished Download metadata. 20,269 ms</span><br><span class="line">三月 11, 2018 8:43:58 下午 hudson.model.UpdateCenter updateDefaultSite</span><br><span class="line">警告: Upgrading Jenkins. Failed to update the default Update Site &#x27;default&#x27;. Plugin upgrades may fail.</span><br><span class="line">java.net.SocketTimeoutException: connect timed out</span><br><span class="line">	at java.net.PlainSocketImpl.socketConnect(Native Method)</span><br><span class="line">	at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)</span><br><span class="line">	at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)</span><br><span class="line">	at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)</span><br><span class="line">	at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)</span><br><span class="line">	at java.net.Socket.connect(Socket.java:589)</span><br><span class="line">	at sun.security.ssl.SSLSocketImpl.connect(SSLSocketImpl.java:668)</span><br><span class="line">	at sun.net.NetworkClient.doConnect(NetworkClient.java:175)</span><br><span class="line">	at sun.net.www.http.HttpClient.openServer(HttpClient.java:463)</span><br><span class="line">	at sun.net.www.http.HttpClient.openServer(HttpClient.java:558)</span><br><span class="line">	at sun.net.www.protocol.https.HttpsClient.&lt;init&gt;(HttpsClient.java:264)</span><br><span class="line">	at sun.net.www.protocol.https.HttpsClient.New(HttpsClient.java:367)</span><br><span class="line">	at sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.getNewHttpClient(AbstractDelegateHttpsURLConnection.java:191)</span><br><span class="line">	at sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1138)</span><br><span class="line">	at sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:1032)</span><br><span class="line">	at sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:177)</span><br><span class="line">	at sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1546)</span><br><span class="line">	at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1474)</span><br><span class="line">	at sun.net.www.protocol.https.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:254)</span><br><span class="line">	at hudson.model.DownloadService.loadJSON(DownloadService.java:167)</span><br><span class="line">	at hudson.model.UpdateSite.updateDirectlyNow(UpdateSite.java:190)</span><br><span class="line">	at hudson.model.UpdateCenter.updateDefaultSite(UpdateCenter.java:2194)</span><br><span class="line">	at jenkins.install.SetupWizard.init(SetupWizard.java:173)</span><br><span class="line">	at jenkins.install.InstallState$InitialSecuritySetup.initializeState(InstallState.java:142)</span><br><span class="line">	at jenkins.model.Jenkins.setInstallState(Jenkins.java:1035)</span><br><span class="line">	at jenkins.install.InstallUtil.proceedToNextStateFrom(InstallUtil.java:97)</span><br><span class="line">	at jenkins.install.InstallState$Unknown.initializeState(InstallState.java:75)</span><br><span class="line">	at jenkins.model.Jenkins.&lt;init&gt;(Jenkins.java:923)</span><br><span class="line">	at hudson.model.Hudson.&lt;init&gt;(Hudson.java:85)</span><br><span class="line">	at hudson.model.Hudson.&lt;init&gt;(Hudson.java:81)</span><br><span class="line">	at hudson.WebAppMain$3.run(WebAppMain.java:233)</span><br><span class="line"></span><br><span class="line">三月 11, 2018 8:43:58 下午 hudson.UDPBroadcastThread run</span><br><span class="line">信息: Cannot listen to UDP port 33,848, skipping: java.net.SocketException: Can&#x27;t assign requested address</span><br><span class="line">三月 11, 2018 8:43:58 下午 hudson.WebAppMain$3 run</span><br></pre></td></tr></table></figure>
<p>原因是因为 GFW 把对应的 IP 给墙了。我的解决方案是，使用 <code>Ctrl + C</code> 停止 Jenkins，然后使用命令 <code>rm -rf ~/.jenkins/</code> 删除 Jenkins 配置文件，然后打开翻墙工具，重新使用 <code>jenkins</code> 命令启动 Jenkins，然后问题解决了。另外一个方案是采用离线安装插件的方式，链接点<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl5dW1pbmcwMDAwL2FydGljbGUvZGV0YWlscy80Njg3OTU4Mw==">这里<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="更换界面主题"><a href="#更换界面主题" class="headerlink" title="更换界面主题"></a>更换界面主题</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZvcHNjdWJlLmNvbS9zZXR1cC1jdXN0b20tbWF0ZXJpYWxpemVkLXVpLXRoZW1lLWplbmtpbnMv">https://devopscube.com/setup-custom-materialized-ui-theme-jenkins/<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="备份-Jenkins-配置"><a href="#备份-Jenkins-配置" class="headerlink" title="备份 Jenkins 配置"></a>备份 Jenkins 配置</h2><p>使用 Thin Backup 插件备份配置。链接：<br><span class="exturl" data-url="aHR0cHM6Ly9kZXZvcHNjdWJlLmNvbS9qZW5raW5zLWJhY2t1cC1kYXRhLWNvbmZpZ3VyYXRpb25zLw==">https://devopscube.com/jenkins-backup-data-configurations/<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 学习笔记</title>
    <url>/post/linux-notes/</url>
    <content><![CDATA[<h2 id="最重要的命令"><a href="#最重要的命令" class="headerlink" title="最重要的命令"></a>最重要的命令</h2><ul>
<li><code>man</code> 查看帮助手册，例如 <code>man ls</code> 表示查看 <code>ls</code> 命令的帮助手册</li>
<li><code>-h</code>、<code>--h</code>、<code>-help</code>、<code>--help</code> 查看命令帮助</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li><code>mkdir</code> 创建一个文件夹；</li>
<li><code>touch</code> 创建一个空文件，touch 的另一个作用是更新文件的时间戳,也就是最后编辑时间,内容保持不变；</li>
<li><code>rm &lt;file&gt;</code> 删除文件，<code>rm -f &lt;file&gt;</code> 强制删除文件；</li>
<li><code>cp &lt;old&gt; &lt;new&gt;</code> 复制文件；</li>
<li><code>mv &lt;old&gt; &lt;new&gt;</code> 移动或重命名文件；</li>
<li><code>cat file</code> 显示文件内容；</li>
<li><code>ls foo</code> 可以用于检查 <code>foo</code> 文件或目录是否存在；</li>
<li><code>&gt;</code> 将输出重定向到文件名，<code>&gt;&gt;</code> 将输出附加到文件名；</li>
<li><code>diff &lt;f1&gt; &lt;f2&gt;</code> 对比文件 1 和 2 的差异；</li>
<li><code>wc &lt;file&gt;</code> 统计文件行数、字数和大小，显示的结果中的数字分别表示文件内容的行数、字数和字节大小；</li>
<li><code>head &lt;file&gt;</code> 显示文件的前 10 行内容，<code>tail &lt;file&gt;</code> 显示文件的最后 10 行内容；</li>
<li><code>which bash</code> 显示程序（bash）路径；</li>
<li><code>grep -i &lt;string&gt; &lt;file&gt;</code> 在指定文件中查找字符串，其中 <code>-i</code> 表示忽略大小写；</li>
<li><code>ps</code> 显示进程；<code>top</code> 按资源占用从高到低排序显示进程；</li>
<li><code>kill -&lt;level&gt; &lt;pid&gt;</code> 杀掉一个进程；</li>
<li><code>cd ..</code> 回到上一层目录；<code>cd -</code> 回到上一个目录；<code>cd ~</code> 回到主目录（Home 目录），等同于 <code>cd</code>；<code>cd /</code> 回到根目录；</li>
<li><code>scp</code> 命令可以在多台设备上相互拷贝文件；<code>scp -r</code> 命令可以在多台设备上拷贝文件夹</li>
<li><code>find</code> 查找文件，用find可以根据文件名查找，或者根据类型查找，通过不同的参数设置，如 <code>find . -name &quot;a.txt&quot;</code> 表示在当前目录找文件名为 a.txt 的路径</li>
<li><code>grep</code> 搜索字符，搜过文件中的字符是非常常用的功能之一,比如写代码时候搜过一个函数都在哪里调用了。或者分析日志时候过滤出有用数据都可以用grep。如 <code>bash$ grep test *.txt</code> 表示在当前目录下搜索包含 test 字符的 .txt 文件。</li>
</ul>
<p>下面放一张网友总结的 Linux 常用命令脑图（原始链接已经找不到了）：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/linux_command.jpg" alt="linux_command"></p>
<blockquote>
<p>组合命令：多个命令之间可以用分号 <code>;</code> 隔开，表示依次执行多个命令。但是更好地使用组合命令是用 <code>&amp;&amp;</code> 隔开多个命令，这种方式的好处是等待前一个命令成功后再执行下一个命令。</p>
</blockquote>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ul>
<li><code>Tab</code> 命令补全</li>
<li><code>Ctrl</code>+<code>C</code> 终止命令执行</li>
<li><code>Ctrl</code>+<code>U</code> 清除已输入的命令</li>
<li><code>Ctrl</code>+<code>D</code> 关闭命令行窗口</li>
<li><code>Ctrl</code>+<code>L</code> 清除屏幕</li>
<li><code>Ctrl</code>+<code>A</code> 将光标移动到命令行开头</li>
<li><code>Ctrl</code>+<code>E</code> 将光标移动到命令行结尾</li>
<li><code>Alt</code>+<code>Enter</code> 终端窗口最大&#x2F;最小化</li>
<li><code>Ctrl</code>+<code>Up/Down Arrow</code> 上下滚动终端屏幕</li>
</ul>
<p>Linux 系统的命令行下，可以直接使用 <code>man</code> 命令查询 C&#x2F;C++ 函数和例子。<br>比如 <code>man socket</code> 查询 socket 函数，直接 <code>man getaddrinfo</code> 可以查看例子。下面再放一张珍藏的常用快捷键示意图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/linux_shortcuts.jpg" alt="linux_shortcuts"></p>
<h2 id="Linux下的路径表示方法"><a href="#Linux下的路径表示方法" class="headerlink" title="Linux下的路径表示方法"></a>Linux下的路径表示方法</h2><ul>
<li>以”&#x2F;“开头的表示从根目录开始,根目录就是linux的最上层目录, 例如 &#x2F;home</li>
<li>以”.&#x2F;“开头的表示从当前目录开始,当前目录就是当前终端所在的目录,也称为工作目录,例如 .&#x2F;samples</li>
<li>以”~”符号开头的，表示从用户目录开始,用户目录表示当前用户的根目录,用户根目录一般路径为&#x2F;home&#x2F;用户名,在我机器上就是&#x2F;home&#x2F;wei, 例如 ~&#x2F;samples 的绝对路径就是&#x2F;home&#x2F;wei&#x2F;samples。</li>
</ul>
<h2 id="推荐教程"><a href="#推荐教程" class="headerlink" title="推荐教程"></a>推荐教程</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGVhcm5lbm91Z2guY29tL2NvbW1hbmQtbGluZS10dXRvcmlhbC9iYXNpY3M=">Learn Enough Command Line to Be Dangerous<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 对象序列化成 Lua 代码</title>
    <url>/post/lua-serialization/</url>
    <content><![CDATA[<h1 id="Lua-Serialization"><a href="#Lua-Serialization" class="headerlink" title="Lua Serialization"></a>Lua Serialization</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0RhdmlkU2hlaC9MdWFTZXJpYWxpemF0aW9u">Lua Serialization<i class="fa fa-external-link-alt"></i></span> 是一种轻量级的序列化工具，用于将 C# 对象序列化成 Lua 代码。它可以帮助你将 C# 中的实例对象保存为 Lua 代码形式的配置文件，方便在 Lua 环境中使用。这对于在 Unity3D + Lua 的游戏开发工作流中非常有用。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>支持将 C# 对象序列化成 Lua 代码。</li>
<li>支持多种数据类型的导出，包括基本类型（int、float、double、bool、string、enum、array），以及复杂类型如 List 和 Dictionary。</li>
<li>支持忽略某些字段的导出。</li>
<li>支持序列化前的预处理操作，例如在导出前初始化某些字段。</li>
<li>支持导出 Lua 原生代码（如 Lua 函数和自定义枚举）。</li>
<li>自定义导出格式。</li>
</ol>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>数据类定义：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">People</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> weight;</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="built_in">int</span>&gt; luckyNumbers;</span><br><span class="line">    <span class="keyword">public</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; luckyNumberMap;</span><br><span class="line">    [<span class="meta">IgnoreLua</span>] <span class="keyword">public</span> <span class="built_in">string</span> description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化处理：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">People people = <span class="keyword">new</span> People()</span><br><span class="line">&#123;</span><br><span class="line">    id = <span class="number">10001</span>,</span><br><span class="line">    name = <span class="string">&quot;Lua&quot;</span>,</span><br><span class="line">    age = <span class="number">18</span>,</span><br><span class="line">    weight = <span class="number">60.5f</span>,</span><br><span class="line">    luckyNumbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;,</span><br><span class="line">    luckyNumberMap = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        &#123; <span class="number">2</span>, <span class="string">&quot;好事成双&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="number">5</span>, <span class="string">&quot;五福临门&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="number">6</span>, <span class="string">&quot;六六大顺&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="number">8</span>, <span class="string">&quot;八方来财&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="number">9</span>, <span class="string">&quot;长长久久&quot;</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    description = <span class="string">&quot;Field that is marked as not serialized.&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> strLua = LuaSerializer.Serialize(people);</span><br><span class="line">Console.WriteLine(strLua);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    [<span class="string">&quot;id&quot;</span>]=<span class="number">10001</span>,</span><br><span class="line">    [<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;Lua&quot;</span>,</span><br><span class="line">    [<span class="string">&quot;age&quot;</span>]=<span class="number">18</span>,</span><br><span class="line">    [<span class="string">&quot;weight&quot;</span>]=<span class="number">60.5</span>,</span><br><span class="line">    [<span class="string">&quot;luckyNumbers&quot;</span>]=&#123;</span><br><span class="line">        <span class="number">2</span>,</span><br><span class="line">        <span class="number">5</span>,</span><br><span class="line">        <span class="number">6</span>,</span><br><span class="line">        <span class="number">8</span>,</span><br><span class="line">        <span class="number">9</span></span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="string">&quot;luckyNumberMap&quot;</span>]=&#123;</span><br><span class="line">        [<span class="number">2</span>]=<span class="string">&quot;好事成双&quot;</span>,</span><br><span class="line">        [<span class="number">5</span>]=<span class="string">&quot;五福临门&quot;</span>,</span><br><span class="line">        [<span class="number">6</span>]=<span class="string">&quot;六六大顺&quot;</span>,</span><br><span class="line">        [<span class="number">8</span>]=<span class="string">&quot;八方来财&quot;</span>,</span><br><span class="line">        [<span class="number">9</span>]=<span class="string">&quot;长长久久&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h3><h4 id="一、序列化前的预处理操作"><a href="#一、序列化前的预处理操作" class="headerlink" title="一、序列化前的预处理操作"></a>一、序列化前的预处理操作</h4><p>通过实现 <code>IBeforeLuaSerialization</code> 接口，并在 <code>OnBeforeLuaSerialize()</code> 方法中添加预处理逻辑。</p>
<p>数据类定义：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">People</span> : <span class="title">IBeforeLuaSerialization</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> weight;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> brief;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBeforeLuaSerialize</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        brief = <span class="string">$&quot;id: <span class="subst">&#123;id&#125;</span>, name: <span class="subst">&#123;name&#125;</span>, age: <span class="subst">&#123;age&#125;</span>, weight: <span class="subst">&#123;weight&#125;</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化处理：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">People people = <span class="keyword">new</span> People()</span><br><span class="line">&#123;</span><br><span class="line">    id = <span class="number">10002</span>,</span><br><span class="line">    name = <span class="string">&quot;Lucky&quot;</span>,</span><br><span class="line">    age = <span class="number">18</span>,</span><br><span class="line">    weight = <span class="number">60.5f</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">string</span> strLua = LuaSerializer.Serialize(people);</span><br><span class="line">Console.WriteLine(strLua);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    [<span class="string">&quot;id&quot;</span>]=<span class="number">10002</span>,</span><br><span class="line">    [<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;Lucky&quot;</span>,</span><br><span class="line">    [<span class="string">&quot;age&quot;</span>]=<span class="number">18</span>,</span><br><span class="line">    [<span class="string">&quot;weight&quot;</span>]=<span class="number">60.5</span>,</span><br><span class="line">    [<span class="string">&quot;brief&quot;</span>]=<span class="string">&quot;id: 10002, name: Lucky, age: 18, weight: 60.5&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二、Lua-原生代码导出"><a href="#二、Lua-原生代码导出" class="headerlink" title="二、Lua 原生代码导出"></a>二、Lua 原生代码导出</h4><p>需要导出 Lua 原生代码的字段，只需在字符串前加上 <code>@</code> 标记。</p>
<p>数据类定义：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">People</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> gender;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化处理：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">People people = <span class="keyword">new</span> People()</span><br><span class="line">&#123;</span><br><span class="line">    id = <span class="number">10003</span>,</span><br><span class="line">    name = <span class="string">&quot;Lucky&quot;</span>,</span><br><span class="line">    gender = <span class="string">&quot;@GenderType.Male&quot;</span>,</span><br><span class="line">    description = <span class="string">&quot;@function() print(&#x27;I am a student.&#x27;) end&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">string</span> strLua = LuaSerializer.Serialize(people);</span><br><span class="line">Console.WriteLine(strLua);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    [<span class="string">&quot;id&quot;</span>]=<span class="number">10003</span>,</span><br><span class="line">    [<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;Lucky&quot;</span>,</span><br><span class="line">    [<span class="string">&quot;gender&quot;</span>]=GenderType.Male,</span><br><span class="line">    [<span class="string">&quot;description&quot;</span>]=<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">&#x27;I am a student.&#x27;</span>) <span class="keyword">end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三、自定义导出格式"><a href="#三、自定义导出格式" class="headerlink" title="三、自定义导出格式"></a>三、自定义导出格式</h4><p>实现 <code>ILuaSerializable</code> 接口，并在 <code>SerializeToLua()</code> 方法中定义自定义导出逻辑。</p>
<p>数据类定义：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">People</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> Child[] children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Child</span> : <span class="title">ILuaSerializable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">SerializeToLua</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$&quot;[name = &#x27;<span class="subst">&#123;name&#125;</span>&#x27;, age = <span class="subst">&#123;age&#125;</span>]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化处理：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">People people = <span class="keyword">new</span> People()</span><br><span class="line">&#123;</span><br><span class="line">    id = <span class="number">10004</span>,</span><br><span class="line">    name = <span class="string">&quot;Lucy&quot;</span>,</span><br><span class="line">    age = <span class="number">32</span>,</span><br><span class="line">    children = <span class="keyword">new</span> Child[]&#123;</span><br><span class="line">        <span class="keyword">new</span> Child()&#123;</span><br><span class="line">            name = <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">            age = <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">new</span> Child()&#123;</span><br><span class="line">            name = <span class="string">&quot;Nancy&quot;</span>,</span><br><span class="line">            age = <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">string</span> strLua = LuaSerializer.Serialize(people);</span><br><span class="line">Console.WriteLine(strLua);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    [<span class="string">&quot;id&quot;</span>]=<span class="number">10004</span>,</span><br><span class="line">    [<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;Lucy&quot;</span>,</span><br><span class="line">    [<span class="string">&quot;age&quot;</span>]=<span class="number">32</span>,</span><br><span class="line">    [<span class="string">&quot;children&quot;</span>]=&#123;</span><br><span class="line">        <span class="string">&quot;[name = &#x27;Jack&#x27;, age = 1]&quot;</span>,</span><br><span class="line">        <span class="string">&quot;[name = &#x27;Nancy&#x27;, age = 2]&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h2><p>一个无第三方依赖的轻量级 C# 序列化成 Lua 代码的工具 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0RhdmlkU2hlaC9MdWFTZXJpYWxpemF0aW9u">Lua Serialization<i class="fa fa-external-link-alt"></i></span>：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0RhdmlkU2hlaC9MdWFTZXJpYWxpemF0aW9uJUUzJTgwJTgy">https://github.com/DavidSheh/LuaSerialization。<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity3D</tag>
        <tag>Lua</tag>
        <tag>Serialization</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Mac 上配置 C++ 环境</title>
    <url>/post/mac-c-env/</url>
    <content><![CDATA[<h2 id="使用-VSCode-编写-C-程序一步到位"><a href="#使用-VSCode-编写-C-程序一步到位" class="headerlink" title="使用 VSCode 编写 C++ 程序一步到位"></a>使用 VSCode 编写 C++ 程序一步到位</h2><ol>
<li>安装C&#x2F;C++插件，请认准微软官方出品</li>
<li>安装Code Runner插件</li>
<li>写代码，然后保存</li>
<li>使用快捷键<code>Ctrl+Alt+N</code>编译并运行代码</li>
</ol>
<h2 id="使用-Xcode-强大的-IDE"><a href="#使用-Xcode-强大的-IDE" class="headerlink" title="使用 Xcode 强大的 IDE"></a>使用 Xcode 强大的 IDE</h2><ol>
<li>打开 Xcode，点 Create a new Xcode project</li>
<li>选择 macOS -&gt; Command Line Tool</li>
<li>下一步后，填写项目的基本信息，然后，<code>Language</code> 这一项选择 <code>C++</code></li>
<li>项目创建完后，点击三角形的按钮就开始编译了</li>
</ol>
<h2 id="C-代码在命令行编译并运行的步骤"><a href="#C-代码在命令行编译并运行的步骤" class="headerlink" title="C++ 代码在命令行编译并运行的步骤"></a>C++ 代码在命令行编译并运行的步骤</h2><ol>
<li>打开终端（⌘ + 空格 输入 Terminal）</li>
<li>用cd命令切换到程序文件所在目录</li>
<li>输入命令<code>g++ main.cpp -o main</code>。前一个 <code>main.cpp</code> 表示程序入口函数所在的文件，后一个 <code>main</code> 表示生成可执行文件的名字，如果编译成功的话，就会生成一个名为 main 的可执行文件</li>
<li>在终端输入<code>./main</code>命令就可以执行看到结果了。<code>./</code>表示当前目录</li>
</ol>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac开发必备工具（三）—— Fish shell</title>
    <url>/post/mac-fishshell/</url>
    <content><![CDATA[<h1 id="Fish-shell"><a href="#Fish-shell" class="headerlink" title="Fish shell"></a>Fish shell</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>fish 可以根据输入自动匹配历史命令。它的一大特点是开箱即用，没有zsh那些繁琐的配置。官网：<span class="exturl" data-url="aHR0cDovL3d3dy5maXNoc2hlbGwuY29tLyVFMyU4MCU4Mg==">http://www.fishshell.com/。<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p>在终端里使用Homebrew安装，直接输入 <code>brew install fish</code> 等待安装完成即可。安装完了以后还不能用，因为没把fish添加到 mac 的 shell 列表里，切换到 fish shell 时显示找不到fish shell，所以我们要先添加 fish 并设置一下 shell 。首先，用 shell 命令<code>sudo vim /etc/shells</code>在 vim 中打开 Mac 的 shell 列表，执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># List of acceptable shells for chpass(1).</span><br><span class="line"># Ftpd will not allow users to connect who are not using</span><br><span class="line"># one of these shells.</span><br><span class="line"></span><br><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure>
<p>按<code>i</code>键，进入插入模式，然后在列表末尾加上<code>/usr/local/bin/fish</code>。最后文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># List of acceptable shells for chpass(1).</span><br><span class="line"># Ftpd will not allow users to connect who are not using</span><br><span class="line"># one of these shells.</span><br><span class="line"></span><br><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br><span class="line">/usr/local/bin/fish</span><br></pre></td></tr></table></figure>
<p>最后，按 esc 键跳到命令模式，输入<code>:wq</code> 命令保存文件并退出vim。当前模式还是 bash shell 模式，要切换到 fish shell 需要输入 <code>fish</code> 命令。每次都输入命令切换 shell 比较繁琐，我们可以通过如下命令从 bash 切换到 fish ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chsh -s /usr/local/bin/fish</span><br></pre></td></tr></table></figure>
<p>也可以通过如下命令切回到 bash：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ol>
<li>自动建议<br>Fish 会自动在光标后面给出建议，颜色为灰色。按下<code>→</code>或<code>Control + F</code>表示采纳建议，按下<code>Alt + →</code>表示只采纳一部分。</li>
<li>Tab 键补全<br>按下 <code>Tab</code> 键，Fish 将尝试自动补全命令、参数或路径，如果有多条补全建议，可以继续使用 <code>Tab</code> 键在不同建议间切换。</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>因为博主并不是天天跟命令行打交道，shell 也根本不会，只是在学习和工作中偶尔会用到命令行，敲几行命令执行一些操作，所以这篇文章只是简单的介绍 Fish shell，作为一个学习的记录，想深入了解的可以访问<span class="exturl" data-url="aHR0cHM6Ly93d3cuZmlzaHNoZWxsLmNvbS8=">官网<i class="fa fa-external-link-alt"></i></span>。<br>有了 Homebrew + iTerm 2 + Fish shell，对命令行有畏惧和抵触情绪的「终端恐惧症患者」再也不用头疼了。关于 Homebrew 和 iTerm 2 的介绍请看我的另外两篇文章：<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vMjAxNy8wOC8yNi9tYWMtaG9tZWJyZXcv">Mac开发必备工具（一）—— Homebrew<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vMjAxNy8wOC8yNy9tYWMtaXRlcm0yLw==">Mac开发必备工具（二）—— iTerm 2<i class="fa fa-external-link-alt"></i></span>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZmlzaHNoZWxsLmNvbS9kb2NzL2N1cnJlbnQvdHV0b3JpYWwuaHRtbA==">fish tutorial<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<p><strong>同系列文章</strong></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vMjAxNy8wOC8yNi9tYWMtaG9tZWJyZXcv">Mac开发必备工具（一）—— Homebrew<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vMjAxNy8wOC8yNy9tYWMtaXRlcm0yLw==">Mac开发必备工具（二）—— iTerm 2<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vMjAxNy8wOC8yOC9tYWMtZmlzaHNoZWxsLw==">Mac开发必备工具（三）—— Fish shell<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Fish shell</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac开发必备工具（一）—— Homebrew</title>
    <url>/post/mac-homebrew/</url>
    <content><![CDATA[<h1 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>macOS 缺失的软件包管理器。使用 Homebrew 安装 Apple 没有预装但 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0hvbWVicmV3L2hvbWVicmV3LWNvcmUvdHJlZS9tYXN0ZXIvRm9ybXVsYQ==">你需要的东西<i class="fa fa-external-link-alt"></i></span>。<span class="exturl" data-url="aHR0cHM6Ly9icmV3LnNoLw==">官网<i class="fa fa-external-link-alt"></i></span>有中文说明。</p>
<h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p>Homebrew 的安装非常简单，将下面这条命令粘贴到终端：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>
<p>等待命令执行完毕。其他配置见<span class="exturl" data-url="aHR0cHM6Ly9icmV3LnNoL2luZGV4X3poLWNuLmh0bWw=">官网中文说明<i class="fa fa-external-link-alt"></i></span>。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol>
<li><code>brew help</code> 查看帮助</li>
<li><code>brew install &lt;package name&gt;</code> 安装软件包</li>
<li><code>brew uninstall &lt;package name&gt;</code> 卸载软件包</li>
<li><code>brew list [--versions]</code> 列出已安装的软件包(包括版本)</li>
<li><code>brew search &lt;package name&gt;</code> 查找软件包</li>
<li><code>brew info &lt;package name&gt;</code> 查看软件包信息</li>
<li><code>brew update</code> 更新brew</li>
<li><code>brew outdated</code> 列出过时的软件包（已安装但不是最新版本）</li>
<li><code>brew upgrade [&lt;package name&gt;]</code> 更新过时的软件包（不指定软件包表示更新全部）</li>
<li><code>brew doctor</code> 检查brew运行状态</li>
</ol>
<h2 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install wget</span><br><span class="line">brew install curl</span><br><span class="line">brew install openssl</span><br><span class="line"></span><br><span class="line">brew install fish      #安装fish shell</span><br><span class="line">brew install git-flow  #安装git-flow</span><br><span class="line">brew install python    #安装python</span><br></pre></td></tr></table></figure>

<h2 id="Homebrew-Cask"><a href="#Homebrew-Cask" class="headerlink" title="Homebrew-Cask"></a>Homebrew-Cask</h2><p>Homebrew-Cask 是 Homebrew 的一个扩展。它能够优雅、简单、快速的安装和管理 macOS 图形界面程序，比如Google Chrome 和Dropbox等等。官网 <span class="exturl" data-url="aHR0cHM6Ly9jYXNrcm9vbS5naXRodWIuaW8vJUUzJTgwJTgy">https://caskroom.github.io/。<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Cask-必装的理由"><a href="#Cask-必装的理由" class="headerlink" title="Cask 必装的理由"></a>Cask 必装的理由</h3><p>有图形界面的软件可以直接在 App Stroe 中下载更新，为啥还需要 Cask 呢？因为有的很好用的免费 Mac 软件并没有选择在 App Store 上架，对于没有上架的软件我们只能是通过搜索找到官网然后在下载安装包，这样不够优雅也不方便管理，而使用 Cask 可以通过一行命令就搞定安装了，还可以统一更新升级所有的软件，实现从非 App Store 途径安装的软件的统一管理。<br>Cask 从软件官方网站下载软件包，然后在后台安装并将 <code>.app</code> 移动到 <code>Applications</code>。通过 Cask 安装的软件也会在 Lanuchpad 显示，跟从 App Store 安装的软件没啥区别。对于那些收费的软件，用 Cask 安装只是比普通安装方法节省了时间和步骤，没啥其他的区别。</p>
<h3 id="Cask-常用命令"><a href="#Cask-常用命令" class="headerlink" title="Cask 常用命令"></a>Cask 常用命令</h3><ol>
<li><del><code>brew cask -help</code> 查看帮助</del></li>
<li><code>brew install --cask &lt;software name&gt;</code> 安装软件</li>
<li><code>brew uninstall --cask &lt;software name&gt;</code> 卸载软件</li>
<li><code>brew search --cask &lt;software name&gt;</code> 搜索软件</li>
<li><code>brew  info --cask  &lt;software name&gt;</code> 查看软件相关信息</li>
<li><code>brew list --cask</code> 列出通过 Homebrew-Cask 安装的包</li>
</ol>
<blockquote>
<p>经过测试，虽然 <code>-help</code> 是未知命令，但是仍然可查看 Cask 的命令，其他帮助命令（如 <code>brew cask -h</code> 和 <code>brew cask --help</code>）好像都不行。还有其他的命令就不一一介绍了，其他命令可以通过<code>brew --help</code>查看。</p>
</blockquote>
<h3 id="Cask-常用软件"><a href="#Cask-常用软件" class="headerlink" title="Cask 常用软件"></a>Cask 常用软件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install --cask iterm2         #安装 iTerm 2</span><br><span class="line">brew install --cask launchrocket   #管理软件后台服务</span><br><span class="line">brew install --cask google-chrome  #安装 Chrome</span><br><span class="line">brew install --cask the-unarchiver #解压软件</span><br><span class="line">brew install --cask alfred         #效率软件</span><br><span class="line">brew install --cask qq             #腾讯 QQ</span><br><span class="line">brew install --cask evernote       #云笔记软件</span><br><span class="line">brew install --cask sublime-text   #文本编辑器</span><br><span class="line">brew install --cask skitch         #Evernote 配套的截图软件</span><br><span class="line">brew install --cask dropbox        #文件同步软件</span><br><span class="line">brew install --cask zotero         #网页收藏与文献管理软件</span><br><span class="line">brew install --cask anki           #记忆软件</span><br><span class="line">brew install --cask virtualbox     #虚拟机，可以装个 Windows</span><br><span class="line">brew install --cask self-control   #避免分心的软件</span><br><span class="line">brew install --cask vlc            #视频软件</span><br><span class="line">brew install --cask appcleaner     #应用清理</span><br><span class="line"></span><br><span class="line">#Quick Look 系列</span><br><span class="line">brew install --cask qlcolorcode    #预览脚本时自动代码配色</span><br><span class="line">brew install --cask qlstephen      #预览未知拓展名的纯文本文件</span><br><span class="line">brew install --cask qlmarkdown     #预览Markdown文件</span><br><span class="line">brew install --cask quicklook-json #预览JSON文件</span><br><span class="line">brew install --cask quicklook-csv  #预览CSV文件</span><br></pre></td></tr></table></figure>

<p>Homebrew-Cask 是一个开源项目，其详细信息可以看<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nhc2tyb29tL2hvbWVicmV3LWNhc2s=">其开源项目介绍<i class="fa fa-external-link-alt"></i></span>，所支持的软件列表在这里：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nhc2tyb29tL2hvbWVicmV3LWNhc2svdHJlZS9tYXN0ZXIvQ2Fza3M=">https://github.com/caskroom/homebrew-cask/tree/master/Casks<i class="fa fa-external-link-alt"></i></span> 。<br>如果觉得管理软件在后台运行的服务很麻烦，可以装个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ppbWJvanNiL2xhdW5jaHJvY2tldA==">LaunchRocket<i class="fa fa-external-link-alt"></i></span>，这也是个开源项目。<br>关于 Quick Look 的介绍可以看这篇文章<span class="exturl" data-url="aHR0cHM6Ly9zc3BhaS5jb20vcG9zdC8zMTkyNw==">加强你的「一指禅」：Mac QuickLook「快速预览」兼容性扩展教程<i class="fa fa-external-link-alt"></i></span>，同时<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWljay1sb29rLXBsdWdpbnM=">Quick Look plugins<i class="fa fa-external-link-alt"></i></span>这个开源项目列出了所有支持 Homebrew-Cask 的 Quick Look 扩展，据说支持的都是程序员必备。</p>
<h2 id="轻松实现一键装机"><a href="#轻松实现一键装机" class="headerlink" title="轻松实现一键装机"></a>轻松实现一键装机</h2><p>在使用 Mac 的过程中，总想着有没有方便、简单的办法实现在不同Mac 上同步开发环境的办法，今天在整理 Homebrew 使用笔记的时候突然冒出一个想法，如果我把所有的 Homebrew 安装命令列成一个清单形式，当在另一台新的 Mac 上工作时，那么就可以先装一个 Homebrew 然后将命令清单中的所有命令复制粘贴到终端中，等待命令执行完毕后，新的 Mac 的大部分开发环境就跟常用的 Mac 开发环境一致了。下面列出笔者的常用命令清单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#安装 Homebrew</span><br><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line"></span><br><span class="line">#安装基础套件</span><br><span class="line">brew install fish      #安装 fish shell</span><br><span class="line">brew install git-flow  #安装 git-flow</span><br><span class="line">brew install python    #安装 python</span><br><span class="line"></span><br><span class="line">#Homebrew-Cask</span><br><span class="line">brew tap caskroom/cask</span><br><span class="line"></span><br><span class="line"># 安装 Cask 基础软件</span><br><span class="line">brew install --cask iterm2              #安装 iTerm 2</span><br><span class="line">brew install --cask visual-studio-code  #微软出品的文本编辑器，可替代 Sublime Text</span><br><span class="line">brew install --cask google-chrome       #安装 Chrome</span><br><span class="line">brew install --cask the-unarchiver      #解压软件</span><br><span class="line">brew install --cask alfred              #效率软件</span><br><span class="line">brew install --cask qq                  #腾讯 QQ</span><br><span class="line">brew install --cask sourcetree          #Git GUI 客户端</span><br><span class="line">brew install --cask cheatsheet          #显示当前程序的快捷键列表，默认快捷键是长按⌘</span><br></pre></td></tr></table></figure>

<p>这份清单会随着我对 Mac 的不断深入了解而持续更新，欢迎关注 <span class="exturl" data-url="aHR0cHM6Ly9kYXZpZHNoZWguZ2l0aHViLmlvLw==">Sheh 伟伟的个人博客<i class="fa fa-external-link-alt"></i></span>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hYWFhYWFzaHUuZ2l0Ym9va3MuaW8vbWFjLWRldi1zZXR1cC9jb250ZW50L0hvbWVicmV3L2luZGV4Lmh0bWw=">Mac 开发配置手册<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<p><strong>同系列文章</strong></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vMjAxNy8wOC8yNi9tYWMtaG9tZWJyZXcv">Mac开发必备工具（一）—— Homebrew<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vMjAxNy8wOC8yNy9tYWMtaXRlcm0yLw==">Mac开发必备工具（二）—— iTerm 2<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vMjAxNy8wOC8yOC9tYWMtZmlzaHNoZWxsLw==">Mac开发必备工具（三）—— Fish shell<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Homebrew</tag>
        <tag>Homebrew-Cask</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac开发必备工具（二）—— iTerm 2</title>
    <url>/post/mac-iterm2/</url>
    <content><![CDATA[<h1 id="iTerm-2"><a href="#iTerm-2" class="headerlink" title="iTerm 2"></a>iTerm 2</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>iTerm 2 is a terminal emulator for Mac OS X that does amazing things.</p>
</blockquote>
<p>iTerm 2 有很多能够提升效率的实用功能。比如说窗口分割、热键窗口、智能搜索、自动完成、快速复制等等，其他功能可查看<span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRlcm0yLmNvbS9mZWF0dXJlcy5odG1s">官网的Features页<i class="fa fa-external-link-alt"></i></span>。</p>
<h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>有两种方式可以安装iTerm 2：</p>
<ol>
<li>直接从<span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRlcm0yLmNvbS9pbmRleC5odG1s">官网<i class="fa fa-external-link-alt"></i></span>下载安装包。</li>
<li>使用 Homebrew 命令<code>brew install iTerm2</code>安装。</li>
</ol>
<p>个人推荐使用第二种方式安装。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>关于 iTerm 2 的配置可以参考官网介绍，然后根据自己的喜好配置。这里介绍一个实用的快捷键配置和一个主题配置。</p>
<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>快速显示和隐藏 iTerm 2 的快捷键设置如下图：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/iterm2_hotkey.jpg" alt="iTerm 2 Hotkey"><br>快捷键的设置可以根据自己的使用习惯来设置。</p>
<h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>经过多款主题的对比，最终选择了推荐最多的一款主题<span class="exturl" data-url="aHR0cDovL2V0aGFuc2Nob29ub3Zlci5jb20vc29sYXJpemVk">Solarized<i class="fa fa-external-link-alt"></i></span>。选择这款主题是因为它有自己的<span class="exturl" data-url="aHR0cDovL2V0aGFuc2Nob29ub3Zlci5jb20vc29sYXJpemVk">官网<i class="fa fa-external-link-alt"></i></span>，同时支持主流的编辑器和 IDE。主题配置步骤如下：</p>
<ol>
<li>先去<span class="exturl" data-url="aHR0cDovL2V0aGFuc2Nob29ub3Zlci5jb20vc29sYXJpemVk">官网<i class="fa fa-external-link-alt"></i></span>下载主题压缩包，<span class="exturl" data-url="aHR0cDovL2V0aGFuc2Nob29ub3Zlci5jb20vc29sYXJpemVkL2ZpbGVzL3NvbGFyaXplZC56aXA=">直接下载链接点这里<i class="fa fa-external-link-alt"></i></span>。</li>
<li>下载后解压，然后<code>⌘+,</code>打开 iTerm 2 的首选项，接着 Profiles -&gt; Colors -&gt; Color Presets -&gt; Import，选择刚解压的文件夹<code>solarized/iterm2-colors-solarized</code>下的<code>Solarized Dark.itermcolors</code>文件。</li>
<li>在Color Presets 下拉菜单中选中 Solarized Dark 主题，大功告成。</li>
<li>配置截图如下：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/iterm2_theme.jpg" alt="iTerm 2 Hotkey"></li>
</ol>
<p>这里放一张效果图简单的预览一下主题的效果。<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/iterm2_preview.jpg" alt="Solarized Preview"></p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ol>
<li><code>⌘+T</code> 打开一个新的标签页</li>
<li><code>⌘+;</code> 弹出自动补齐窗口</li>
<li><code>⌘+Shift+;</code> 弹出历史命令记录窗口</li>
<li><code>⌘+Shift+H</code> 弹出历史粘贴记录窗口</li>
<li><code>⌘+←</code>、<code>⌘+→</code>、 <code>⌘+&#123;</code>, <code>⌘+&#125;</code>、<code>⌘+&lt;number&gt;</code> 切换标签页</li>
<li><code>⌘+F</code> 智能查找，支持正则查找</li>
<li><code>⌘+[</code>、<code>⌘+]</code>、<code>⌘+Option+方向键</code> 切换 pane</li>
<li><code>⌘+D</code>  水平切分屏幕，<code>⌘+Shift+D</code> 垂直切分屏幕</li>
<li><code>⌘+Enter</code> 进入与返回全屏模式</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>当然，iTerm 2 的功能远远不止这些，本文只是博主在使用过程中的一个记录和总结，后续用到其他高级功能了再来补充，待续…</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><span class="exturl" data-url="aHR0cDovL3d3dy5pdGVybTIuY29tL2RvY3VtZW50YXRpb24uaHRtbA==">iTerm2官方文档<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<p><strong>同系列文章</strong></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vMjAxNy8wOC8yNi9tYWMtaG9tZWJyZXcv">Mac开发必备工具（一）—— Homebrew<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vMjAxNy8wOC8yNy9tYWMtaXRlcm0yLw==">Mac开发必备工具（二）—— iTerm 2<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vMjAxNy8wOC8yOC9tYWMtZmlzaHNoZWxsLw==">Mac开发必备工具（三）—— Fish shell<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>iTerm 2</tag>
        <tag>Solarized</tag>
      </tags>
  </entry>
  <entry>
    <title>Rider 常用快捷键</title>
    <url>/post/rider_shortcut/</url>
    <content><![CDATA[<h2 id="Rider-常用快捷键"><a href="#Rider-常用快捷键" class="headerlink" title="Rider 常用快捷键"></a>Rider 常用快捷键</h2><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><ul>
<li><code>Ctrl</code> + <code>/</code>	                注释</li>
<li><code>Shift</code> + <code>F6</code>                重命名</li>
<li><code>Ctrl</code> + <code>Y</code>                  删除一行</li>
<li><code>Ctrl</code> + <code>Alt</code> + <code>Left/Right</code> 返回上次编辑位置</li>
<li><code>Ctrl</code> + <code>Alt</code> + <code>L</code>          格式化代码</li>
<li><code>Ctrl</code> + <code>D</code>                  复制当前行</li>
<li><code>Shift</code> + <code>Alt</code> + <code>Up</code>        将行往上移动</li>
<li><code>Ctrl</code> + <code>W</code>	                区域选择</li>
</ul>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul>
<li><code>Ctrl</code> + <code>F</code>              在当前文件查找</li>
<li><code>Ctrl</code> + <code>Shift</code> + <code>F</code>    全局查找</li>
<li><code>Ctrl</code> + <code>N</code>              全局查找类</li>
<li><code>Ctrl</code> + <code>Shift</code> + <code>N</code>    全局查找代码文件</li>
<li><code>Ctrl</code> + <code>R</code>              查找并替换</li>
<li><code>Ctrl</code> + <code>Shift</code> + <code>R</code>	全局查找并替换</li>
<li><code>Ctrl</code> + <code>G</code>              定位到某一行</li>
<li><code>Alt</code> + <code>F7</code>              查找所有引用</li>
</ul>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><ul>
<li><code>Alt</code> + <code>Shift</code> + <code>F9</code>    开始调试</li>
<li><code>F8</code>	                    单步调试</li>
<li><code>F7</code>	                    进入当前方法</li>
<li><code>F9</code>	                    跳到下一个断点</li>
</ul>
<h3 id="版本控制（VCS）"><a href="#版本控制（VCS）" class="headerlink" title="版本控制（VCS）"></a>版本控制（VCS）</h3><ul>
<li><code>Ctrl</code> + <code>T</code>              更新本地代码</li>
<li><code>Ctrl</code> + <code>K</code>              提交本地代码</li>
<li><code>Ctrl</code> + <code>Shift</code> + <code>K</code>    Push提交的文件</li>
</ul>
<h2 id="Rider-快捷键冲突"><a href="#Rider-快捷键冲突" class="headerlink" title="Rider 快捷键冲突"></a>Rider 快捷键冲突</h2><p>Rider 全局搜索快捷键 <code>Ctrl</code> + <code>Shift</code> + <code>F</code> 跟 Win10 繁体字切换冲突了。解决办法是将 Win10 繁体字切换的快捷键更改成其他快捷键。进入 Win10 设置界面，选择时间和语言 -&gt; 语言 -&gt; 首选语言 -&gt; 中文（简体，中国） -&gt; 选项 -&gt; 键盘 -&gt; 微软拼音 -&gt; 选项 -&gt; 按键 -&gt; 热键 -&gt; 简体&#x2F;繁体中文输入切换。可以禁用切换，也可以把快捷键改成其他快捷键，如 <code>Ctrl</code> + <code>Shift</code> + <code>A</code>。</p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>uFrame插件导入报错</title>
    <url>/post/uFrame%E6%8F%92%E4%BB%B6%E5%AF%BC%E5%85%A5%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>最近想研究一下uFrame插件，于是从AssetStore下载了最新的uFrame插件。下载后导入到Unity是两个版本的unitypackage包，分别是uFrame-1.5.1r2和uFrame-1.6.3r1。网上简单查了一下，说两个版本差别还是挺大的，新版本不能向前兼容。</p>
<p><strong>一、挡路的狗（Bug）</strong></p>
<hr>
<p>我最后选择了最新版本，双击后导入，导入完成后，控制台出现如下错误：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/uframe_1.jpg" alt="Error1.png"><br>一大堆错误的详细信息就不一一列出了，第一个错误的详细信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Assets/uFrame/MVVM/Framework/Editor/Templates/uFrameTemplates.cs(144,48): error CS0246: The type or namespace name `UGUIExtensions&#x27; could not be found. Are you missing a using directive or an assembly reference?</span><br></pre></td></tr></table></figure>
<p>分析了一下，发现是UGUIExtensions这个类因为某个原因没找到，然后，我直接用VS的全局搜索整个解决方案。最后，发现UGUIBindings.cs这个脚本中的UGUIExtensions类被宏命令屏蔽了，因为我使用的Unity版本是5.3.4f1，而UGUIBindings.cs这个脚本的第一行<code>#if UNITY_4_6 || UNITY_5_0 || UNITY_5_1 || UNITY_5_2</code>直接不支持5.3.4f1，所以解决办法就是直接在第一行末尾追加<code> || UNITY_5_3</code>。<br>改完保存编译后，果然没错了。本来以为可以开始好好研究了，然而并非如此。</p>
<p><strong>二、拦路虎（Exception）</strong></p>
<hr>
<p>当我导入ExampleProject案例工程的unitypackage后，一切正常没有报错，接着，我选择Window -&gt; uFrameDesigner打开uFrame的可视化编辑器后，疯狂的抛出如下异常：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/uframe_2.jpg" alt="Error2.png"></p>
<p>异常详细信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UnityException: Texture &#x27;Header3&#x27; is not readable, the texture memory can not be accessed from scripts. You can make the texture readable in the Texture Import Settings.</span><br><span class="line">UnityEngine.Texture2D.GetPixels32 () (at C:/buildslave/unity/build/artifacts/generated/common/runtime/TextureBindings.gen.cs:336)</span><br><span class="line">Invert.Common.TexturesExtensions.CutTextureBottomBorder (UnityEngine.Texture2D texture, Int32 cutSize) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner.Unity/ElementDesignerStyles.cs:1998)</span><br><span class="line">Invert.Core.GraphDesigner.Unity.Schemas.UnityNodeStyleSchema.ConstructHeaderImage (Boolean expanded, Color color, System.String iconName) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner.Unity/Schemas/UnityNodeStyleSchema.cs:57)</span><br><span class="line">Invert.Core.GraphDesigner.Schemas.impl.NodeStyleSchema.GetHeaderImage (Boolean expanded, Color color, System.String iconName) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner/Schemas/impl/NodeStyleSchema.cs:176)</span><br><span class="line">Invert.Core.GraphDesigner.HeaderDrawer.Draw (IPlatformDrawer platform, Single scale) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner/Drawers/impl/HeaderDrawer.cs:97)</span><br><span class="line">Invert.Core.GraphDesigner.DiagramNodeDrawer.DrawChildren (IPlatformDrawer platform, Single scale) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner/Drawers/impl/DiagramNodeDrawer.cs:356)</span><br><span class="line">Invert.Core.GraphDesigner.DiagramNodeDrawer.Draw (IPlatformDrawer platform, Single scale) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner/Drawers/impl/DiagramNodeDrawer.cs:292)</span><br><span class="line">Invert.Core.GraphDesigner.GenericNodeDrawer`2[TData,TViewModel].Draw (IPlatformDrawer platform, Single scale) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner/Drawers/impl/DiagramNodeDrawer.cs:64)</span><br><span class="line">Invert.Core.GraphDesigner.DiagramDrawer.Draw (IPlatformDrawer platform, Single scale) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner/Drawers/impl/DiagramDrawer.cs:146)</span><br><span class="line">Invert.Core.GraphDesigner.DesignerWindow.DrawDiagram (IPlatformDrawer drawer, Vector2 scrollPosition, Single scale, Rect diagramRect) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner/Windows/DesignerWindow.cs:349)</span><br><span class="line">Invert.Core.GraphDesigner.DesignerWindow.Draw (IPlatformDrawer drawer, Single width, Single height, Vector2 scrollPosition, Single scale) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner/Windows/DesignerWindow.cs:256)</span><br><span class="line">Invert.Core.GraphDesigner.Unity.ElementsDesigner.OnGUI () (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner.Unity/ElementsDesigner.cs:256)</span><br><span class="line">System.Reflection.MonoMethod.Invoke (System.Object obj, BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) (at /Users/builduser/buildslave/mono/build/mcs/class/corlib/System.Reflection/MonoMethod.cs:222)</span><br></pre></td></tr></table></figure>
<p>这时，uFrame的编辑器窗口也是卡死状态。通过分析报错信息发现，是因为一个名为Header3的图片为非可读的，所以报错了。找到Header3图片，然后修改图片格式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/uframe_3.jpg" alt="Image Setting.png"></p>
<p>修改完后所有的都正常了。正在我得意的以为可以好好开始研究一下案例的时候，现实总是残酷的。。。</p>
<p><strong>三、死耗子（Error）</strong></p>
<hr>
<p>当我选择第一个场景双击打开点击运行后，发现报了如下错误：</p>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/uframe_4.jpg" alt="Error3.png"><br>详细信息就不贴了，第一个问题很明显，就是相应的场景没有添加进Build Settings，反正也不知道场景的添加顺序，我就直接把案例工程中的所有场景都添加进Build Settings。然后，重新运行就都正常了。终于可以开开心心的研究uFrame了</p>
<blockquote>
<p>uFrame-1.5.1r2导入后也有很多错误，不过我懒得研究了。我喜欢用新版的，我是一个喜新厌旧的人。对uFrame-1.5.1r2感兴趣的人可以自己研究一下。</p>
</blockquote>
<hr>
<blockquote>
<p>如果本文有错误之处还请帮忙指出。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>uFrame</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity 开发中常见的 C# 性能问题</title>
    <url>/post/unity-csharp-performance/</url>
    <content><![CDATA[<h2 id="for-VS-foreach"><a href="#for-VS-foreach" class="headerlink" title="for VS. foreach"></a>for VS. foreach</h2><p>老版本的 Unity （测试用的是 Unity 5.0.2f1) foreach 是有大概 40B 的 GC，所以，项目重遍历 IList、ArrayList 和 Dictionary 时都不要用 foreach。<br>使用 for 替代，或者使用如下写法：</p>
<ul>
<li><p>List 的非 foreach 遍历</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;int&gt; data = new List&lt;int&gt;();</span><br><span class="line">var e = data.GetEnumerator();</span><br><span class="line">while(e.MoveNext())</span><br><span class="line">&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Dictionary 的非 foreach 遍历</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var enumerator = dictionary.GetEnumerator();</span><br><span class="line">while (enumerator.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    var element = enumerator.Current;</span><br><span class="line">    element.Value.DoSomethine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：Unity 5.5 已修复此问题。</p>
</blockquote>
</li>
</ul>
<h2 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h2><p>连接次数只有几次（10 以内），此时应该直接用 <code>+</code> 号连接，不产生 GC。实际<br>上，编译器已经做了优化。</p>
<p>其余的使用 StringBuilder， StringBuilder 内部 Buffer 的缺省值为 16，<br>按 StringBuilder 的使用场景， Buffer 肯定得重新分配。经验值一般用 256 作<br>为 Buffer 的初值。当然，如果能计算出最终生成字符串长度的话，则应该按这<br>个值来设定 Buffer 的初值。使用 new StringBuilder(256) 就将 Buffer 的初始<br>长度设为了 256。</p>
<h2 id="Struct-VS-Class"><a href="#Struct-VS-Class" class="headerlink" title="Struct VS. Class"></a>Struct VS. Class</h2><p>Struct 在栈中不产生 GC， Class 在堆中，会产生 GC。<br>对 Struct 的结点修改时，修改完以后记得重新赋值。 因为 Struct 赋值是 copy<br>而不是引用，修改完以后，以前的不生效。</p>
<p>使用情景：</p>
<ul>
<li>堆栈的空间有限，对于大量的逻辑的对象，创建类要比创建结构好一些。</li>
<li>结构表示轻量对象，并且结构的成本较低，适合处理大量短暂的对象。</li>
<li>在表现抽象和多级别的对象层次时，类是最好的选择。</li>
<li>大多数情况下该类型只是一些数据，且数据的类型为值类型时，结构是最佳的选择。</li>
</ul>
<h2 id="数组、ArrayList-和-List-的区别？"><a href="#数组、ArrayList-和-List-的区别？" class="headerlink" title="数组、ArrayList 和 List 的区别？"></a>数组、ArrayList 和 List 的区别？</h2><ul>
<li>数组：内存中是连续存储的，索引速度非常快，赋值与修改元素也很简单。但不利于动态扩展以及移动。因为数组的缺点，就产生了 ArrayList。</li>
<li>ArrayList：使用该类时必须进行引用，同时继承了 IList 接口，提供了数据存储和检索，ArrayList 对象的大小动态伸缩，支持不同类型的结点。ArrayList 虽然很完美，但结点类型是 Object，故不是类型安全的，也可能发生装箱和拆箱操作，带来很大的性能耗损。</li>
<li>List 是泛型接口，规避了 ArrayList 的两个问题。</li>
</ul>
<h2 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h2><p>Enum 会产生 GC 的两种情况：</p>
<ol>
<li>把枚举当 TKey 使用。也就是以枚举作 Dictionary 的键。</li>
<li>把枚举转成 string 使用。</li>
</ol>
<blockquote>
<p>把枚举作为 Dictionary 的键会产生 GC，是因为将 enum 值类型装换成 object 引用类型会产生装箱。<br>Dictionary 本质上，比较键的方法是使用 <code>EqualComparer&lt;T&gt;.Default</code>，然后调用 <code>GetHashCode()</code> 以找到正确的存储桶，并 <code>Equals</code> 比较存储桶中是否有我们要寻找的值。详细解释请看 <span class="exturl" data-url="aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjYyODE1MzM=">http://stackoverflow.com/a/26281533<i class="fa fa-external-link-alt"></i></span> 。</p>
</blockquote>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System;</span><br><span class="line">public class TestClosure : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    void Update ()</span><br><span class="line">    &#123;</span><br><span class="line">        int num = 1;</span><br><span class="line">        Action action = () =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            int count = num++;</span><br><span class="line">        &#125;;</span><br><span class="line">        action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码会有 112B 的 GC。</p>
<p>使用闭包的时候，涉及到大约 112B 的 GC，随着闭包引用内容的增加而增大。看自己的需求，如果函数调用频繁的话，要考虑是否不使用闭包来实现。</p>
<h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void TestDelegate1(String param)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Action&lt;string&gt; TestDelegate2 = (param) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">public void TestFunction(Action&lt;string&gt; callback)</span><br><span class="line">&#123;</span><br><span class="line">    //do something</span><br><span class="line">    callback(&quot;this is a test string&quot;);</span><br><span class="line">    //do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void TestCall1()</span><br><span class="line">&#123;</span><br><span class="line">    TestFunction(TestDelegate1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void TestCall2()</span><br><span class="line">&#123;</span><br><span class="line">    TestFunction(TestDelegate2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TestCall1()</code> 调用有 GC 问题，而 <code>TestCall2()</code> 调用没有。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System;</span><br><span class="line"></span><br><span class="line">public class Test : MonoBehaviour </span><br><span class="line">&#123;</span><br><span class="line">	void Update ()</span><br><span class="line">	&#123;</span><br><span class="line">		UnityEngine.Profiling.Profiler.BeginSample(&quot;TestDelegate1&quot;);</span><br><span class="line">		TestCall1();</span><br><span class="line">		UnityEngine.Profiling.Profiler.EndSample();</span><br><span class="line"></span><br><span class="line">		UnityEngine.Profiling.Profiler.BeginSample(&quot;TestDelegate2&quot;);</span><br><span class="line">		TestCall2();</span><br><span class="line">		UnityEngine.Profiling.Profiler.EndSample();</span><br><span class="line"></span><br><span class="line">		UnityEngine.Profiling.Profiler.BeginSample(&quot;TestDelegate3&quot;);</span><br><span class="line">		TestFunction2(TestDelegate3);</span><br><span class="line">		UnityEngine.Profiling.Profiler.EndSample();</span><br><span class="line"></span><br><span class="line">		UnityEngine.Profiling.Profiler.BeginSample(&quot;TestDelegate4&quot;);</span><br><span class="line">		TestFunction2(TestDelegate4);</span><br><span class="line">		UnityEngine.Profiling.Profiler.EndSample();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void TestDelegate1(string param)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Action&lt;string&gt; TestDelegate2 = (param) =&gt;</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	public void TestFunction(Action&lt;string&gt; callback)</span><br><span class="line">	&#123;</span><br><span class="line">		//do something</span><br><span class="line">		callback(&quot;this is a test string&quot;);</span><br><span class="line">		//do something</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void TestCall1()</span><br><span class="line">	&#123;</span><br><span class="line">		TestFunction(TestDelegate1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void TestCall2()</span><br><span class="line">	&#123;</span><br><span class="line">		TestFunction(TestDelegate2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public delegate void MyDele(string p);</span><br><span class="line">	public void TestDelegate3(string p)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	public MyDele TestDelegate4 = (param) =&gt;</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;;</span><br><span class="line">	public void TestFunction2(MyDele callback)</span><br><span class="line">	&#123;</span><br><span class="line">		//do something</span><br><span class="line">		callback(&quot;this is a test string&quot;);</span><br><span class="line">		//do something</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void TestCall3()</span><br><span class="line">	&#123;</span><br><span class="line">		TestFunction2(TestDelegate3);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void TestCall4()</span><br><span class="line">	&#123;</span><br><span class="line">		TestFunction2(TestDelegate4);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Unity3D 2017.4.0 上测试，<code>TestCall1()</code> 和 <code>TestCall3()</code> 的调用都有 104B 的 GC，而 <code>TestCall2()</code> 和 <code>TestCall4</code> 则没有 GC。</p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity3D</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity DOTS-Subscene 介绍</title>
    <url>/post/unity-dots-subscene/</url>
    <content><![CDATA[<h2 id="为什么要学-DOTS-？"><a href="#为什么要学-DOTS-？" class="headerlink" title="为什么要学 DOTS ？"></a>为什么要学 DOTS ？</h2><p><strong>DOTS 代表了 Unity 的未来。</strong>Unity 的架构正在朝着全面采用 DOTS 的方向发展。面向数据的设计(DoD)堪称是实时3D 行业的未来。利用 DoD 原理和实现来解决问题并开发复杂的解决方案已成为大势所趋，尤其是在游戏领域。<br>例如，瑞典游戏工作室 Far North Entertainment 就使用了 DOTS 来解决他们的性能问题，相关说明见 “<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnVuaXR5LmNvbS9nYW1lcy9jcmVhdGluZy1hLXRoaXJkLXBlcnNvbi16b21iaWUtc2hvb3Rlci13aXRoLWRvdHM=">Creating a third-person zombie shooter with DOTS<i class="fa fa-external-link-alt"></i></span>”（使用DOTS创建第三人称僵尸扫荡游戏）。<br>还有国内公司海彼游戏研运的《蛋壳特攻队》，就是使用的 Unity DOTS 技术，相关技术介绍见<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvSlZKbV9jSG5Dc3A5S0l4clBmZ2VnUQ==">《弹壳特攻队》开发技术分享<i class="fa fa-external-link-alt"></i></span>。<br>据称使用了 DoD 的非 Unity 游戏示例包括：暴雪的《守望先锋》和 CD Projekt 的《巫师3》。</p>
<h2 id="DOTS-介绍"><a href="#DOTS-介绍" class="headerlink" title="DOTS 介绍"></a>DOTS 介绍</h2><p>DOTS 是 Data-Oriented Tech Stack 的缩写，官方翻译为多线程式数据导向型技术堆栈。它可以利用多核处理器来实现数据的并行处理并提高 Unity 项目的性能。<br>目前，DOTS 可与不同的格式共存，并与 Unity MonoBehaviours（非 DOTS 结构）一起使用。最终，Unity 将完全过渡到 DOTS。<br>DOTS 包含以下元素：</p>
<ol>
<li>实体组件系统(ECS) - 提供使用面向数据的方法进行编码的框架。它通过 Entities 软件包进行分发，您可以通过 Package Manager 来添加编辑器。在 1.0 版本中，分成了两个软件包 Entities 和 Entities Graphics。</li>
<li>C# 作业系统（Job System） - 提供一种生成多线程代码的简单方法。它通过Jobs软件包进行分发。</li>
<li>Burst 编译器 - 可生成快速、优化的本机代码。它通过Burst软件包进行分发，可通过 Package Manager 在编辑器中使用。</li>
<li>本机容器 - 属于 ECS 数据结构，可提供对内存的控制。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures@master/pictures/unity_dots_archite.webp" alt="unity_dots_archite"></p>
<h2 id="烘焙（Baking）"><a href="#烘焙（Baking）" class="headerlink" title="烘焙（Baking）"></a>烘焙（Baking）</h2><h3 id="通过烘焙转换数据"><a href="#通过烘焙转换数据" class="headerlink" title="通过烘焙转换数据"></a>通过烘焙转换数据</h3><p>烘焙是将 Unity 编辑器中的游戏对象数据（<strong>Authoring data</strong>，即创作数据）转换成写入实体场景的实体（<strong>Runtime data</strong>，即运行时数据）的过程。烘焙是一个不可逆的过程，它将一组性能密集型但灵活的游戏对象转变为一组针对性能进行优化的实体和组件。<br><strong>创作数据（Authoring data）</strong>：是在编辑应用程序期间创建的任何数据，例如脚本、资产或任何其他游戏相关数据。这种数据类型灵活且可读：专为人类交互而设计。<br><strong>运行时数据（Runtime data ）</strong>：是 ECS 在运行时处理的数据，例如进入 Play 模式时处理的数据。此数据类型针对性能和存储效率进行了优化：专为计算机处理而设计。</p>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures@master/pictures/unity_dots_flow1.webp" alt="unity_dots_flow1"><br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures@master/pictures/unity_dots_flow2.webp" alt="unity_dots_flow2"></p>
<h3 id="烘焙过程"><a href="#烘焙过程" class="headerlink" title="烘焙过程"></a>烘焙过程</h3><p>烘焙仅发生在编辑器中，而不是在游戏中，就像资产导入一样。烘焙仅在编辑器中进行，因为每次需要时处理数据的 GameObject 表示及其烘焙代码需要大量时间和处理能力。此过程意味着如果 Unity 在游戏中执行烘焙，应用程序的性能将会降低。<br>每当创作场景中的创作数据发生变化时，就会触发烘焙过程。 Unity 如何烘焙数据取决于您是否将创作场景作为子场景打开。<br>如果相应的创作场景的子场景打开，则会触发实时烘焙。实时烘焙是指在您处理创作数据时，Unity 将创作数据烘焙到 ECS 数据中。根据 Unity 需要处理的创作数据量，它要么增量执行烘焙过程，要么执行数据的完整烘焙：</p>
<ul>
<li>完整烘焙（Full baking）：Unity 处理整个场景并对其进行烘焙。</li>
<li>增量烘焙（Incremental baking）：Unity只烘焙修改过的数据。<br>如果相应创作场景的子场景关闭，则 Unity 将在后台执行异步烘焙。它在创作场景中执行数据的完整烘焙。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures@master/pictures/unity_dots_baking1.webp" alt="unity_dots_baking1"><br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures@master/pictures/unity_dots_baking2.webp" alt="unity_dots_baking2"></p>
<h3 id="烘焙阶段"><a href="#烘焙阶段" class="headerlink" title="烘焙阶段"></a>烘焙阶段</h3><p>烘焙分成三个阶段：</p>
<ol>
<li>实体创建：在 Baker 运行之前，Unity 会为子场景中的每个创作游戏对象创建一个实体。在此阶段，除了一些内部元数据之外，实体没有任何组件。</li>
<li>烘焙器（Baker）阶段：Unity 创建实体后，它会运行烘焙器。每个烘焙器处理特定的创作组件类型，并且多个烘焙器可以使用相同的创作组件类型。Unity 的 ECS 提供了一些默认的烘焙器。比如用于渲染的渲染烘焙器、用于物理的刚体烘焙器等。</li>
<li>烘焙系统阶段：所有烘焙器运行完毕后，Unity 运行烘焙系统。烘焙系统是具有 BakingSystem 属性的 ECS 系统，用于指定它们只能在烘焙过程中运行。</li>
</ol>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>简单的烘培示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个 RotationSpeedAuthoring 类必须遵循 MonoBehaviour 约定</span></span><br><span class="line"><span class="comment">//并且应该保存在名为 RotationSpeedAuthoring.cs的文件中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RotationSpeedAuthoring</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> DegreesPerSecond;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> RotationSpeed : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> RadiansPerSecond;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleBaker</span> : <span class="title">Baker</span>&lt;<span class="title">RotationSpeedAuthoring</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Bake</span>(<span class="params">RotationSpeedAuthoring authoring</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> entity = GetEntity(TransformUsageFlags.Dynamic);</span><br><span class="line">        AddComponent(entity, <span class="keyword">new</span> RotationSpeed</span><br><span class="line">        &#123;</span><br><span class="line">            RadiansPerSecond = math.radians(authoring.DegreesPerSecond)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了保持增量烘焙工作，需要跟踪烘焙游戏对象时使用了哪些数据。 Unity 会自动跟踪创作组件中的任何字段，如果任何数据发生变化，面包师就会重新运行。<br>但是，Unity 不会自动跟踪其他来源的数据，例如创作组件或资产。你需要向烘焙器添加依赖项，以便它可以跟踪此类数据。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> DependentData : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Distance;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> VertexCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DependentDataAuthoring</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject Other;</span><br><span class="line">    <span class="keyword">public</span> Mesh Mesh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GetComponentBaker</span> : <span class="title">Baker</span>&lt;<span class="title">DependentDataAuthoring</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Bake</span>(<span class="params">DependentDataAuthoring authoring</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在任何提前退出之前，声明对外部引用的依赖。</span></span><br><span class="line">        <span class="comment">// 因为即使这些值为 null，它们仍然可能是对缺失对象的适当 Unity 引用。</span></span><br><span class="line">        <span class="comment">// 依赖项确保在恢复这些对象时将触发烘焙器。</span></span><br><span class="line"></span><br><span class="line">        DependsOn(authoring.Other);</span><br><span class="line">        DependsOn(authoring.Mesh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (authoring.Other == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (authoring.Mesh == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> transform = GetComponent&lt;Transform&gt;();</span><br><span class="line">        <span class="keyword">var</span> transformOther = GetComponent&lt;Transform&gt;(authoring.Other);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (transform == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (transformOther == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> entity = GetEntity(TransformUsageFlags.Dynamic);</span><br><span class="line">        AddComponent(entity, <span class="keyword">new</span> DependentData</span><br><span class="line">        &#123;</span><br><span class="line">            Distance = Vector3.Distance(transform.position, transformOther.position),</span><br><span class="line">            VertexCount = authoring.Mesh.vertexCount</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Subscene"><a href="#Subscene" class="headerlink" title="Subscene"></a>Subscene</h2><h3 id="为什么需要-Subscene"><a href="#为什么需要-Subscene" class="headerlink" title="为什么需要 Subscene ?"></a>为什么需要 Subscene ?</h3><p>由于某些项目包含大量数据，因此如果数据包含在一个创作场景中，Unity 编辑器可能很难处理所有数据。 ECS 可以有效地处理数百万个实体，但在其游戏对象表示中，它们可能会导致编辑器停止运行。因此，将创作数据放入几个较小的创作场景中会更有效。<br>这样有以下两点优势：</p>
<ol>
<li>便于多人协作。</li>
<li>方便全局预览，不会导致 Unity 编辑器卡死。</li>
</ol>
<h3 id="场景概览"><a href="#场景概览" class="headerlink" title="场景概览"></a>场景概览</h3><p>在实体组件系统（ECS）中，场景的工作方式有所不同。这是因为 Unity 的核心场景系统与 ECS 不兼容。在 ECS 中，场景被分成以下三种类型：</p>
<ol>
<li>创作场景（Authoring scenes）：创作场景是一种可以像任何其他场景一样打开和编辑的场景，但设计用于烘焙处理。它包含 Unity 在运行时将其转换为 ECS 数据的 GameObjects 和 MonoBehaviour 组件。</li>
<li>实体场景（Entity scenes）：实体场景包含烘焙过程产生的 ECS 数据。</li>
<li>子场景（Subscenes）：子场景是对创作或实体场景的引用。在 Unity 编辑器中，您创建一个子场景以添加创作元素。当子场景关闭时，会触发相关实体场景的烘焙过程。<br>子场景和实体场景经常相互混淆。但子场景只不过是一个附着点，用于方便地加载实体场景。<br>子场景是一个 GameObject 组件，允许将场景加载为其 GameObject 创作表示（以对其进行操作）或其 ECS 表示（只读，但高性能）。</li>
</ol>
<h3 id="子场景介绍"><a href="#子场景介绍" class="headerlink" title="子场景介绍"></a>子场景介绍</h3><p>实体组件系统 (ECS) 使用子场景而不是场景来管理应用程序的内容。这是因为 Unity 的核心场景系统与 ECS 不兼容。你可以将 GameObjects 和 MonoBehaviour 组件添加到子场景中，然后烘焙将 GameObjects 和 MonoBehaviour 组件转换为实体和 ECS 组件。还可以选择创建自己的烘培器以将 ECS 组件附加到转换后的实体。</p>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures@master/pictures/unity_subscence1.webp" alt="unity_subscence1"><br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures@master/pictures/unity_subscence2.webp" alt="unity_subscence2"><br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures@master/pictures/unity_subscence3.webp" alt="unity_subscence3"></p>
<p>当子场景打开时，会发生以下情况：</p>
<ul>
<li>在“层次结构”窗口中，Unity 显示具有 SubScene 组件的游戏对象下的子场景中的所有创作游戏对象。</li>
<li>场景视图根据首选项窗口的实体部分中的场景视图模式设置显示运行时数据（实体）或创作数据（游戏对象）。</li>
<li>初始烘焙过程在子场景中的所有创作组件上运行。</li>
<li>对创作组件所做的任何更改都会触发增量烘焙过程。<br>当子场景关闭时，Unity 会流式载入烘焙场景的内容。当您进入“播放”模式时，关闭的子场景中的实体需要几帧才能变得可用。在构建中，子场景的行为与编辑器中关闭的子场景相同，因此它们的实体不能立即可用。</li>
</ul>
<blockquote>
<p>注意：Unity 不会流式载入打开的子场景的内容。当您进入播放模式时，打开的子场景中的实体立即可用。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures@master/pictures/unity_dots_entity1.webp" alt="unity_dots_entity1"><br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures@master/pictures/unity_dots_entity2.webp" alt="unity_dots_entity2"></p>
<h3 id="场景的流式载入（Scene-streaming）"><a href="#场景的流式载入（Scene-streaming）" class="headerlink" title="场景的流式载入（Scene streaming）"></a>场景的流式载入（Scene streaming）</h3><p>加载大场景可能需要几帧。为了避免卡顿，实体中的所有场景加载都是异步的。这称为流式载入。<br>流式载入的主要优点是：</p>
<ul>
<li>当 Unity 在后台载入场景时，应用程序可以保持响应。</li>
<li>Unity 可以在大于内存容量的无缝世界中动态加载和卸载场景，而不会中断游戏玩法。</li>
<li>在播放模式下，如果实体场景文件丢失或过时，Unity 会按需转换场景。由于实体场景的烘焙和加载是异步发生的并且在单独的进程中，因此编辑器保持响应。<br>流式载入的主要缺点是：</li>
<li>应用程序不能假设场景数据存在，特别是在启动时。这可能会使您的代码变得更加复杂。</li>
<li>系统从场景系统组加载场景，场景系统组是初始化组的一部分。在该帧中更新较晚的系统会在同一帧中接收加载的数据，但早于该组更新的系统直到下一帧才会接收加载的数据。您的代码可能需要考虑到这一点。</li>
</ul>
<h3 id="加载场景"><a href="#加载场景" class="headerlink" title="加载场景"></a>加载场景</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Runtime component, SceneSystem uses EntitySceneReference to identify scenes.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> SceneLoader : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> EntitySceneReference SceneReference;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR// Authoring component, a SceneAsset can only be used in the Editor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneLoaderAuthoring</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> UnityEditor.SceneAsset Scene;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Baker</span> : <span class="title">Baker</span>&lt;<span class="title">SceneLoaderAuthoring</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Bake</span>(<span class="params">SceneLoaderAuthoring authoring</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> reference = <span class="keyword">new</span> EntitySceneReference(authoring.Scene);</span><br><span class="line">            <span class="keyword">var</span> entity = GetEntity(TransformUsageFlags.None);</span><br><span class="line">            AddComponent(entity, <span class="keyword">new</span> SceneLoader</span><br><span class="line">            &#123;</span><br><span class="line">                SceneReference = reference</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">[<span class="meta">RequireMatchingQueriesForUpdate</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">SceneLoaderSystem</span> : <span class="title">SystemBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> EntityQuery newRequests;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCreate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        newRequests = GetEntityQuery(<span class="keyword">typeof</span>(SceneLoader));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> requests = newRequests.ToComponentDataArray&lt;SceneLoader&gt;(Allocator.Temp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can&#x27;t use a foreach with a query as SceneSystem.LoadSceneAsync does structural changes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; requests.Length; i += <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            SceneSystem.LoadSceneAsync(World.Unmanaged, requests[i].SceneReference);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        requests.Dispose();</span><br><span class="line">        EntityManager.DestroyEntity(newRequests);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>EntitySceneReference</code> 来在烘焙过程中保留对场景的引用并在运行时加载它们。在调用 <code>SceneSystem.LoadSceneAsync</code> 期间，仅创建场景实体。 Unity 使用此实体在内部控制加载过程的其余部分。<br>在此调用期间不会加载场景头文件（scene header）、切片实体（section entities）及其内容，并且它们会在几帧后准备就绪。<br><code>SceneSystem.LoadSceneAsync</code> 会引起结构更改。这些结构变化阻止我们在 foreach 中使用查询调用此函数。</p>
<h4 id="卸载场景"><a href="#卸载场景" class="headerlink" title="卸载场景"></a>卸载场景</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> unloadParameters = SceneSystem.UnloadParameters.DestroyMetaEntities;</span><br><span class="line">SceneSystem.UnloadScene(World.Unmanaged, sceneEntity, unloadParameters);</span><br></pre></td></tr></table></figure>

<p>默认情况下， <code>SceneSystem.UnloadScene</code> 仅卸载切片（sections ）的内容，但保留场景和切片的元实体（meta entities）。如果稍后要再次加载场景，这非常有用，因为准备好这些元实体可以加快场景的加载速度。<br>要卸载内容并删除元实体， 调用 <code>SceneSystem.UnloadScene</code> 时请使用 <code>UnloadParameters.DestroyMetaEntities</code> 参数。</p>
<h4 id="场景切片（Scene-Section）"><a href="#场景切片（Scene-Section）" class="headerlink" title="场景切片（Scene Section）"></a>场景切片（Scene Section）</h4><p>Unity 将场景中的所有实体分组为切片，默认为切片 0。场景中的每个实体都有一个 SceneSection 共享组件，指示该实体属于哪个切片。SceneSection 包含场景的 GUID（Hash128 ）和切片编号（整数）。<br>切片索引不需要是连续的，但默认切片 0 始终存在，即使它是空的。例如，您可以有默认切片 0 和索引为 123 的切片。在编辑器中，场景切片仅在子场景关闭时应用。打开的子场景包含第 0 切片中的所有实体。<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures@master/pictures/unity_dots_section.webp" alt="unity_dots_section"></p>
<p>有两种方式可以将实体分配到指定的切片：</p>
<ol>
<li>使用创作组件 SceneSectionComponent 。此创作组件会影响其所在的创作游戏对象及其所有子对象（递归地）。</li>
<li>编写自定义烘焙系统来直接设置 SceneSection 值。你无法在 Baker 中为 SceneSection 分配值。</li>
</ol>
<h4 id="场景和切片的元实体"><a href="#场景和切片的元实体" class="headerlink" title="场景和切片的元实体"></a>场景和切片的元实体</h4><p>烘焙创作场景会生成实体场景文件。每个实体场景文件的标头包含：</p>
<ul>
<li>切片列表，其中包含文件名、文件大小和边界体积等数据。</li>
<li>AssetBundle 依赖项 (GUID) 列表。</li>
<li>可选的自定义元数据。<br>切片和 Bundles 的列表决定了 Unity 在加载场景时需要加载的文件列表。您可以选择将自定义元数据用于特定于游戏的目的。例如，您可以将 PVS（潜在可见集）信息存储为自定义元数据，以决定何时流式传输场景，或者可以存储某些条件以决定何时加载场景。<br>加载实体场景分两步进行：</li>
</ul>
<ol>
<li>解析阶段加载标头并为每个场景和每个切片创建一个元实体。</li>
<li>Unity 加载各切片的内容。</li>
</ol>
<h4 id="场景实例化"><a href="#场景实例化" class="headerlink" title="场景实例化"></a>场景实例化</h4><p>要实例化世界上某个位置的场景，可以执行以下操作：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> loadParameters = <span class="keyword">new</span> SceneSystem.LoadParameters()</span><br><span class="line">    &#123; Flags = SceneLoadFlags.NewInstance &#125;;</span><br><span class="line"><span class="keyword">var</span> sceneEntity = SceneSystem.LoadSceneAsync(state.WorldUnmanaged,</span><br><span class="line">    sceneReference, loadParameters);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ecb = <span class="keyword">new</span> EntityCommandBuffer(Allocator.Persistent,</span><br><span class="line">    PlaybackPolicy.MultiPlayback);</span><br><span class="line"><span class="keyword">var</span> postLoadEntity = ecb.CreateEntity();</span><br><span class="line"><span class="keyword">var</span> postLoadOffset = <span class="keyword">new</span> PostLoadOffset</span><br><span class="line">&#123;</span><br><span class="line">    Offset = sceneOffset</span><br><span class="line">&#125;;</span><br><span class="line">ecb.AddComponent(postLoadEntity, postLoadOffset);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> postLoadCommandBuffer = <span class="keyword">new</span> PostLoadCommandBuffer()</span><br><span class="line">&#123;</span><br><span class="line">    CommandBuffer = ecb</span><br><span class="line">&#125;;</span><br><span class="line">state.EntityManager.AddComponentData(sceneEntity, postLoadCommandBuffer);</span><br></pre></td></tr></table></figure>

<p>上面的代码使用名为 <code>PostLoadOffset</code> 的组件来存储要应用于实例的偏移量。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> PostLoadOffset : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> float3 Offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，使用自定义系统来应用变换：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">UpdateInGroup(typeof(ProcessAfterLoadGroup))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">struct</span> PostprocessSystem : ISystem</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> EntityQuery offsetQuery;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnCreate</span>(<span class="params"><span class="keyword">ref</span> SystemState state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        offsetQuery = <span class="keyword">new</span> EntityQueryBuilder(Allocator.Temp)</span><br><span class="line">            .WithAll&lt;PostLoadOffset&gt;()</span><br><span class="line">            .Build(<span class="keyword">ref</span> state);</span><br><span class="line">        state.RequireForUpdate(offsetQuery);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"><span class="keyword">ref</span> SystemState state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Query the instance information from the entity created in the EntityCommandBuffer.</span></span><br><span class="line">        <span class="keyword">var</span> offsets = offsetQuery.ToComponentDataArray&lt;PostLoadOffset&gt;(Allocator.Temp);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> offset <span class="keyword">in</span> offsets)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Use that information to apply the transforms to the entities in the instance.</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> transform <span class="keyword">in</span> SystemAPI.Query&lt;RefRW&lt;LocalTransform&gt;&gt;())</span><br><span class="line">            &#123;</span><br><span class="line">                transform.ValueRW.Position += offset.Offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        state.EntityManager.DestroyEntity(offsetQuery);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1VuaXR5LVRlY2hub2xvZ2llcy9FbnRpdHlDb21wb25lbnRTeXN0ZW1TYW1wbGVz">官方 ECS 案例 GitHub 仓库<i class="fa fa-external-link-alt"></i></span></li>
<li>官方文档翻译后的思维导图，如下：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures@master/pictures/unity-dots-mindmap.webp" alt="unity-dots-mindmap"></li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5lbnRpdGllc0AxLjAvbWFudWFsL2luZGV4Lmh0bWw=">Entities 1.0.14<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9sZWFybi51M2QuY24vdHV0b3JpYWwvZG90cy1ndWlkZT9jaGFwdGVySWQ9NjQyMTQ5N2QyYWNiNDcwMDIxYmM1YjUyIzY0MjE0ZDU5NzliNWEyMDAxZWQxZThjNA==">DOTS 指南<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvdW5pdHkzZC9jb252ZXJ0aW5nLXNjZW5lLWRhdGEtdG8tZG90cy11bml0ZS1jb3BlbmhhZ2VuLTIwMTk=">Converting Scene Data to DOTS<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zODI5MDIxNzA=">Unity DOTS编码实践：SubScene<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>DOTS</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity ECS 笔记</title>
    <url>/post/unity-ecs-note/</url>
    <content><![CDATA[<p>Unity ECS 提供了一种更好的游戏设计方法，使开发者专注于正在解决的实际问题：组成游戏的数据和行为。它利用 C＃Job System 和 Burst Compiler 使应用程序能够充分利用当今的多核处理器。从面向对象的设计转向面向数据的设计使开发者可以更轻松地重用代码，并使其他人更容易理解和处理代码。</p>
<h2 id="ECS-优点"><a href="#ECS-优点" class="headerlink" title="ECS 优点"></a>ECS 优点</h2><ul>
<li>编写极高性能的代码 (Extremely performant code)</li>
<li>更易于阅读的代码 (Easier to read)</li>
<li>更易于代码重用 (Easier to reuse code)</li>
<li>Burst 编译器 (Burst compiler)</li>
<li>C# 作业系统 (C# Job System )</li>
</ul>
<h2 id="ECS-基本概念"><a href="#ECS-基本概念" class="headerlink" title="ECS 基本概念"></a>ECS 基本概念</h2><ul>
<li>Entity 是实例,作为承载组件的载体,也是框架中维护对象的实体</li>
<li>Component 只包含数据,具备这个组件便具有这个功能</li>
<li>System 作为逻辑维护,维护对应的组件执行相关操作</li>
</ul>
<h2 id="ESC-的使用"><a href="#ESC-的使用" class="headerlink" title="ESC 的使用"></a>ESC 的使用</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using Unity.Entities;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">// Entity 实体：挂载 GameObjectEntity 组件的游戏对象。需要自定义结构体给 Entity 组装需要的 Component</span><br><span class="line">struct Components</span><br><span class="line">&#123;</span><br><span class="line">    public Transform transform;</span><br><span class="line">    public Rotator rotator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Component 数据：可以在Inspector窗口中编辑的旋转速度值</span><br><span class="line">[RequireComponent(typeof(GameObjectEntity))]</span><br><span class="line">class Rotator : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public float speed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// System 行为：继承自ComponentSystem来处理旋转操作</span><br><span class="line">class RotatorSystem : ComponentSystem</span><br><span class="line">&#123;</span><br><span class="line">    override protected void OnUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        foreach (var e in GetEntities&lt;Components&gt;())</span><br><span class="line">        &#123;</span><br><span class="line">            e.transform.rotation *= Quaternion.AngleAxis(e.rotator.speed * Time.deltaTime, Vector3.up);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Entity-Debugger"><a href="#Entity-Debugger" class="headerlink" title="Entity Debugger"></a>Entity Debugger</h3><p>Unity ECS 系统提供的一个可视化的调试 ECS 的工具，通过工具可以看到 Entity 数量和某个 Entity 所包含的 Component，以及对应的 System 的耗时。</p>
<h2 id="Job-System"><a href="#Job-System" class="headerlink" title="Job System"></a>Job System</h2><p>在 Unity 中，Unity API 必须在主线程中使用，无法在子线程调用。Job System 旨在让用户能更加容易地编写与 Unity API 交互的多线程代码。</p>
<h3 id="多线程的问题"><a href="#多线程的问题" class="headerlink" title="多线程的问题"></a>多线程的问题</h3><p>当创建的多线程数量超过 CPU 内核数量时，会导致线程相互争夺 CPU资源，从而导致频繁的上下文切换。而 CPU 执行上下文切换时，需要做大量工作来确保新线程的状态是正确的，这是相当耗费资源的，应尽可能避免。</p>
<h3 id="Job-System-概览"><a href="#Job-System-概览" class="headerlink" title="Job System 概览"></a>Job System 概览</h3><ul>
<li>数据和方法分离 (Separate data from function)</li>
<li>多核处理 (Multi-core processing)</li>
<li>节省多线程 (Save multi-threading)</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using Unity.Collections;</span><br><span class="line">using Unity.Jobs;</span><br><span class="line">using UnityEngine.Jobs;</span><br><span class="line"></span><br><span class="line">public class CubeAccelerationParallelFor : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    [SerializeField]</span><br><span class="line">    protected int m_ObjectCount = 10000;</span><br><span class="line"></span><br><span class="line">    [SerializeField]</span><br><span class="line">    protected float m_ObjectPlacementRadius = 100f;</span><br><span class="line"></span><br><span class="line">    protected GameObject[] m_Objects;</span><br><span class="line">    protected Transform[] m_Transforms;</span><br><span class="line"></span><br><span class="line">    public Vector3 m_Acceleration = new Vector3(0.0002f, 0.0001f, 0.0002f);</span><br><span class="line"></span><br><span class="line">    NativeArray&lt;Vector3&gt; m_Velocities;</span><br><span class="line">    TransformAccessArray m_TransformsAccessArray;</span><br><span class="line"></span><br><span class="line">    PositionUpdateJob m_Job;</span><br><span class="line">    AccelerationJob m_AccelJob;</span><br><span class="line"></span><br><span class="line">    JobHandle m_PositionJobHandle;</span><br><span class="line">    JobHandle m_AccelJobHandle;</span><br><span class="line"></span><br><span class="line">    void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Objects = new GameObject[m_ObjectCount];</span><br><span class="line">        m_Transforms = new Transform[m_ObjectCount];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Velocities = new NativeArray&lt;Vector3&gt;(m_ObjectCount, Allocator.Persistent);</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; m_ObjectCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            var cube = CreateCube();</span><br><span class="line">            cube.transform.position = Random.insideUnitSphere * m_ObjectPlacementRadius;</span><br><span class="line">            m_Objects[i] = cube;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m_ObjectCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            var obj = m_Objects[i];</span><br><span class="line">            m_Transforms[i] = obj.transform;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_TransformsAccessArray = new TransformAccessArray(m_Transforms);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct PositionUpdateJob : IJobParallelForTransform</span><br><span class="line">    &#123;</span><br><span class="line">        [ReadOnly]//通过将其声明为只读，允许多个作业并行访问数据</span><br><span class="line">        public NativeArray&lt;Vector3&gt; velocity;  // 通过 AccelerationJob 赋值</span><br><span class="line"></span><br><span class="line">        public float deltaTime;</span><br><span class="line"></span><br><span class="line">        public void Execute(int i, TransformAccess transform)</span><br><span class="line">        &#123;</span><br><span class="line">            transform.position += velocity[i] * deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct AccelerationJob : IJobParallelFor</span><br><span class="line">    &#123;</span><br><span class="line">        public NativeArray&lt;Vector3&gt; velocity;</span><br><span class="line"></span><br><span class="line">        public Vector3 acceleration;</span><br><span class="line"></span><br><span class="line">        public void Execute(int i)</span><br><span class="line">        &#123;</span><br><span class="line">            velocity[i] = i * acceleration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        m_AccelJob = new AccelerationJob()</span><br><span class="line">        &#123;</span><br><span class="line">            velocity = m_Velocities,</span><br><span class="line">            acceleration = m_Acceleration,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        m_Job = new PositionUpdateJob()</span><br><span class="line">        &#123;</span><br><span class="line">            deltaTime = Time.deltaTime,</span><br><span class="line">            velocity = m_Velocities,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //安排并行工作。第一个参数是每次迭代执行的次数,第二个参数是批量大小</span><br><span class="line">        m_AccelJobHandle = m_AccelJob.Schedule(m_ObjectCount, 64);</span><br><span class="line">        m_PositionJobHandle = m_Job.Schedule(m_TransformsAccessArray, m_AccelJobHandle);</span><br><span class="line"></span><br><span class="line">        m_PositionJobHandle.Complete();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void OnDestroy()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Velocities.Dispose();</span><br><span class="line">        m_TransformsAccessArray.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private GameObject CreateCube()</span><br><span class="line">    &#123;</span><br><span class="line">        var cube = GameObject.CreatePrimitive(PrimitiveType.Cube);</span><br><span class="line"></span><br><span class="line">        // 关闭阴影</span><br><span class="line">        var renderer = cube.GetComponent&lt;MeshRenderer&gt;();</span><br><span class="line">        renderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;</span><br><span class="line">        renderer.receiveShadows = false;</span><br><span class="line"></span><br><span class="line">        // 禁用 Collider</span><br><span class="line">        var collider = cube.GetComponent&lt;Collider&gt;();</span><br><span class="line">        collider.enabled = false;</span><br><span class="line"></span><br><span class="line">        return cube;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Burst"><a href="#Burst" class="headerlink" title="Burst"></a>Burst</h2><p>Burst 是一种新的基于 LLVM 的数学感知后端编译器。它将 C＃ 的 Job 编译为高度优化的机器代码，可以利用编译的平台的特定功能。Burst主要用于与Job系统高效协作。可以通过使用属性 [BurstCompile] 装饰 Job 结构,从而在代码中简单地使用 Burst 编译器 。</p>
<p>Burst是一个实验包，目前支持Unity 2018.3及更高版本，且目前还只是预览版。</p>
<p>更多介绍请参考：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1BhY2thZ2VzL2NvbS51bml0eS5idXJzdEAwLjIvbWFudWFsL2luZGV4Lmh0bWw=">https://docs.unity3d.com/Packages/com.unity.burst@0.2/manual/index.html<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>LLVM是一个自由软件项目，它是一种编译器基础设施，以C++写成，包含一系列模块化的编译器组件和工具链，用来开发编译器前端和后端。</p>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li>Unity 的官方示例库 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1VuaXR5LVRlY2hub2xvZ2llcy9FbnRpdHlDb21wb25lbnRTeXN0ZW1TYW1wbGVz">EntityComponentSystemSamples<i class="fa fa-external-link-alt"></i></span></li>
<li>Job System 示例库 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N0ZWxsYTNkL2pvYi1zeXN0ZW0tY29va2Jvb2s=">job-system-cookbook<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zb2Z0d2FyZS5pbnRlbC5jb20vZW4tdXMvYXJ0aWNsZXMvZ2V0LXN0YXJ0ZWQtd2l0aC10aGUtdW5pdHktZW50aXR5LWNvbXBvbmVudC1zeXN0ZW0tZWNzLWMtc2hhcnAtam9iLXN5c3RlbS1hbmQtYnVyc3QtY29tcGlsZXI=">Get Started with the Unity* Entity Component System (ECS), C# Job System, and Burst Compiler<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>ECS</tag>
        <tag>Burst</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Shader 学习笔记</title>
    <url>/post/unity-shader-notes/</url>
    <content><![CDATA[<h2 id="一些基础知识点介绍"><a href="#一些基础知识点介绍" class="headerlink" title="一些基础知识点介绍"></a>一些基础知识点介绍</h2><ol>
<li><p>数据类型</p>
<ul>
<li>double（双精度类型），一般64bit</li>
<li>float（浮点数类型），一般是32bit，如float2, float3, float4</li>
<li>half（半精度类型），一般是16bit。用于几何位置或纹理坐标。</li>
<li>fixed（定点数类型），一般是11bit。精度更低。一般用于颜色。</li>
<li>vec（向量值类型）, 如vec2, vec3, vec4</li>
</ul>
</li>
<li><p>常见方法</p>
<ul>
<li>tex2D(sampler2D, TEXCOORD0)</li>
<li>length(float2&#x2F;float3&#x2F;float4) 求向量模</li>
<li>atan -&gt; arctan</li>
<li>asin -&gt; arcsin</li>
<li>saturate(x)。如果x取值小于0，则返回值为0；如果x取值大于1，则返回值为1；若x在0到1之间，则直接返回x的值。</li>
<li>discard 丢弃片段。例如uv的x&#x2F;y坐标满足某个条件时丢弃对应的片段，那么这些丢弃的片段都不绘制了。但是discard是一条消耗比较大的指令，因为只要有个一包含discard指令的着色器，就可能会导致某些重要的优化失效，渲染可能会执行的更差，</li>
<li>step(a, x)。Returns (x &gt;&#x3D; a) ? 1 : 0</li>
</ul>
</li>
<li><p>常见结构体</p>
<ul>
<li>SurfaceOutput，表面着色器输出结构体 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct SurfaceOutput &#123;</span><br><span class="line">    half3 Albedo; //该像素的颜色值</span><br><span class="line">    half3 Normal; //该像素的法向量</span><br><span class="line">    half3 Emission; //该像素的辐射光，辐射光是最简单的一种光，它直接从物体发出并且不受任何光源影响</span><br><span class="line">    half Specular; //该像素的镜面高光</span><br><span class="line">    half Gloss; //该像素的光泽度</span><br><span class="line">    half Alpha; //该像素的透明度</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>Input，输入结构体。如果我们的shader很复杂并且需要知道像素的其他相关信息，我们就可以将以下变量包含在输入结构体中，以此来查询其他的相关变量。<ul>
<li>float3 viewDir – 视图方向( view direction)值。为了计算视差效果（Parallax effects），边缘光照（rim lighting）等，需要包含视图方向（view direction）值。</li>
<li>float4  with COLOR semantic（比如float4 currentColor，即用户自定义和颜色相关的变量名称） – 每个顶点（per-vertex）颜色的插值。</li>
<li>float4 screenPos – 为了反射效果，需要包含屏幕坐标系中的位置信息时包含此参数。</li>
<li>float3 worldPos – 世界坐标系中的位置。</li>
<li>float3 worldRefl – 表示世界坐标系中的反射向量(reflect vector)。如果表面着色器(surface shader) 不为SurfaceOutput结构中的Normal赋值，也就是说Normal不会发生变化，也就不需要重新求取worldRefl值了，那么就可以直接通过Input结构体传递该参数。</li>
<li>float3 worldNormal – 表示世界坐标系中的法线向量(normal vector)。如果表面着色器(surface shader) 不为SurfaceOutput结构中的Normal赋值，也就是说Normal不会发生变化，也就不需要重新求取worldNormal值了，那么就可以直接通过Input结构体传递该参数。</li>
</ul>
</li>
</ul>
</li>
<li><p>Properties常见语句</p>
<ul>
<li>float 例句：<code>_SomeValue(&quot;SomeValue&quot;, float) = 10</code></li>
<li>Color 例句：<code>_Color(&quot;Background Color&quot;, Color) = (1,1,1,1)</code></li>
<li>Texture 例句：<code>_MainTex(&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</code>。其中{option}，它只对2D，Rect或者Cube贴图有关，在写输入时我们最少要在贴图之后写一对什么都不含的空白的{}，当我们需要打开特定选项时可以把其写在这对花括号内。如果需要同时打开多个选项，可以使用空白分隔。可能的选择有ObjectLinear, EyeLinear, SphereMap, CubeReflect, CubeNormal中的一个，这些都是OpenGL中TexGen的模式。使用<code>[NoScaleOffset]</code>标签可以在检视窗口中隐藏纹理的 Tiling 和 Offset 两个参数选项。如<code>[NoScaleOffset]_MainTex(&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</code></li>
<li>Range 例句：<code>_SomeRange(&quot;SomeRange&quot;, Range(0.25, 0.5)) = 0.25</code></li>
<li>Vector 例句：<code>_SomeVector(&quot;SomeVector&quot;, Vector) = (1,1,1,1)</code></li>
<li>Rect 例句：</li>
<li>Cube 例句：</li>
</ul>
</li>
</ol>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9vbmV2Y2F0LmNvbS8yMDEzLzA3L3NoYWRlci10dXRvcmlhbC0x">https://onevcat.com/2013/07/shader-tutorial-1<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<ol start="6">
<li><p>Tags。</p>
<p> <code>Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;IgnoreProjector&quot;=&quot;True&quot; &quot;ForceNoShadowCasting&quot;=&quot;True&quot; &quot;Queue&quot;=&quot;Transparent&quot;&#125;</code></p>
<p> Tags的种类：</p>
<ul>
<li>RenderType 渲染类型。分为两种：<ul>
<li>Opaque 不透明</li>
<li>Transparent 透明</li>
</ul>
</li>
<li>IgnoreProjector 忽略Projector的影响。只有<code>&quot;True&quot;</code>和<code>&quot;False&quot;</code>两种值。</li>
<li>ForceNoShadowCasting 强制关闭阴影投射。只有<code>&quot;True&quot;</code>和<code>&quot;False&quot;</code>两种值。</li>
<li>Queue 指定渲染队列。将透明和不透明物体进行混合，如果渲染队列设置不正确则会导致不透明物体无法呈现在透明物体之后。预定义的Queue有:<ul>
<li>Background 最早被调用的渲染，用来渲染天空盒或者背景。</li>
<li>Geometry 这是默认值，用来渲染非透明物体（普通情况下，场景中的绝大多数物体应该是非透明的）。</li>
<li>AlphaTest 用来渲染经过Alpha Test的像素，单独为AlphaTest设定一个Queue是出于对效率的考虑。</li>
<li>Transparent 以从后往前的顺序渲染透明物体。</li>
<li>Overlay 用来渲染叠加的效果，是渲染的最后阶段（比如镜头光晕等特效）。<blockquote>
<p>这些预定义的值本质上是一组定义好的整数，Background &#x3D; 1000， Geometry &#x3D; 2000, AlphaTest &#x3D; 2450， Transparent &#x3D; 3000，最后Overlay &#x3D; 4000。<br> 在我们实际设置Queue值时，不仅能使用上面的几个预定义值，我们也可以指定自己的Queue值，写成类似这样：”Queue”&#x3D;”Transparent+100”，<br> 表示一个在Transparent之后100的Queue上进行调用。通过调整Queue值，我们可以确保某些物体一定在另一些物体之前或者之后渲染。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>LOD。它是 Level of Detail 的缩写，在这里例子里我们指定了其为200（其实这是 Unity 的内建 Diffuse 着色器的设定值）。这个数值决定了我们能用什么样的 Shader。在 Unity 的 Quality Settings中我们可以设定允许的最大 LOD，当设定的 LOD 小于 SubShader 所指定的 LOD 时，这个 SubShader 将不可用。Unity 内建 Shader 定义了一组 LOD 的数值，我们在实现自己的 Shader 的时候可以将其作为参考来设定自己的 LOD 数值，这样在之后调整根据设备图形性能来调整画质时可以进行比较精确的控制。</p>
</li>
</ol>
<ul>
<li>VertexLit 及其系列 &#x3D; 100</li>
<li>Decal, Reflective VertexLit &#x3D; 150</li>
<li>Diffuse &#x3D; 200</li>
<li>Diffuse Detail, Reflective Bumped Unlit, Reflective Bumped VertexLit &#x3D; 250</li>
<li>Bumped, Specular &#x3D; 300</li>
<li>Bumped Specular &#x3D; 400</li>
<li>Parallax &#x3D; 500</li>
<li>Parallax Specular &#x3D; 600</li>
</ul>
<h2 id="UnityCG"><a href="#UnityCG" class="headerlink" title="UnityCG"></a>UnityCG</h2><ol>
<li><p>Cg API文档：<span class="exturl" data-url="aHR0cDovL2h0dHAuZGV2ZWxvcGVyLm52aWRpYS5jb20vQ2cvaW5kZXhfc3RkbGliLmh0bWw=">http://http.developer.nvidia.com/Cg/index_stdlib.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>常量</p>
<ul>
<li><code>#define PI 3.141592653589</code></li>
<li><code>const float PI = 3.14159;//pi = 3.14159265358979323846264338327</code></li>
</ul>
</li>
<li><p>顶点输入参数的语义（semantic）：</p>
<ul>
<li>POSITION  位置</li>
<li>NORMAL    法向量</li>
<li>TEXCOORD0 纹理坐标</li>
<li>TANGENT   切向量</li>
<li>COLOR     颜色</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct vertexInput &#123;</span><br><span class="line">    float4 vertex : POSITION; // position (in object coordinates, i.e. local or model coordinates)</span><br><span class="line">    float4 tangent : TANGENT; // vector orthogonal to the surface normal</span><br><span class="line">    float3 normal : NORMAL; // surface normal vector (in object coordinates; usually normalized to unit length)</span><br><span class="line">    float4 texcoord : TEXCOORD0;  // 0th set of texture coordinates (a.k.a. “UV”; between 0 and 1) </span><br><span class="line">    float4 texcoord1 : TEXCOORD1; // 1st set of tex. coors. </span><br><span class="line">    float4 texcoord2 : TEXCOORD2; // 2nd set of tex. coors. </span><br><span class="line">    float4 texcoord3 : TEXCOORD3; // 3rd set of tex. coors. </span><br><span class="line">    fixed4 color : COLOR; // color (usually constant)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>Unity 在 UnityCG.cginc 中预定义的输入结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct appdata_base &#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">    float4 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line">struct appdata_tan &#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float4 tangent : TANGENT;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">    float4 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line">struct appdata_full &#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float4 tangent : TANGENT;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">    float4 texcoord : TEXCOORD0;</span><br><span class="line">    float4 texcoord1 : TEXCOORD1;</span><br><span class="line">    float4 texcoord2 : TEXCOORD2;</span><br><span class="line">    float4 texcoord3 : TEXCOORD3;</span><br><span class="line">    fixed4 color : COLOR;</span><br><span class="line">    // and additional texture coordinates only on XBOX360</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct appdata_img &#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    half2 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引入预定义结构体。如果要使用Unity预定义的一些结构体，则需要在着色器中使用<code>#include &quot;UnityCG.cginc&quot;</code>语句引入<code>UnityCG.cginc</code>文件。示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shader &quot;cginc&quot; &#123; </span><br><span class="line">   SubShader &#123; </span><br><span class="line">      Pass &#123; </span><br><span class="line">         CGPROGRAM </span><br><span class="line"> </span><br><span class="line">         #pragma vertex vert  </span><br><span class="line">         #pragma fragment frag </span><br><span class="line">         #include &quot;UnityCG.cginc&quot;</span><br><span class="line"> </span><br><span class="line">         struct vertexOutput &#123;</span><br><span class="line">            float4 pos : SV_POSITION;</span><br><span class="line">            float4 col : TEXCOORD0;</span><br><span class="line">         &#125;;</span><br><span class="line"> </span><br><span class="line">         vertexOutput vert(appdata_full input) </span><br><span class="line">         &#123;</span><br><span class="line">            vertexOutput output;</span><br><span class="line"> </span><br><span class="line">            output.pos =  mul(UNITY_MATRIX_MVP, input.vertex);</span><br><span class="line">            output.col = input.texcoord;</span><br><span class="line"></span><br><span class="line">            return output;</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         float4 frag(vertexOutput input) : COLOR </span><br><span class="line">         &#123;</span><br><span class="line">            return input.col; </span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         ENDCG  </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="数据和运算"><a href="#数据和运算" class="headerlink" title="数据和运算"></a>数据和运算</h2><ol>
<li><p>数据类型的精度</p>
<ul>
<li>float 精度最高，消耗最大</li>
<li>half  精度适中，消耗一般。可用于表示几何位置或纹理坐标</li>
<li>fixed 精度最低，消耗最小。常用于颜色</li>
</ul>
</li>
<li><p>Unity内置的uniform参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uniform float4 _Time, _SinTime, _CosTime; // time values</span><br><span class="line">uniform float4 _ProjectionParams; // x = 1 or -1 (-1 if projection is flipped) y = near plane; z = far plane; w = 1/far plane</span><br><span class="line">uniform float4 _ScreenParams; // x = width; y = height; z = 1 + 1/width; w = 1 + 1/height</span><br><span class="line">uniform float3 _WorldSpaceCameraPos;</span><br><span class="line">uniform float4x4 _Object2World; // model matrix</span><br><span class="line">uniform float4x4 _World2Object; // inverse model matrix </span><br><span class="line">uniform float4 _WorldSpaceLightPos0; // position or direction of light source for forward rendering</span><br><span class="line"></span><br><span class="line">uniform float4x4 UNITY_MATRIX_MVP; // model view projection matrix </span><br><span class="line">uniform float4x4 UNITY_MATRIX_MV; // model view matrix</span><br><span class="line">uniform float4x4 UNITY_MATRIX_V; // view matrix</span><br><span class="line">uniform float4x4 UNITY_MATRIX_P; // projection matrix</span><br><span class="line">uniform float4x4 UNITY_MATRIX_VP; // view projection matrix</span><br><span class="line">uniform float4x4 UNITY_MATRIX_T_MV; // transpose of model view matrix</span><br><span class="line">uniform float4x4 UNITY_MATRIX_IT_MV; // transpose of the inverse model view matrix</span><br><span class="line">uniform float4 UNITY_LIGHTMODEL_AMBIENT; // ambient color</span><br></pre></td></tr></table></figure>
</li>
<li><p>OpenGL着色语言中的变量类型限定符：</p>
</li>
</ol>
<ul>
<li>统一变量（uniform）<br>统一变量存储应用程序通过OpenGL ES 3.0 API（Unity中是通过C#）传入着色器的只读值，对于保存着色器所需要的所有数据类型（如变换矩阵、照明参数和颜色）都很有用。本质上，一个着色器的任何参数在所有顶点或者片段中都应该以统一变量的形式传入。在编译时已知值的变量应该是常量，而不是统一变量，这样可以提高效率。<br>统一变量在全局作用域中声明，只需要统一限定符。还需要注意的是，统一变量的命名空间在顶点着色器和片段着色器中都是共享的。统一变量通常保存在硬件中，这个区域被称作“常量存储”，是硬件中为存储常量值而分配的特殊空间。</li>
</ul>
<p>OpenGL ES2.0 的三种变量类型（uniform，attribute和varying）:<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamFja2VyczY3OS9hcnRpY2xlL2RldGFpbHMvNjg0ODA4NQ==">http://blog.csdn.net/jackers679/article/details/6848085<i class="fa fa-external-link-alt"></i></span></p>
<ol start="4">
<li><p>POSITION vs SV_POSITION<br>它们都是 CG&#x2F;HLSL 中的语义（semantics）。POSITION 将告诉 Unity 把模型的顶点坐标填充到输入参数 v 中，SV_POSITION 将告诉 Unity 顶点着色器的输出是剪裁空间中的顶点坐标。SV_ 前缀的变量代表 system value。</p>
</li>
<li><p>在Shader中+、-、*、&#x2F;都是两个操作数各对应分量的运算。矩阵和向量、矩阵和矩阵之间的乘法使用<code>mul</code>函数。向量的点乘和叉乘分别使用<code>dot</code>和<code>cross</code>函数。</p>
</li>
</ol>
<h2 id="编辑器辅助标签"><a href="#编辑器辅助标签" class="headerlink" title="编辑器辅助标签"></a>编辑器辅助标签</h2><ul>
<li><code>[Header(Color Ramp Sample)]</code>在检视窗口中添加一个标签文本。</li>
<li><code>[KeywordEnum(None, Top_Bottom, Left_Right, Custom_UV)] Stereo (&quot;Stereo Mode&quot;, Float) = 0</code>在检视窗口中添加一个弹出列表控件</li>
<li><code>[Toggle(STEREO_DEBUG)] _StereoDebug (&quot;Stereo Debug Tinting&quot;, Float) = 0</code>在检视窗口中添加一个Toggle控件</li>
<li>使用<code>[NoScaleOffset]</code>标签可以在检视窗口中隐藏纹理的 Tiling 和 Offset 两个参数选项。如<code>[NoScaleOffset]_MainTex(&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;</code></li>
</ul>
<h2 id="深度测试（ZTest）"><a href="#深度测试（ZTest）" class="headerlink" title="深度测试（ZTest）"></a>深度测试（ZTest）</h2><p>ZTest 可取值为：Greater , GEqual , Less , LEqual , Equal , NotEqual , Always , Never , Off，默认是 LEqual，ZTest Off 等同于 ZTest Always。ZWrite 可取值为：On , Off，默认是 On。系统中存在一个颜色缓冲区和一个深度缓冲区，分别存储颜色值和深度值，来决定画面上应该显示什么颜色。深度值是物体在世界空间中距离摄像机的远近。距离越近，深度值越小；距离越远，深度值越大。</p>
<h2 id="Tags-语句"><a href="#Tags-语句" class="headerlink" title="Tags 语句"></a>Tags 语句</h2><p>Tags 语句是用来给子着色器或通道分配一些键值对，用于控制渲染顺序、渲染类型、投影器效果等参数。例如，<code>Tags&#123; &quot;PreviewType&quot; = &quot;Plane&quot; &#125;</code>语句的含义如下：<br>    - PreviewType 标签是用来指示材质检视面板预览应如何显示材质。34<br>    - PreviewType &#x3D; “Plane” 的意思是，材质在检视面板中会显示为一个平面，而不是默认的球形。这个标签一般用于 UI 着色器，比如透明、粒子、字体等。</p>
<h2 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h2><p>Unity 使用 Blend 命令来设置混合的渲染状态，Blend 命令的参数是源因子和目标因子，它们分别表示片段着色器的输出值和渲染目标的原有值的乘数1。例如：<code>Blend SrcAlpha OneMinusSrcAlpha</code> 表示开启Alpha混合（即传统的透明度混合），并指定混合因子。其他混合命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Blend SrcAlpha OneMinusSrcAlpha // Traditional transparency</span><br><span class="line">Blend One OneMinusSrcAlpha // Premultiplied transparency</span><br><span class="line">Blend One One // Additive</span><br><span class="line">Blend OneMinusDstColor One // Soft Additive</span><br><span class="line">Blend DstColor Zero // Multiplicative</span><br><span class="line">Blend DstColor SrcColor // 2x Multiplicative</span><br></pre></td></tr></table></figure>

<p>颜色与颜色之间可以进行加减乘除进行混合运算。加法可以起到颜色叠加的效果，但是由于颜色值的值域为0~1，相加很容易达到1，颜色会愈发明亮，因此叠加建议使用乘法；减法可以进行反色处理，但是同样是值域的原因，数值达到0，颜色就很暗淡，因此要做反色建议使用除法。关于混合的更多内容请参考官方文档：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL2NuLzIwMTguMy9NYW51YWwvU0wtQmxlbmQuaHRtbA==">ShaderLab: Blending<i class="fa fa-external-link-alt"></i></span>。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</code> 等价于 <code>o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</code>。注意，在这两句代码的前面变量声明的部分要多声明一句<code>float4 _MainTex_ST;</code>。<code>TRANSFORM_TEX</code> 是 Unity 内置的宏，在 UnityCG.cginc 中定义的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Transforms 2D UV by scale/bias property</span><br><span class="line">#define TRANSFORM_TEX(tex, name)(tex.xy * name##_ST.xy + name##_ST.zw)</span><br></pre></td></tr></table></figure>

<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><ul>
<li>浅墨：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1FpYW5Nby9Bd2Vzb21lLVVuaXR5LVNoYWRlcg==">https://github.com/QianMo/Awesome-Unity-Shader<i class="fa fa-external-link-alt"></i></span></li>
<li>风宇冲：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnNpbmEuY29tLmNuL3MvYXJ0aWNsZWxpc3RfMTE5MjMwOTM5NF80XzEuaHRtbA==">https://blog.sina.com.cn/s/articlelist_1192309394_4_1.html<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5LmNuL2NuLzIwMTguMy9NYW51YWwvU0wtU3ViU2hhZGVyVGFncy5odG1s">ShaderLab：向子着色器分配标签<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zODk4OTIyODY=">Unity Shader 子着色器标签（SubShader Tags） - 知乎专栏<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NiYmJjL2FydGljbGUvZGV0YWlscy82OTM4NTY1Mw==">【Unity Shader】浅析Unity shader中RenderType的作用及_CameraDepthNormalsTexture …<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kNWNiZTQyYmNkOWE=">ShaderLab之SubShader - 简书<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>uGUI 的优化</title>
    <url>/post/unity-ugui-optimize/</url>
    <content><![CDATA[<h1 id="一、界面制作"><a href="#一、界面制作" class="headerlink" title="一、界面制作"></a>一、界面制作</h1><ol>
<li><p>在UI界面中，用Canvas还是用RectTransform做根节点更好？哪种方法效率更高？</p>
<blockquote>
<p>Canvas划分是个很大的话题。简单来说，因为一个Canvas下的所有UI元素都是合在一个Mesh中的，过大的Mesh在更新时开销很大，所以一般建议每个较复杂的UI界面，都自成一个Canvas(可以是子Canvas)，在UI界面很复杂时，甚至要划分更多的子Canvas。同时还要注意动态元素和静态元素的分离，因为动态元素会导致Canvas的mesh的更新。最后，Canvas又不能细分的太多，因为会导致Draw Call的上升。</p>
</blockquote>
</li>
<li><p>ScrollRect在滚动的时候，会产生Canvas.SendwillRenderCanvases，有办法消除吗？</p>
<blockquote>
<p>ScrollRect在滚动时，会产生OnTransformChanged的开销，这是UI元素在移动时触发的，但通常这不会触发Canvas.SendWillRenderCanvases。<br>如果观察到Canvas.SendWillRenderCanvases耗时较高，可以检查下ScrollRect所在的Canvas是否开启了Pixel Perfect的选项，该选项的开启会导致UI元素在发生位移时，其长宽会被进行微调（为了对其像素），而ScrollRect中通常有较多的UI元素，从而产生较高的Canvas.SendWillRenderCanvases开销。因此可以尝试关闭Pixel Perfect看效果是否可以接受，或者尝试在滚动过程中暂时关闭Pixel Perfect等方式来消除其开销。</p>
</blockquote>
</li>
</ol>
<h1 id="二、网格重建"><a href="#二、网格重建" class="headerlink" title="二、网格重建"></a>二、网格重建</h1><ol>
<li>我在UGUI里更改了Image的Color属性，那么Canvas是否会重建？我只想借用它的Color做Animation里的变化量。</li>
</ol>
<blockquote>
<p>如果修改的是Image组件上的Color属性，其原理是修改顶点色，因此是会引起网格的Rebuild的（即Canvas.BuildBatch操作，同时也会有Canvas.SendWillRenderCanvases的开销）。而通过修改顶点色来实现UI元素变色的好处在于，修改顶点色可以保证其材质不变，因此不会产生额外的Draw Call。</p>
</blockquote>
<ol start="2">
<li><p>Unity自带的UI Shader处理颜色时，改_Color属性不会触发顶点重建吗?</p>
<blockquote>
<p>在UI的默认Shader中存在一个Tint Color的变量，正常情况下，该值为常数(1,1,1)，且并不会被修改。如果是用脚本访问Image的Material，并修改其上的Tint Color属性时，对UI元素产生的网格信息并没有影响，因此就不会引起网格的Rebuild。但这样做因为修改了材质，所以会增加一个Draw Call。</p>
</blockquote>
</li>
<li><p>能否就UGUI Batch提出一些建议呢？是否有一些Batch的规则？</p>
<blockquote>
<p>在 UGUI 中，Batch是以Canvas为单位的，即在同一个Canvas下的UI元素最终都会被Batch到同一个Mesh中。而在Batch前，UGUI会根据这些UI元素的材质（通常就是Atlas）以及渲染顺序进行重排，在不改变渲染结果的前提下，尽可能将相同材质的UI元素合并在同一个SubMesh中，从而把DrawCall降到最低。而Batch的操作只会在UI元素发生变化时才进行，且合成的Mesh越大，操作的耗时也就越大。<br>因此，我们建议尽可能把频繁变化（位置，颜色，长宽等）的UI元素从复杂的Canvas中分离出来，从而避免复杂的Canvas频繁重建。</p>
</blockquote>
</li>
<li><p>动静分离或者多Canvas带来性能提升的理论基础是什么呢？如果静态部分不变动，整个Canvas就不刷新了？</p>
<blockquote>
<p>在UGUI中，网格的更新或重建（为了尽可能合并UI部分的DrawCall）是以Canvas为单位的，且只在其中的UI元素发生变动（位置、颜色等）时才会进行。因此，将动态UI元素与静态UI元素分离后，可以将动态UI元素的变化所引起的网格更新或重建所涉及到的范围变小，从而降低一定的开销。而静态UI元素所在的Canvas则不会出现网格更新和重建的开销。</p>
</blockquote>
</li>
<li><p>UWA建议“尽可能将静态UI元素和频繁变化的动态UI元素分开，存放于不同的Panel下。同时，对于不同频率的动态元素也建议存放于不同的Panel中。”那么请问，如果把特效放在Panel里面，需要把特效拆到动态的里面吗？</p>
<blockquote>
<p>通常特效是指粒子系统，而粒子系统的渲染和UI是独立的，仅能通过Render Order来改变两者的渲染顺序，而粒子系统的变化并不会引起UI部分的重建，因此特效的放置并没有特殊的要求。</p>
</blockquote>
</li>
<li><p>多人同屏的时候，人物移动会使得头顶上的名字Mesh重组，从而导致较为严重的卡顿，请问一下是否有优化的办法？</p>
<blockquote>
<p>如果是用UGUI开发的，当头顶文字数量较多时，确实很容易引起性能问题，可以考虑从以下几点入手进行优化：</p>
<ol>
<li>尽可能避免使用UI&#x2F;Effect，特别是Outline，会使得文本的Mesh增加4倍，导致UI重建开销明显增大；</li>
<li>拆分Canvas，将屏幕中所有的头顶文字进行分组，放在不同的Canvas下，一方面可以降低更新的频率（如果分组中没有文字移动，该组就不会重建），另一方面可以减小重建时涉及到的Mesh大小（重建是以Canvas为单位进行的）；</li>
<li>降低移动中的文字的更新频率，可以考虑在文字移动的距离超过一个阈值时才真正进行位移，从而可以从概率上降低Canvas更新的频率。</li>
</ol>
</blockquote>
</li>
</ol>
<h1 id="三、界面切换"><a href="#三、界面切换" class="headerlink" title="三、界面切换"></a>三、界面切换</h1><ol>
<li>游戏中出现UI界面重叠，该怎么处理较好？比如当前有一个全屏显示的UI界面，点其中一个按钮会再起一个全屏界面，并把第一个UI界面盖住。我现在的做法是把被覆盖的界面 SetActive(False)，但发现后续 SetActive(True) 的时候会有 GC.Alloc 产生。这种情况下，希望既降低 Batches 又降低 GC Alloc 的话，有什么推荐的方案吗？<blockquote>
<p>可以尝试通过添加一个 Layer 如 OutUI， 且在 Camera 的 Culling Mask 中将其取消勾选（即不渲染该 Layer）。从而在 UI 界面切换时，直接通过修改 Canvas 的 Layer 来实现“隐藏”。但需要注意事件的屏蔽，禁用动态的 UI 元素等等。<br>这种做法的优点在于切换时基本没有开销，也不会产生多余的 Draw Call，但缺点在于“隐藏时”依然还会有一定的持续开销（通常不太大），而其对应的 Mesh 也会始终存在于内存中（通常也不太大）。<br>以上的方式可供参考，而性能影响依旧是需要视具体情况而定。</p>
</blockquote>
</li>
</ol>
<h1 id="四、加载相关"><a href="#四、加载相关" class="headerlink" title="四、加载相关"></a>四、加载相关</h1><ol>
<li><p>加载UI预制的时候，如果把特效放到预制里，会导致加载非常耗时。怎么优化这个加载时间呢？</p>
<blockquote>
<p>UI和特效（粒子系统）的加载开销在多数项目中都占据较高的CPU耗时。UI界面的实例化和加载耗时主要由以下几个方面构成：</p>
<ol>
<li>纹理资源加载耗时<br>UI界面加载的主要耗时开销，因为在其资源加载过程中，时常伴有大量较大分辨率的Atlas纹理加载，我们在之前的Unity加载模块深度分析之纹理篇有详细讲解。对此，我们建议研发团队在美术质量允许的情况下，尽可能对UI纹理进行简化，从而加快UI界面的加载效率。</li>
<li>UI网格重建耗时<br>UI界面在实例化或Active时，往往会造成Canvas（UGUI）或Panel（NGUI）中UIDrawCall的变化，进而触发网格重建操作。当Canvas或Panel中网格量较大时，其重建开销也会随之较大。</li>
<li>UI相关构造函数和初始化操作开销<br>这部分是指UI底层类在实例化时的ctor开销，以及OnEnable和OnDisable的自身开销。</li>
</ol>
<p>上述2和3主要为引擎或插件的自身逻辑开销，因此，我们应该尽可能避免或降低这两个操作的发生频率。我们的建议如下：</p>
<ol>
<li>在内存允许的情况下，对于UI界面进行缓存。尽可能减少UI界面相关资源的重复加载以及相关类的重复初始化；</li>
<li>根据UI界面的使用频率，使用更为合适的切换方式。比如移进移出或使用Culling Layer来实现UI界面的切换效果等，从而降低UI界面的加载耗时，提升切换的流畅度。</li>
<li>对于特效（特别是粒子特效）来说，我们暂时并没有发现将UI界面和特效耦合在一起，其加载耗时会大于二者分别加载的耗时总和。因此，我们仅从优化粒子系统加载效率的角度来回答这个问题。粒子系统的加载开销，就目前来看，主要和其本身组件的反序列化耗时和加载数量相关。对于反序列化耗时而言，这是Unity引擎负责粒子系统的自身加载开销，开发者可以控制的空间并不大。对于加载数量，则是开发者需要密切关注的，因为在我们目前看到的项目中，不少都存在大量的粒子系统加载，有些项目的数量甚至超过1000个，如下图所示。因此，建议研发团队密切关注自身项目中粒子系统的数量使用情况。一般来说，建议我们建议粒子系统使用数量的峰值控制在400以下。</li>
</ol>
</blockquote>
</li>
<li><p>我有一个UI预设，它使用了一个图集， 我在打包的时候把图集和UI一起打成了AssetBundle。我在加载生成了GameObject后立刻卸载了AssetBundle对象， 但是当我后面再销毁GameObject的时候发现图集依然存在，这是什么情况呢？</p>
<blockquote>
<p>这是很可能出现的。unload(false)卸载AssetBundle并不会销毁其加载的资源 ，是必须对其调用Resources.UnloadAsset，或者调用Resources.UnloadUnusedAssets才行。关于AssetBundle加载的详细解释可以参考我们之前的文章：你应该知道的AssetBundle管理机制。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>性能优化</tag>
        <tag>uGUI</tag>
      </tags>
  </entry>
  <entry>
    <title>一步步学习 Unity Shader</title>
    <url>/post/unity-shader-step-by-step/</url>
    <content><![CDATA[<h2 id="Shaderlab"><a href="#Shaderlab" class="headerlink" title="Shaderlab"></a>Shaderlab</h2><h3 id="定义一个属性"><a href="#定义一个属性" class="headerlink" title="定义一个属性"></a>定义一个属性</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[var name]([Message], [Type]) = [Default value]</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_FloatVal(&quot;Float Value&quot;, float) = 0.0 // 浮点数</span><br><span class="line">_MainTex(&quot;Texture&quot;, 2D) = &quot;white&quot;&#123;&#125; // 纹理图片</span><br><span class="line">_RangeVal(&quot;Range value&quot;, Range(0.0, 10.0)) = 1.0 // 范围</span><br><span class="line">_Color(&quot;Color&quot;, Color) = (1.0, 1.0, 1.0, 1.0) // 颜色</span><br></pre></td></tr></table></figure>
<h3 id="子着色器（SubShader）"><a href="#子着色器（SubShader）" class="headerlink" title="子着色器（SubShader）"></a>子着色器（SubShader）</h3><p>可以创建多个子着色器，但 Unity 只会获取第一个可以运行在用户图形硬件上的着色器，所以可以编写多个版本的子着色器来兼容不同的硬件。每个子着色器可以有多个通道（Pass）。</p>
<ol>
<li>Pass 可以有如下命令：<ul>
<li><code>Cull off</code> 关闭背面剪裁</li>
<li><code>Blend SrcAlpha OneMinusSrcAlpha</code> 开启混合</li>
<li><code>ZWrite off</code> 关闭深度写入</li>
</ul>
</li>
<li>CG<br> 着色器代码包裹在 <code>CGPROGRAM</code> 和 <code>ENDCG</code> 两个关键词之间</li>
<li>FallBack<br> 如果编写的代码不能运行在当前的图形硬件上，系统就会自动将着色器切换到 FallBack 指定的着色器。例如： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FallBack &quot;Diffuse&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Vertex-and-fragment-shader-顶点和片段着色器"><a href="#Vertex-and-fragment-shader-顶点和片段着色器" class="headerlink" title="Vertex and fragment shader (顶点和片段着色器)"></a>Vertex and fragment shader (顶点和片段着色器)</h2><p>渲染管线（Rendering pipeline）：Vertex shader (顶点着色器) —&gt; Rasterizer (光栅化) —&gt; Fragment shader (片段着色器) —&gt; Framebuffer (帧缓冲)</p>
<h1 id="Annexes-附加"><a href="#Annexes-附加" class="headerlink" title="Annexes (附加)"></a>Annexes (附加)</h1><h2 id="Variables-in-CG-CG-中的变量"><a href="#Variables-in-CG-CG-中的变量" class="headerlink" title="Variables in CG (CG 中的变量)"></a>Variables in CG (CG 中的变量)</h2><ol>
<li><code>Sampler2D</code> 表示 2D 纹理</li>
<li><code>Bool</code> 表示布尔值</li>
<li><code>Float</code>、<code>Half</code>、<code>Fixed</code> 均表示浮点数</li>
<li><code>float2</code>、<code>float3</code>、<code>float4</code> 分别表示二维、三维、四维向量。向量的分量可以用下面三种形式表示：<ul>
<li>x, y, z, w</li>
<li>r, g, b, a</li>
<li>s, t, p, q</li>
</ul>
</li>
</ol>
<h2 id="Structures-结构体"><a href="#Structures-结构体" class="headerlink" title="Structures (结构体)"></a>Structures (结构体)</h2><p>一个结构体可以包含多个变量</p>
<h2 id="Functions-（方法）"><a href="#Functions-（方法）" class="headerlink" title="Functions （方法）"></a>Functions （方法）</h2><p>方法封装了一个任务</p>
<h2 id="Shader-Semantics-（Shader-语义）"><a href="#Shader-Semantics-（Shader-语义）" class="headerlink" title="Shader Semantics （Shader 语义）"></a>Shader Semantics （Shader 语义）</h2><p>语义表示了一个参数的目的。例如：<code>float4 vertex : POSITION;</code> 语句中的 <code>POSITION</code> 表示 <code>vertex</code> 变量用于一个位置。常见语义关键词有：</p>
<ul>
<li><code>POSITION</code> 位置</li>
<li><code>COLOR</code> 颜色</li>
<li><code>NORMAL</code> 法向量 </li>
<li><code>TANGENTE</code> 切向量 </li>
<li><code>TEXCOORD</code> 纹理坐标</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5zaGFkZXJzbGFiLmNvbS9zaGFkZXJzLmh0bWw=">http://www.shaderslab.com/shaders.html<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D MaterialPropertyBlock 的一个坑</title>
    <url>/post/unity_materialpropertyblock/</url>
    <content><![CDATA[<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>项目中有个预制体里面包含了 SpriteRender、Spine 的 MeshRenderer ，以及粒子系统特效。需求是要求游戏里的这个预制体对象在某一种状态下半透明。使用 <code>MaterialPropertyBlock</code> 修改预制体对象中的一个 Sprite 的材质颜色时，该对象直接变成了全白显示。</p>
<h2 id="产生问题的原因"><a href="#产生问题的原因" class="headerlink" title="产生问题的原因"></a>产生问题的原因</h2><p>Sprite 的着色器中的 <code>_Color</code> 属性使用了 <code>[PerRendererData]</code> 标签。因为 Unity 在内部使用 <code>MaterialPropertyBlock</code> 进行 Sprite 渲染，所以使用 <code>MaterialPropertyBlock</code> 发送一些 [PerRendererData] 时，必须首先使用 <code>Renderer.GetMaterialPropertyBlock</code> 获取默认的材质属性，然后在获取的 <code>MaterialPropertyBlock</code> 对象的基础上修改指定的某个属性，直接修改会覆盖掉 默认材质属性块的其他属性，如 <code>_MainTex</code> 等。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SetAlpha</span><span class="params">(alpha)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">self</span>._renderList == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">self</span>._matPropBlock == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">self</span>._matPropBlock = UnityEngine.MaterialPropertyBlock.New()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">self</span>._matPropBlock:Clear()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> __, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">self</span>._renderList) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> mat = v.sharedMaterial</span><br><span class="line">        <span class="keyword">if</span> v:HasPropertyBlock() <span class="keyword">then</span></span><br><span class="line">            v:GetPropertyBlock(<span class="built_in">self</span>._matPropBlock)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> mat:HasProperty(<span class="string">&quot;_Color&quot;</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> color = mat:GetColor(<span class="string">&quot;_Color&quot;</span>)</span><br><span class="line">            color.a = alpha</span><br><span class="line">            <span class="built_in">self</span>._matPropBlock:SetColor(<span class="string">&quot;_Color&quot;</span>, color)</span><br><span class="line">            v:SetPropertyBlock(<span class="built_in">self</span>._matPropBlock)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGlsZWk5MTEwL3AvNDUxNTMzMy5odG1s">Unity3D PerRendererData<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 VS Code 写 Shaderlab</title>
    <url>/post/vscode-shaderlab/</url>
    <content><![CDATA[<p>Unity3D 开发中，我们一般使用 VS 写代码，但是对于写 Shader，VS 还不如自带的 MonoDeveloper 强大，而且目前我还没有发现对 Shaderlab支持比较好的 VS 扩展插件。自从试用过 VS Code 后我把电脑上的 Sublime Text 给卸载了，换成了 VS Code 一直用到现在，而且越用越觉得强大，毕竟有微软这个爸爸，发展势头还是很猛的。言归正传，这篇博客打算记录一下我使用 VS Code 写 Shaderlab 的一些经验。</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>首先得安装 VS Code，这个是肯定的，没啥好说的。安装好 VS Code 后，在插件页搜索 ShaderlabVSCodeFree 扩展，然后安装重启。装好插件后，使用 VS Code 打开 Shaderlab 文件，就可以愉快的写 Shader 了。该插件支持<code>.shader</code>、<code>.cginc</code>、<code>.glslinc</code>、<code>.compute</code>四种格式的 Shaderlab 文件，同时，还支持语法高亮、基础代码补全、签名帮助 三大功能，基础代码补全这个功能用了一下感觉非常赞，要是再能支持自动格式化就完美了，不过对于免费版来说，已经非常良心了。该插件还有个收费的 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYXNzZXRzdG9yZS51bml0eTNkLmNvbS9lbi8jIS9jb250ZW50Lzk0NjUz">ShaderlabVSCode Beta<i class="fa fa-external-link-alt"></i></span> 版，支持的功能更多，也支持代码格式化，插件作者是中国的 Unity3D 开发者，所以，如果大家手头富裕的话，请支持一下作者，去AssetStore购买 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYXNzZXRzdG9yZS51bml0eTNkLmNvbS9lbi8jIS9jb250ZW50Lzk0NjUz">ShaderlabVSCode Beta<i class="fa fa-external-link-alt"></i></span> 版。</p>
<h2 id="添加代码片段"><a href="#添加代码片段" class="headerlink" title="添加代码片段"></a>添加代码片段</h2><p>为了写代码的方便，常用的 Shaderlab 代码块可以通过 File -&gt; Preferences -&gt; User Snippets 选项，然后找到 Shaderlab 语言，添加进 Json 配置文件，我放两个常用的代码片段：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	// Place your snippets for Shaderlab here. Each snippet is defined under a snippet name and has a prefix, body and </span></span><br><span class="line"><span class="comment">	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:</span></span><br><span class="line"><span class="comment">	// $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the </span></span><br><span class="line"><span class="comment">	// same ids are connected.</span></span><br><span class="line"><span class="comment">	// Example:</span></span><br><span class="line"><span class="comment">	&quot;Print to console&quot;: &#123;</span></span><br><span class="line"><span class="comment">		&quot;prefix&quot;: &quot;log&quot;,</span></span><br><span class="line"><span class="comment">		&quot;body&quot;: [</span></span><br><span class="line"><span class="comment">			&quot;console.log(&#x27;$1&#x27;);&quot;,</span></span><br><span class="line"><span class="comment">			&quot;$2&quot;</span></span><br><span class="line"><span class="comment">		],</span></span><br><span class="line"><span class="comment">		&quot;description&quot;: &quot;Log output to console&quot;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">	<span class="attr">&quot;Unity3D Shaderlab&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shaderlab&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;Shader \&quot;$&#123;1:New Shader&#125;\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;\tProperties&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;\t&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="string">&quot;\t\t_MainTex (\&quot;Texture\&quot;, 2D) = \&quot;white\&quot; &#123;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;\t&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;\tSubShader&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;\t&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="string">&quot;\t\tTags &#123; \&quot;RenderType\&quot;=\&quot;$&#123;2:Opaque&#125;\&quot; &#125;\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="string">&quot;\t\tPass&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="string">&quot;\t\t&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">					<span class="string">&quot;\t\t\t$3&quot;</span><span class="punctuation">,</span>	</span><br><span class="line">					<span class="string">&quot;\t\t&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;\t&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;&#125;&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Unity3D Shaderlab&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">	<span class="attr">&quot;CGPROGRAM&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cg&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">			<span class="string">&quot;CGPROGRAM&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;#pragma vertex vert&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;#pragma fragment frag\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;#include \&quot;UnityCG.cginc\&quot;\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;struct appdata&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;\tfloat4 vertex : POSITION;&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;\tfloat2 uv : TEXCOORD0;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;&#125;;\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;struct v2f&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;\tfloat2 uv : TEXCOORD0;&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;\tfloat4 vertex : SV_POSITION;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;&#125;;\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;sampler2D _MainTex;\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;v2f vert(appdata v)&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;\tv2f o;&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;\to.vertex = UnityObjectToClipPos(v.vertex);&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;\to.uv = TRANSFORM_TEX(v.uv, _MainTex);\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">			</span><br><span class="line">				<span class="string">&quot;\treturn o;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;&#125;\n&quot;</span><span class="punctuation">,</span></span><br><span class="line">			</span><br><span class="line">			<span class="string">&quot;fixed4 frag(v2f i) : SV_Target&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;\t// sample the texture&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;\tfixed4 col = tex2D(_MainTex, i.uv);&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;\treturn col;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="string">&quot;ENDCG&quot;</span></span><br><span class="line">		<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Unity3D Shaderlab CGPROGRAM&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>保存后，可以新建一个扩展名为 <code>.shader</code> 的文本文件，然后输入<code>shaderlab</code>后回车就会自动生成一个标准的 Shaderlab 结构代码块。输入<code>cg</code>后回车就会生成一段 CGPROGRAM 代码块，赶快试试吧！<br>刚开始使用VS Code 写 Shader 先放上两个代码片段，后期再增加其他代码片段。</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Shader</tag>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 系统的包管理器</title>
    <url>/post/windows-chocolatey-scoop/</url>
    <content><![CDATA[<p>自从在 Mac 下使用了 <span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vMjAxNy8wOC8yNi9tYWMtaG9tZWJyZXcv">Homebrew<i class="fa fa-external-link-alt"></i></span> + <span class="exturl" data-url="aHR0cHM6Ly9kYXZpZHNoZWguZ2l0aHViLmlvLzIwMTcvMDgvMjcvbWFjLWl0ZXJtMi8=">iTerm 2<i class="fa fa-external-link-alt"></i></span> + <span class="exturl" data-url="aHR0cHM6Ly9kYXZpZHNoZWguZ2l0aHViLmlvLzIwMTcvMDgvMjgvbWFjLWZpc2hzaGVsbC8=">Fish shell<i class="fa fa-external-link-alt"></i></span> 后，瞬间感觉世界清静了不少。然后就在想 Windows 下面有没有类似的软件呢？毕竟在工作中使用 Windows 还是比较多的，然后在网上还真搜到了。对应于 Mac 下的 <a href="%5Bhttp://davidsheh.github.io/2017/08/26/mac-homebrew/%5D(http://davidsheh.github.io/2017/08/26/mac-homebrew/)">Homebrew</a> + <span class="exturl" data-url="aHR0cHM6Ly9kYXZpZHNoZWguZ2l0aHViLmlvLzIwMTcvMDgvMjcvbWFjLWl0ZXJtMi8=">iTerm 2<i class="fa fa-external-link-alt"></i></span> + <span class="exturl" data-url="aHR0cHM6Ly9kYXZpZHNoZWguZ2l0aHViLmlvLzIwMTcvMDgvMjgvbWFjLWZpc2hzaGVsbC8=">Fish shell<i class="fa fa-external-link-alt"></i></span> ， Windows 下是 Chocolatey( + Scoop) + ConEmu + PowerShell。</p>
<h2 id="Chocolatey"><a href="#Chocolatey" class="headerlink" title="Chocolatey"></a>Chocolatey</h2><p>官网号称 Chocolatey 是在 Windows 上管理软件的明智方式，轻松管理 Windows 软件的各个方面（安装，配置，升级和卸载）。其他介绍请看官网：<span class="exturl" data-url="aHR0cHM6Ly9jaG9jb2xhdGV5Lm9yZy8lRTMlODAlODI=">https://chocolatey.org/。<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Chocolatey-安装"><a href="#Chocolatey-安装" class="headerlink" title="Chocolatey 安装"></a>Chocolatey 安装</h3><p>Chocolatey 的安装要求用户系统至少是 Windows 7 以上或者 Server 版本 2003 以上，PowerShell 至少是 v2 以上。还需要 <code>.NET Framework 4+</code>，不过在安装 Chocolatey 前会自动检查，如果没有就会自动安装。<br>Chocolatey 可以通过两种方式安装：使用 cmd.exe 来安装和使用 PowerShell.exe 来安装。安装的具体事项可以看官网的 <span class="exturl" data-url="aHR0cHM6Ly9jaG9jb2xhdGV5Lm9yZy9pbnN0YWxs">Install<i class="fa fa-external-link-alt"></i></span>。</p>
<h4 id="使用-cmd-exe-方式安装"><a href="#使用-cmd-exe-方式安装" class="headerlink" title="使用 cmd.exe 方式安装"></a>使用 cmd.exe 方式安装</h4><p>建议优先使用此方式安装，因为 cmd.exe 安装过程没有其他操作步骤。打开 CMD 命令行，然后输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@&quot;%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&#x27;https://chocolatey.org/install.ps1&#x27;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>如果安装失败，安装过程报错，报错信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Installation of Chocolatey to default folder requires Administrative permissions. Please run from elevated prompt.</span><br></pre></td></tr></table></figure>
<p>具体报错信息如下图：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/chocolatey_error.jpg"><br>上面这个错误产生的原因是因为没有以管理员身份启动 cmd.exe。如何以管理员身份启动 cmd.exe 请自行搜索，这里就不再啰嗦了。</p>
<h4 id="使用-PowerShell-exe-方式安装"><a href="#使用-PowerShell-exe-方式安装" class="headerlink" title="使用 PowerShell.exe 方式安装"></a>使用 PowerShell.exe 方式安装</h4><p>如果 cmd.exe 方式安装不成功再尝试这种方式， PowerShell.exe 安装过程会有安全性提示，要输入命令来确认。打开 PowerShell 命令行，然后输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy AllSigned; iex ((New-Object System.Net.WebClient).DownloadString(&#x27;https://chocolatey.org/install.ps1&#x27;))</span><br></pre></td></tr></table></figure>
<p>安装过程可能会有安全性提示，按照提示来操作就行了。</p>
<blockquote>
<p>使用<code>Win + R</code> 快捷键，接着输入<code>cmd</code>然后回车打开 CMD，输入 <code>powershell</code> 然后回车打开 PowerShell。如果安装报错，也有可能跟第一种安装方式一样是因为没有使用管理员身份运行 PowerShell 的原因。默认以管理员身份启动 PowerShell 的设置可以参考<span class="exturl" data-url="aHR0cDovL3d3dy5wc3RpcHMubmV0L3NldC1wb3dlcnNoZWxsLWljb24tbGF1bmNoLXRvLWRlZmF1bHQtdG8tcnVuLWFzLWFkbWluaXN0cmF0b3IuaHRtbA==">让PowerShell控制台默认以管理员启动<i class="fa fa-external-link-alt"></i></span> 。</p>
</blockquote>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">choco -h                       # 查看帮助</span><br><span class="line">choco &lt;command&gt; -h             #查看相应命令的帮助</span><br><span class="line">choco install &lt;package name&gt;   #安装软件包</span><br><span class="line">choco search &lt;keyword&gt;         #搜索软件包，会列出跟关键字相关的所有软件包</span><br><span class="line">choco upgrade &lt;package name&gt;   #升级软件包</span><br><span class="line">choco uninstall &lt;package name&gt; #卸载软件包</span><br><span class="line">choco list --local-only        #查看本地安装的软件包</span><br></pre></td></tr></table></figure>
<p>更多命令请参考 <span class="exturl" data-url="aHR0cHM6Ly9jaG9jb2xhdGV5Lm9yZy9kb2NzL2NvbW1hbmRzLXJlZmVyZW5jZSNob3ctdG8tcGFzcy1vcHRpb25zLS1zd2l0Y2hlcw==">Command Reference<i class="fa fa-external-link-alt"></i></span> </p>
<p><strong>注意：</strong><code>choco list</code> 命令查看的是所有软件包，包括本地已安装和远程存在的软件包，所以这个命令执行很耗时。一般我们查看的都是本地已安装的软件包，所以要加上 <code>--local-only</code> 参数，如果要查看远程的软件包，直接使用 <code>choco search</code> 搜索指定软件包。</p>
<h3 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">choco install googlechrome #安装 Chrome 浏览器</span><br><span class="line">choco install autohotkey.portable #安装 AutoHotKey</span><br><span class="line">choco install ccleaner #安装清理工具</span><br><span class="line">choco install visualstudiocode #安装 VS Code</span><br><span class="line">choco install conemu #安装ConEmu</span><br><span class="line">choco install sourcetree #安装SourceTree</span><br><span class="line">choco install winrar #安装压缩软件</span><br><span class="line">choco install android-sdk #安装 Android SDK</span><br><span class="line">choco install git #安装Git</span><br><span class="line">choco install jdk8 #安装jdk8</span><br><span class="line">choco install nodejs #安装Node.js</span><br><span class="line">choco install virtualbox #安装虚拟机</span><br><span class="line">choco install vim #安装 Vim</span><br><span class="line">choco install docker #安装Docker</span><br><span class="line">choco install wget #安装Wget</span><br><span class="line">choco install dropbox #安装 Dropbox</span><br><span class="line">choco install tortoisesvn #安装 TortoiseSVN</span><br></pre></td></tr></table></figure>
<p>你所能想到的 Windows 上常用的软件差不多都能找到，想要找什么软件，直接使用 <code>choco search &lt;keyword&gt;</code> 用关键字搜索，如果不知道自己想要啥软件或者记不起来要装啥软件，可以去官网的 <span class="exturl" data-url="aHR0cHM6Ly9jaG9jb2xhdGV5Lm9yZy9wYWNrYWdlcw==">Packages<i class="fa fa-external-link-alt"></i></span> 页下找找，几千个软件包，慢慢找去吧。</p>
<h2 id="Scoop"><a href="#Scoop" class="headerlink" title="Scoop"></a>Scoop</h2><p>Scoop 是 Windows 上的命令行安装程序，主要针对命令行下的开发者工具，和程序猿更配哦。个人的感觉是，Scoop 更像 Mac 上的 <span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vMjAxNy8wOC8yNi9tYWMtaG9tZWJyZXcv">Homebrew<i class="fa fa-external-link-alt"></i></span>， Chocolatey 更像 <span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vMjAxNy8wOC8yNi9tYWMtaG9tZWJyZXcv">Homebrew-Cask<i class="fa fa-external-link-alt"></i></span>。关于 Scoop 的更多介绍请看官网：<span class="exturl" data-url="aHR0cDovL3Njb29wLnNoLyVFRiVCQyU4QyVFNSU5MCU4QyVFNiU5NyVCNiVFRiVCQyU4Q1Njb29w">http://scoop.sh/，同时，Scoop<i class="fa fa-external-link-alt"></i></span> 是开源的项目，仓库地址<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x1a2VzYW1wc29uL3Njb29w">点这里<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="Scoop-安装"><a href="#Scoop-安装" class="headerlink" title="Scoop 安装"></a>Scoop 安装</h3><p>Scoop 的安装要求 Windows 上安装的 PowerShell 版本至少的 PowerShell 3，而且必须为你的用户帐户启用 PowerShell 。Windows 10 或 Windows Server 2012 应该默认安装的是 PowerShell 3，但 Windows 7 和Windows Server 2008 可能是比较老的版本。</p>
<h4 id="升级-PowerShell"><a href="#升级-PowerShell" class="headerlink" title="升级 PowerShell"></a>升级 PowerShell</h4><p>如果是 Windows 7 系统可能需要升级一下 PowerShell，有两种方式可以升级：一是直接下载 <span class="exturl" data-url="aHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS9lbi11cy9kb3dubG9hZC9kZXRhaWxzLmFzcHg/aWQ9MzQ1OTU=">PowerShell 3 的安装包<i class="fa fa-external-link-alt"></i></span>，二是通过 Chocolatey 升级。推荐使用第二种方式，下面重点介绍一下第二种方式的升级方法。<br>首先安装 Chocolatey ， 安装方法见上文。使用 <code>choco search powershell</code> 命令只搜索到 PowerShell 4 和 PowerShell 5。虽然在官网 <span class="exturl" data-url="aHR0cHM6Ly9jaG9jb2xhdGV5Lm9yZy9wYWNrYWdlcw==">Packages<i class="fa fa-external-link-alt"></i></span> 上搜索到了 <span class="exturl" data-url="aHR0cHM6Ly9jaG9jb2xhdGV5Lm9yZy9wYWNrYWdlcy9Qb3dlclNoZWxsLzMuMC4yMDEyMTAyNw==">PowerShell 3<i class="fa fa-external-link-alt"></i></span>，但是好像没通过审核，而且我强行安装失败，最后我直接安装的 PowerShell 5，在 PowerShell 命令行下输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">choco install powershell  #默认安装的最新版5.1</span><br></pre></td></tr></table></figure>
<p>安装过程需要同意，提示 <code>Do you want to run the script?([Y]es/[N]o/[P]rint):</code> 时，输入<code>y</code>就行了。</p>
<blockquote>
<p><strong>提示：</strong>可以使用 <code>Get-Host</code> 命令查看 PowerShell 版本，安装完后需要重启电脑，新版 PowerShell 才能生效。</p>
</blockquote>
<h4 id="开始安装-Scoop"><a href="#开始安装-Scoop" class="headerlink" title="开始安装 Scoop"></a>开始安装 Scoop</h4><p>安装 Scoop 前需要确保你已经允许 PowerShell 执行本地脚本，执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set-executionpolicy remotesigned -scope currentuser</span><br></pre></td></tr></table></figure>
<p>执行这个命令时可能会提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Do you want to change the execution policy?</span><br><span class="line">[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help (default is &quot;N&quot;): </span><br></pre></td></tr></table></figure>
<p>输入 <code>y</code> 或者 <code>a</code> 就可以了。接下来开始安装 Scoop，执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iex (new-object net.webclient).downloadstring(&#x27;https://get.scoop.sh&#x27;)</span><br></pre></td></tr></table></figure>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop help #查看帮助</span><br><span class="line">scoop install #安装 APP</span><br><span class="line">scoop uninstall #卸载 APP</span><br><span class="line">scoop list #列出已安装的 APP</span><br><span class="line">scoop search #搜索 APP</span><br><span class="line">scoop update #更新 APP 和 Scoop 自身</span><br></pre></td></tr></table></figure>
<p>其实只需要记住 <code>scoop help</code> 这一个命令就行了，其他命令忘记了直接通过这个命令查看就行了。</p>
<h3 id="常用软件-1"><a href="#常用软件-1" class="headerlink" title="常用软件"></a>常用软件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scoop install 7zip #安装压缩软件</span><br><span class="line">scoop install git  #安装Git</span><br><span class="line">scoop install openssh #安装OpenSSH</span><br><span class="line">scoop install concfg #安装控制台配置文件导入导出工具</span><br></pre></td></tr></table></figure>
<p>上面的四条命令可以合并成一个命令 <code>scoop install 7zip git openssh concfg</code>。支持的更多软件看这里：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x1a2VzYW1wc29uL3Njb29wL3RyZWUvbWFzdGVyL2J1Y2tldA==">https://github.com/lukesampson/scoop/tree/master/bucket<i class="fa fa-external-link-alt"></i></span> 。</p>
<h3 id="Scoop-的其他配置"><a href="#Scoop-的其他配置" class="headerlink" title="Scoop 的其他配置"></a>Scoop 的其他配置</h3><p><img src="https://github.com/lukesampson/scoop/raw/gh-pages/images/docs/shell-theme.png"><br>上图是 Scoop 官方给出的效果图，使用的是  <span class="exturl" data-url="aHR0cDovL2V0aGFuc2Nob29ub3Zlci5jb20vc29sYXJpemVk">Solarized<i class="fa fa-external-link-alt"></i></span> 主题。主题和字体的配置需要用到 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x1a2VzYW1wc29uL2NvbmNmZw==">concfg<i class="fa fa-external-link-alt"></i></span> 插件，<code>concfg</code> 插件是导入和导出 Windows 控制台配置（如字体和颜色）的一个工具。使用 <code>scoop install concfg</code> 命令来安装。<br>个人感觉 Scoop 最牛逼的地方在于 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x1a2VzYW1wc29uL3Njb29wL3dpa2kvQnVja2V0cw==">Buckets<i class="fa fa-external-link-alt"></i></span>，甚至是可以制作自己的 Buckets，可配置性更高了，由于篇幅的原因，这个以后有机会了再写吧。</p>
<h3 id="Scoop-VS-Chocolatey"><a href="#Scoop-VS-Chocolatey" class="headerlink" title="Scoop VS Chocolatey"></a>Scoop VS Chocolatey</h3><p>Scoop 和 Chocolatey 不同的地方在于下面几点：</p>
<ol>
<li>独立安装，和已有软件不冲突</li>
<li>没有权限对话框，因为程序安装到用户目录</li>
<li>不会污染路径</li>
<li>不使用 NuGet，无需担心依赖</li>
<li>不是软件包管理器，它仅读取一个关于如何安装程序的 JSON</li>
<li>不安装特定版本，仅仅支持最新版本</li>
<li><strong>专注于开发者的工具</strong></li>
</ol>
<p>更多请参考 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x1a2VzYW1wc29uL3Njb29wL3dpa2kvQ2hvY29sYXRleS1Db21wYXJpc29u">Chocolatey Comparison<i class="fa fa-external-link-alt"></i></span>。国外有人把 Windows 下主流的包管理工具做了一个对比，分别列出了各自的优缺点，还有很多人投票，网站链接： <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xhbnQuY28vaW1wcm92ZS90b3BpY3MvMTg0My9+d2luZG93cy1wYWNrYWdlLW1hbmFnZXJz">What are the best Windows package managers?<i class="fa fa-external-link-alt"></i></span>。</p>
<h2 id="一键装机"><a href="#一键装机" class="headerlink" title="一键装机"></a>一键装机</h2><p>当你在一台电脑上用 Chocolatey 和 Scoop（非程序员可以不装 Scoop） 配置过一次工作环境后，你只需要记住你所使用的软件包的名称，然后将所有的安装命令的清单云同步，那么当你换电脑了就可以很轻松的同步工作环境的配置，是不是非常酷，甚至是换工作时在新同事面前耍（装）帅（逼）。我的命令清单如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用 Chocolatey 安装</span><br><span class="line">choco install googlechrome #安装 Chrome 浏览器</span><br><span class="line">choco install unity #安装最新版 Unity3D 游戏引擎</span><br><span class="line">choco install visualstudiocode #安装 VS Code</span><br><span class="line">choco install sourcetree #安装SourceTree</span><br><span class="line"></span><br><span class="line">choco install autohotkey.portable #安装 AutoHotKey</span><br><span class="line">choco install conemu #安装ConEmu</span><br><span class="line"></span><br><span class="line">choco install jdk8 #安装jdk8</span><br><span class="line">choco install android-sdk #安装 Android SDK</span><br><span class="line"></span><br><span class="line">#使用 Scoop 安装</span><br><span class="line">scoop install concfg git #安装 concfg、git 等</span><br><span class="line">concfg import solarized small #导入 Solarized 主题</span><br><span class="line">scoop install pshazz #安装自定义提示和 具有Git&amp;SSH 特性的插件</span><br></pre></td></tr></table></figure>
<p>清单会持续更新，先就列这么多吧，以后再更新其他命令，欢迎关注 <span class="exturl" data-url="aHR0cHM6Ly9kYXZpZHNoZWguZ2l0aHViLmlvLw==">Sheh 伟伟的个人博客<i class="fa fa-external-link-alt"></i></span>。</p>
<hr>
<p><strong>同系列文章</strong></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC93aW5kb3dzLWNob2NvbGF0ZXktc2Nvb3Av">Windows 系统的包管理器<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Chocolatey</tag>
        <tag>Scoop</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL 使用记录</title>
    <url>/post/wsl-usage/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WSL 是 Windows Subsystem for Linux 的缩写。它是 Win10 系统下面的一个 Linux 子系统。</p>
<h2 id="安装和卸载-WSL环境"><a href="#安装和卸载-WSL环境" class="headerlink" title="安装和卸载 WSL环境"></a>安装和卸载 WSL环境</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在 Win10 上的 Microsoft Store 中搜索 Linux，就可以看到 WSL 所支持的 Linux 版本，找到想要安装的版本直接安装就可以了。目前，WSL支持 Ubuntu，Kali Linux，GNU，OpenSUSE 等，后续可能会有更多Linux发行版支持WSL。本文主要记录 Ubuntu 的使用过程。</p>
<h3 id="安装报错"><a href="#安装报错" class="headerlink" title="安装报错"></a>安装报错</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Installing, this may take a few minutes...</span><br><span class="line">WslRegisterDistribution failed with error: 0x8007019e</span><br><span class="line">The Windows Subsystem for Linux optional component is not enabled. Please enable it and try again.</span><br><span class="line">See https://aka.ms/wslinstall for details.</span><br><span class="line">Press any key to continue...</span><br></pre></td></tr></table></figure>
<p>报错原因是没有启用 WSL，解决办法在输出信息里，直接打开<span class="exturl" data-url="aHR0cHM6Ly9ha2EubXMvd3NsaW5zdGFsbA==">链接<i class="fa fa-external-link-alt"></i></span>，就可以看到解决办法。<strong>注意：</strong> 要用管理员方式打开 PowerShell。</p>
<h3 id="卸载和重装"><a href="#卸载和重装" class="headerlink" title="卸载和重装"></a>卸载和重装</h3><p>随便去试吧，如果你搞坏了你的 WSL 环境，它很容易重新安装。在进行之前，请确保做好了任何重要内容的备份。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:/&gt; lxrun.exe /uninstall /full</span><br><span class="line">C:/&gt; lxrun.exe /install</span><br></pre></td></tr></table></figure>

<h2 id="设置相关"><a href="#设置相关" class="headerlink" title="设置相关"></a>设置相关</h2><h3 id="访问-Windows-磁盘"><a href="#访问-Windows-磁盘" class="headerlink" title="访问 Windows 磁盘"></a>访问 Windows 磁盘</h3><p>WSL 将 Windows 系统的磁盘符都挂在到 <code>/mnt</code> 目录下了，所以如果想在 Ubuntu 中访问 Windows 系统的 C 盘，可以使用命令 <code>cd /mnt/c</code>。</p>
<h3 id="修改默认-Shell"><a href="#修改默认-Shell" class="headerlink" title="修改默认 Shell"></a>修改默认 Shell</h3><p>可以使用 <code>echo $SHELL</code> 命令查看当前正在使用的 Shell，使用 <code>which zsh</code> 可以查看安装的 <code>zsh</code> 路径，使用 <code>chsh -s /bin/zsh</code> 修改默认 Shell。</p>
<h3 id="使用-Fish-Shell"><a href="#使用-Fish-Shell" class="headerlink" title="使用 Fish Shell"></a>使用 Fish Shell</h3><ol>
<li>安装 <code>fish</code>：<code>apt-get install fish</code></li>
<li>设置默认 <code>shell</code> 为 <code>fish</code><ul>
<li>使用 <code>vim ~/.bashrc</code> 命令打开文件</li>
<li>在文件末尾添加一行 <code>fish</code> 命令</li>
</ul>
</li>
</ol>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol>
<li><code>cd /</code> 或 <code>cd ~</code> 回到根目录或回到 Home 目录</li>
<li><code>cd -</code> 回到前一个工作路径</li>
<li>在 Bash 中，可以按下 <code>Ctrl+W</code> 删除你键入的最后一个单词，<code>Ctrl+U</code> 可以删除行内光标所在位置之前的内容，<code>Alt+左/右</code> 可以以单词为单位移动光标，<code>Ctrl+A</code> 可以将光标移至行首，<code>Ctrl+E</code> 可以将光标移至行尾，<code>Ctrl+K</code> 可以删除光标至行尾的所有内容，<code>Ctrl+L</code> 可以清屏。</li>
<li><code>Ctrl+D</code> 一个特殊的二进制值，表示 EOF，作用相当于在终端中输入 <code>exit</code> 后回车；</li>
<li>Linux 中的三个终端控制键：<ol>
<li><code>Ctrl+C</code> 比较暴力，就是发送 Terminal 到当前的程序，比如你正在运行一个查找功能，文件正在查找中，Ctrl+C就会强制结束当前的这个进程。也可以取消命令执行，比如你已经输入了一长串命令了，这时突然不想执行这个命令了，就可以按下这个组合键取消。</li>
<li><code>Ctrl+Z</code> 是把当前的程序挂起，暂停执行这个程序，比如你正在 mysql 终端中，需要出来搞点其他的文件操作，又不想退出 mysql 终端（因为下次还得输入用户名密码进入，挺麻烦），于是可以 <code>Ctrl+Z</code> 将 mysql 挂起，然后进行其他操作，然后输入fg回车后就可以回来，当然可以挂起好多进程到后台，然后 <code>fg</code> 加编号就能把挂起的进程返回到前台。当然，配合 <code>bg</code> 和 <code>fg</code> 命令进行前后台切换会非常方便。</li>
<li><code>Ctrl+D</code> 是发送一个 exit 信号，没有那么强烈，类似<code>Ctrl+C</code> 的操作，比如你从管理员 root 退回到你的普通用户就可以这么用。</li>
</ol>
</li>
<li><code>Ctrl+R</code> 逆向搜索历史命令</li>
<li><code>Ctrl+P</code> 访问上一条命令</li>
<li><code>Ctrl+N</code> 访问下一条命令</li>
<li><code>!!</code> 执行上一条命令，<code>!foo</code> 执行以 foo 开头的命令</li>
<li><code>scp [localpath] [username]@[ip]</code></li>
</ol>
<h2 id="在命令行中高效移动"><a href="#在命令行中高效移动" class="headerlink" title="在命令行中高效移动"></a>在命令行中高效移动</h2><p><img src="https://clementc.github.io/figures/moving_cli.png" alt="Moving efficiently in the command line"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2lXYW5nSmlheGlhbmcvV1NMLUd1aWRlbGluZQ==">https://github.com/iWangJiaxiang/WSL-Guideline<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
        <tag>wsl</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>「C#高级编程」读书笔记</title>
    <url>/post/%E3%80%8CC_Sharp%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="1-C-类型的取值范围"><a href="#1-C-类型的取值范围" class="headerlink" title="1. C#类型的取值范围"></a>1. C#类型的取值范围</h3><p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/cs_value_range.jpg" alt="取值范围"></p>
<h3 id="2-访问限制符"><a href="#2-访问限制符" class="headerlink" title="2. 访问限制符"></a>2. 访问限制符</h3><table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="left">应用于</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="left">所有类型或成员</td>
<td align="left">任何代码均可以访问该项</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="left">类型和内嵌类型的所有成员</td>
<td align="left">只有派生的类型能够访问该项</td>
</tr>
<tr>
<td align="center">internal</td>
<td align="left">所有类型或成员</td>
<td align="left">只能在包含它的程序集中访问该项</td>
</tr>
<tr>
<td align="center">private</td>
<td align="left">类型和内嵌类型的所有成员</td>
<td align="left">只能在它所属的类型中访问该项</td>
</tr>
<tr>
<td align="center">protected internal</td>
<td align="left">类型和内嵌类型的所有成员</td>
<td align="left">只能在包含它的程序集和派生类型的任何代码中访问该项</td>
</tr>
</tbody></table>
<h3 id="3-C-常见的修饰符"><a href="#3-C-常见的修饰符" class="headerlink" title="3. C#常见的修饰符"></a>3. C#常见的修饰符</h3><table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="left">应用于</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">new</td>
<td align="left">函数成员</td>
<td align="left">成员用相同的签名隐藏继承的成员</td>
</tr>
<tr>
<td align="center">static</td>
<td align="left">所有成员</td>
<td align="left">成员不作用于类的具体实例</td>
</tr>
<tr>
<td align="center">virtual</td>
<td align="left">仅函数成员</td>
<td align="left">成员可以由派生类重写</td>
</tr>
<tr>
<td align="center">abstract</td>
<td align="left">仅函数成员</td>
<td align="left">虚拟成员定义了成员的签名，但没有提供实现代码</td>
</tr>
<tr>
<td align="center">override</td>
<td align="left">仅函数成员</td>
<td align="left">成员重写了继承的虚拟或抽象成员</td>
</tr>
<tr>
<td align="center">sealed</td>
<td align="left">类、方法和属性</td>
<td align="left">对于类，不能继承自密封类。对于属性和方法，成员重写已继承的虚拟成员，但任何派生类中的任何成员都不能重写该成员。该修饰符必须与override一起使用</td>
</tr>
<tr>
<td align="center">extern</td>
<td align="left">仅静态[DllImport]方法</td>
<td align="left">成员在外部用另一种语言实现</td>
</tr>
</tbody></table>
<h3 id="4-结构体"><a href="#4-结构体" class="headerlink" title="4. 结构体"></a>4. 结构体</h3><ul>
<li>结构是值类型，不是引用类型。</li>
<li>存储在栈中或存储为内联（inline）（如果它们是存储在堆中的另一个对象的一部分），其生存期的限制与简单的数据类型一样。</li>
<li>结构体不支持继承。</li>
<li>对于结构构造函数的工作方式有一些区别。尤其是编译器总是提供一个无参数的默认构造函数，它是不允许替换的。</li>
<li>使用结构，可以指定字段如何在内存中的布局。</li>
<li>注意，因为结构是值类型，所以<code>new</code>运算符与类和其他引用类型的工作方式不同。<code>new</code>运算符并不分配堆中的内存，而是只调用相应的构造函数，根据传送给它的参数初始化所有的字段。</li>
<li>结构遵循其他数据类型都遵循的规则：在使用前所有的元素都必须进行初始化。在结构上调用<code>new</code>运算符，或者给所有的字段分别赋值,结构就完全初始化了。当然,如果结构定义为类的成员字段,在初始化包含的对象时,该结构会自动初始化为0。</li>
<li>结构是会影响性能的值类型,但根据使用结构的方式,这种影响可能是正面的,也可能是负面的。正面的影响是为结构分配内存时,速度非常快,因为它们将内联或者保存在栈中。在结构超出了作用域被删除时,速度也很快。负面影响是,只要把结构作为参数来传递或者把一个结构赋予另一个结构（如A&#x3D;B,其 中A和B是结构),结构的所有内容就被复制,而对于类,则只复制引用。这样就会有性能损失,根据结构的大小,性能损失也不同。注意,结构主要用于小的数据结构。但当把结构作为参数传递给方法时,应把它作为ref参数传递,以避免性能损失————此时只传递了结构在内存中的地址,这样传递速度就与在类中的传递速度一样快了。但如果这样做,就必须注意被调用的方法可以改变结构的值。</li>
<li>结构不是为继承设计的。这意味着:它不能从一个结构中继承。唯一的例外是对应的结构(和C#中的其他类型一样)最终派生于类<code>System.Object</code>。因此,结构也可以访问<code>System.Object</code>的方法。在结构中,甚至可以重写<code>System.Object</code>中的方法————如重写<code>ToString()</code>方法。结构的继承链是:每个结构派生自<code>System.ValueType</code>类,<code>System.ValueType</code>类又派生自<code>System.Object</code>。<code>ValueType</code>并没有给<code>Object</code>添加任何新成员,但提供了一些更适合结构的实现方式。注意,不能为结构提供其他基类,每个结构都派生自<code>ValueType</code>。</li>
<li>为结构定义构造函数的方式与为类定义构造函数的方式相同,但 不允许定义无参数的构造函数。默认构造函数把数值字段都初始化为0,把引用类型字段初始化为<code>null</code>,且总是隐式地给出,即使提供了其他带参数的构造函数,也是如此。提供字段的初始值也不能绕过默认构造函数。</li>
</ul>
<h3 id="5-扩展方法"><a href="#5-扩展方法" class="headerlink" title="5. 扩展方法"></a>5. 扩展方法</h3><ul>
<li>扩展方法允许改变一个类，但不需要该类的源代码。所以使用扩展方法的情景之一是，当不知道类的源码或者不想修改该类的源码却想扩展该类，就可以用扩展方法。</li>
<li>扩展方法是静态方法，它是类的一部分，但实际上没有放在类的源代码中。</li>
<li>扩展方法需放在静态类中。</li>
<li>对于扩展方法，第一个参数是要扩展的类型，它放在<code>this</code>关键字的后面。</li>
<li>在扩展方法中，可以访问所扩展类型的所有共有方法和属性。</li>
<li>如果扩展方法与类中的某个方法同名，就从来不会调用扩展方法。类中已有的任何实例方法优先。</li>
</ul>
<h3 id="6-var关键字。"><a href="#6-var关键字。" class="headerlink" title="6. var关键字。"></a>6. <code>var</code>关键字。</h3><p>编译器可以根据变量的初始化值“推断 ” 变量的类型。使用var关键字需要遵循的一些规则：</p>
<ul>
<li>变量必须初始化。否则，编译器就没有推断变量类型的依据。</li>
<li>初始化器不能为空。</li>
<li>初始化器必须放在表达式中。</li>
<li>不能把初始化器设置为一个对象，除非在初始化器中创建了一个新对象。</li>
</ul>
<h3 id="7-密封类和密封方法"><a href="#7-密封类和密封方法" class="headerlink" title="7. 密封类和密封方法"></a>7. 密封类和密封方法</h3><ul>
<li>C#允许把类和方法声明为<code>sealed</code>。对于类，这表示不能继承该类；对于方法，这表示不能重写该方法。</li>
<li>在把类或方法标记为<code>sealed</code>时,最可能的情形是:如果要对库、类或自己编写的其他类作用域之外的类或方法进行操作,则重写某些功能会导致代码混乱。也可以因商业原因把类或方法标记为<code>sealed</code>,以防第三方以违反授权协议的方式扩展该类。但一般情况下,在把类或成员标记为<code>sealed</code>时要小心,因为这么做会严重限制它的使用方式。即使认为它不能对继承自一个类或重写类的某个成员发挥作用,仍有可能在将来的某个时刻,有人会遇到我们没有预料到的情形,此时这么做就很有用。.Net基类库大量使用了密封类 ,使希望从这些类中派生出自己的类的第三方开发人员无法访问这些类。例如,<code>string</code>就是一个密封类。</li>
</ul>
<h3 id="8-约束"><a href="#8-约束" class="headerlink" title="8. 约束"></a>8. 约束</h3><p>泛型支持的几种约束类型:</p>
<table>
<thead>
<tr>
<th align="center">约束</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">where T : struct</td>
<td align="left">对于结构约束，类型T必须是值类型</td>
</tr>
<tr>
<td align="center">where T : class</td>
<td align="left">类约束指定类型T必须是引用类型</td>
</tr>
<tr>
<td align="center">where T : IFoo</td>
<td align="left">指定类型T必须实现接口IFoo</td>
</tr>
<tr>
<td align="center">where T : Foo</td>
<td align="left">指定类型T必须派生自基类Foo</td>
</tr>
<tr>
<td align="center">where T : new()</td>
<td align="left">这是一个构造函数约束，指定类型T必须有一个默认构造函数</td>
</tr>
<tr>
<td align="center">where T1 : T2</td>
<td align="left">这个约束也可以指定类型T1派生自泛型类型T2。该约束也称为裸类型约束</td>
</tr>
</tbody></table>
<p>其他：</p>
<ul>
<li>只能为默认构造函数定义构造函数约束，不能为其他构造函数定义构造函数约束。</li>
<li>在C#中，<code>where</code>子句的一个重要限制是，不能定义必须由泛型类型实现的运算符。运算符不能再借口中定义。在<code>where</code>子句中，只能定义基类、接口和默认构造函数。</li>
</ul>
<h3 id="9-复制数组"><a href="#9-复制数组" class="headerlink" title="9. 复制数组"></a>9. 复制数组</h3><ul>
<li>如果数组的元素是值类型，调用Clone()方法就会复制所有值。如，int[] intArray1 &#x3D; {1, 2}; int[] intArray2 &#x3D; (int[])intArray1.Clone();其中intArray2数组的元素也变成了{1, 2}</li>
<li>如果数组包含引用类型，则不复制元素，而只复制引用。</li>
<li>除了使用Clone()方法之外，还可以使用Array.Copy()方法创建浅表副本。</li>
<li>Clone()方法和Copy()方法有一个重要区别：Clone()方法会创建一个新数组，而Copy()方法必须传递阶数相同且有足够元素的已有数组。</li>
<li>如果需要包含引用类型的数组的深层副本，就必须迭代数组并创建新对象。</li>
</ul>
<h3 id="10-Array类使用QuickSort算法对数组中的元素进行排序"><a href="#10-Array类使用QuickSort算法对数组中的元素进行排序" class="headerlink" title="10. Array类使用QuickSort算法对数组中的元素进行排序"></a>10. <code>Array</code>类使用<code>QuickSort</code>算法对数组中的元素进行排序</h3><p><code>Array</code>类中的Sort()方法需要数组中的元素实现<code>IComparable</code>接口。简单类型（如System.String和System.Int32）已经实现了IComparable接口。</p>
<h3 id="11-元组"><a href="#11-元组" class="headerlink" title="11. 元组"></a>11. 元组</h3><ul>
<li>数组合并了相同类型的对象，而元组合并了不同类型的对象。</li>
<li><code>.NET 4</code>定义了8个泛型<code>Tuple</code>类和一个静态<code>Tuple</code>类，不同泛型<code>Tuple</code>类支持不同数量的元素。例如，<code>Tuple&lt;T1&gt;</code>包含一个元素，<code>Tuple&lt;T1, T2&gt;</code>包含两个元素，以此类推。代码示例:<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TupleExample</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		TupleExample example = <span class="keyword">new</span> TupleExample();</span><br><span class="line">		<span class="keyword">var</span> result = example.Divide(<span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;result of division: &#123;0&#125;, reminder: &#123;1&#125;&quot;</span>, result.Item1, result.Item2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Tuple&lt; <span class="built_in">int</span>, <span class="built_in">int</span> &gt; Divide(<span class="built_in">int</span> dividend, <span class="built_in">int</span> divisor)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">int</span> result = dividend / divisor;</span><br><span class="line">		<span class="built_in">int</span> reminder = dividend % divisor;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> TupleExample.Create&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;(result, reminder);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果元组包含项超过8个，就可以使用带8个参数的Tuple类定义。最后一个模板参数是TRest,表示必须给它传递一个元组，这样就可以创建带任意个参数的元组了。示例：<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tuple = Tuple.Create&lt;<span class="built_in">string</span>, <span class="built_in">string</span>, <span class="built_in">string</span>, <span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">double</span>, Tuple&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;&gt;(<span class="string">&quot;Stephanie&quot;</span>, <span class="string">&quot;Alina&quot;</span>, <span class="string">&quot;Nagel&quot;</span>, <span class="number">2009</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1.37</span>, Tuple.Create&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;(<span class="number">52</span>, <span class="number">3490</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="12-运算符"><a href="#12-运算符" class="headerlink" title="12. 运算符"></a>12. 运算符</h3><ul>
<li><code>is</code>运算符：可以检查对象是否与特定的类型兼容。“兼容”表示对象是该类型或者派生自该类型。</li>
<li><code>as</code>运算符：用于执行引用类型的显示类型转换。如果要转换的类型与制定的类型兼容，转换就会成功进行；如果类型不兼容，<code>as</code>运算符就会返回<code>null</code>值。</li>
<li><code>sizeof</code>运算符：使用该运算符可以确定栈中值类型需要的长度（单位是字节）；如果对于复杂类型（和非基元类型）使用该运算符，就需要把代码写在<code>unsafe</code>块中，如：<code>unsafe&#123;Console.WriteLine(sizeof(Customer));&#125;</code></li>
<li>可空类型和运算符：通常可空类型与一元或二元运算符一起使用时，如果其中一个操作数或两个操作数都是<code>null</code>,其结果就是<code>null</code>。如：<br><code>int? a = null; int? b = a + 4; // b = null int? c = a * 5; // c = null</code></li>
<li>空合并运算符（??）：该运算符提供了一种快捷方式，可以在处理可空类型和引用类型时表示<code>null</code>可能的值。这个运算符放在两个操作数之间，第一个操作数必须是一个可空类型或者引用类型；第二个操作数必须与第一个操作数的类型相同，或者可以隐含地转换为第一个操作数的类型。</li>
</ul>
<h3 id="13-比较引用类型的相等性"><a href="#13-比较引用类型的相等性" class="headerlink" title="13. 比较引用类型的相等性"></a>13. 比较引用类型的相等性</h3><ul>
<li>ReferenceEquals()方法：该方法是一个静态方法，测试两个引用是否引用类的同一个实例，特别是两个引用是否包含内存中的相同地址。如果提供的两个引用引用同一个对象实例，则返回<code>true</code>，否则返回<code>false</code>。但是它认为<code>null</code>等于<code>null</code>。另外，该方法在应用于值类型时，它总是返回false，因为为了调用这个方法，值类型需要装箱到对象中。</li>
<li>Equals()虚方法：Equals()虚方法的<code>System.Object</code>实现代码也可以比较引用。但因为这个方法是虚拟的，所以可以在自己的类中重写它，从而按值来比较对象。<strong>特别是如果希望类的实例用作字典中的键，就需要重写这个方法，以比较相关值。</strong> 否则，根据重写<code>Object.GetHashCode()</code>的方式，包含对象的字典类要么不工作，要么工作的效率非常低。在重写Equals()方法时要注意，重写的代码不会抛出异常。同理，这是因为如果抛出异常，字典类就会出问题，一些在内部调用这个方法的<code>.NET</code>基类也可能出问题。</li>
<li>静态的Equals()方法：Equals()的静态版本与其虚拟实例版本的作用相同，其区别是静态版本带有两个参数，并对它们进行相等比较。这个方法可以处理两个对象中有一个是<code>null</code>的情况，因此，如果一个对象可能是<code>null</code>，这个方法就可以抛出异常，提供额外保护。静态重载版本首先要检查它传递的引用是否为<code>null</code>。如果他们都是<code>null</code>，就返回<code>true</code>(因为<code>null</code>与<code>null</code>相等)。如果只有一个引用是<code>null</code>，就返回<code>false</code>。如果两个引用实际上引用了某个对象，它就调用Equals()的虚拟实例版本。这表示在重写Equals()的实例版本时，其效果相当于也重写了静态版本。</li>
<li>比较运算符（&#x3D;&#x3D;）：最好将比较运算符看作严格的值比较和严格的引用比较之间的中间选项。在大多数情况下，下面的代码表示正在比较引用：<code>bool b = (x == y);// x, y object references</code></li>
</ul>
<h3 id="14-运算符重载"><a href="#14-运算符重载" class="headerlink" title="14. 运算符重载"></a>14. 运算符重载</h3><ul>
<li>运算符重载的声明方式与方法相同，但<code>operator</code>关键字告诉编译器，它实际上是一个自定义的运算符重载，后面是相关运算符的实际符号，返回类型是在使用这个运算符时获得的类型。</li>
<li>对于二元运算符（它带两个参数），如<code>+</code>和<code>-</code>运算符，第一个参数是运算符左边的值，第二个参数是运算符右边的值。</li>
<li>一般把运算符左边的参数命名为<code>lhs</code>，运算符右边的参数命名为<code>rhs</code>。</li>
<li>C#要求所有的运算符重载都声明为<code>public</code>和<code>static</code>，这表示它们与它们的类或结构相关联，而不是与某个特定实例相关联，所以运算符重载的代码体不能访问非静态类成员，也不能访问<code>this</code>标识符。</li>
<li>C#语言要求成对重载比较运算符。即，如果重载了<code>==</code>,也就必须重载<code>!=</code>；否则会产生编译错误。另外，比较运算符必须返回布尔类型的值。这是它们与算术运算符的根本区别。</li>
<li>在重载<code>==</code>和<code>!=</code>时，还必须重载从<code>System.Object</code>中继承的Equals()和GetHashCode()方法，否则会产生一个编译警告。原因是Equals()方法应实现与<code>==</code>运算符相同类型的相等逻辑。</li>
</ul>
<h3 id="15-委托"><a href="#15-委托" class="headerlink" title="15. 委托"></a>15. 委托</h3><ul>
<li>理解委托的一个要点是它们的类型安全性非常高。</li>
<li>理解委托的一种好方式是把委托当作这样一件事，它给方法的签名和返回类型指定名称。</li>
<li><code>Action</code><ul>
<li><code>Action</code>是无返回值的泛型委托。</li>
<li><code>Action</code>表示无参，无返回值的委托</li>
<li><code>Action&lt;int,string&gt;</code>表示有传入参数<code>int</code>,<code>string</code>无返回值的委托</li>
<li><code>Action&lt;int,string,bool&gt;</code>表示有传入参数<code>int</code>,<code>string</code>,<code>bool</code>无返回值的委托</li>
<li><code>Action&lt;int,int,int,int&gt;</code>表示有传入4个<code>int</code>型参数，无返回值的委托</li>
<li><code>Action</code>至少0个参数，至多16个参数，无返回值。</li>
</ul>
</li>
<li><code>Func</code><ul>
<li><code>Func</code>是有返回值的泛型委托</li>
<li><code>Func&lt;int&gt;</code>表示无参，返回值为int的委托</li>
<li><code>Func&lt;object,string,int&gt;</code>表示传入参数为<code>object</code>, <code>string</code>返回值为int的委托</li>
<li><code>Func&lt;object,string,int&gt;</code>表示传入参数为<code>object</code>, <code>string</code>返回值为int的委托</li>
<li><code>Func&lt;T1,T2,,T3,int&gt;</code>表示传入参数为<code>T1</code>,<code>T2</code>,<code>T3</code>(泛型)返回值为<code>int</code>的委托</li>
<li><code>Func</code>至少0个参数，至多16个参数，根据返回值泛型返回。必须有返回值，不可<code>void</code></li>
</ul>
</li>
</ul>
<h3 id="16-Lambda表达式"><a href="#16-Lambda表达式" class="headerlink" title="16. Lambda表达式"></a>16. <code>Lambda</code>表达式</h3><ul>
<li>只要有委托参数类型的地方，就可以使用<code>Lambda</code>表达式。或者说<code>Lambda</code>表达式可以用于类型是一个委托的任意地方。</li>
<li>如果只有一个参数，只写出参数名就足够了。如果委托使用多个参数，就把参数名放在小括号中。为了方便可以在小括号中给变量添加参数类型。</li>
<li>如果<code>Lambda</code>表达式只有一条语句，在方法块内就不需要花括号和<code>return</code>语句，因为编译器会添加一条隐式<code>return</code>语句。</li>
</ul>
<h3 id="17-正则表达式"><a href="#17-正则表达式" class="headerlink" title="17. 正则表达式"></a>17. 正则表达式</h3><p>常用的特定字符和转义序列如下表：</p>
<table>
<thead>
<tr>
<th align="center">符 号</th>
<th align="left">含 义</th>
<th align="center">示 例</th>
<th align="left">匹配的示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">^</td>
<td align="left">输入文本的开头</td>
<td align="center">^B</td>
<td align="left">B,但只能是文本中的第一个字符</td>
</tr>
<tr>
<td align="center">$</td>
<td align="left">输入文本的结尾</td>
<td align="center">X$</td>
<td align="left">X,但只能是文本中的最后一个字符</td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">除了换行符（\n）以外的所有单个字符</td>
<td align="center">i.ation</td>
<td align="left">isation、ization</td>
</tr>
<tr>
<td align="center">*</td>
<td align="left">可以重复0次或多次的前导字符</td>
<td align="center">ra*t</td>
<td align="left">rt、rat、raat和raaat等</td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">可以重复1次或多次的前导字符</td>
<td align="center">ra+t</td>
<td align="left">rat、raat和raaat等（但不能是rt）</td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">可以重复0次或1次的前导字符</td>
<td align="center">ra?t</td>
<td align="left">只有rt和rat匹配</td>
</tr>
<tr>
<td align="center">s</td>
<td align="left">任何空白字符</td>
<td align="center">\sa</td>
<td align="left">[space]a、\ta、\na（其中[space]表示空格，\t和\n都是转移字符）</td>
</tr>
<tr>
<td align="center">S</td>
<td align="left">任何不是空白的字符</td>
<td align="center">\SF</td>
<td align="left">aF、rF、cF，但不能是\tF</td>
</tr>
<tr>
<td align="center">b</td>
<td align="left">字边界</td>
<td align="center">ion\b</td>
<td align="left">以ion结尾的任何字</td>
</tr>
<tr>
<td align="center">B</td>
<td align="left">不是字边界的任意位置</td>
<td align="center">\BX\B</td>
<td align="left">字中间的任何X</td>
</tr>
</tbody></table>
<p>可以把替换的字符放在方括号中，请求匹配包含这些字符。例如，<code>[1|c]</code>表示字符可以是<code>1</code>或<code>c</code>。在方括号中，也可以指定一个范围，例如<code>[a-z]</code>表示所有的小写字母，<code>[A-E]</code>表示<code>A</code>~&#96;E<code>之间的所有大写字母（包括字母</code>A<code>和</code>E<code>），</code>[0-9]<code>表示一个数字。如果要搜索一个整数，就可以编写</code>[0-9]+&#96;。</p>
<h3 id="18-集合"><a href="#18-集合" class="headerlink" title="18. 集合"></a>18. 集合</h3><ul>
<li>链表。<code>LinkedList&lt;T&gt;</code>是一个双向链表，其元素指向它前面和后面的元素。其特点是：插入快，查找慢。</li>
<li>有序列表。如果需要基于键对所需集合排序，就可以使用<code>SortedList&lt;TKey,TValue&gt;</code>类，这个类按照键给元素排序。</li>
<li>字典。<ul>
<li>字典的主要特征是能根据键快速查找值。也可以自由添加和删除元素，这点有点像<code>List&lt;T&gt;</code>类，但没有在内存中移动后续元素的性能开销。</li>
<li>用作字典中键的类型必须重写Object类的GetHashCode()方法。只要字典类需要确定元素的位置，它就要调用GetHashCode()方法。GetHashCode()方法返回的<code>int</code>由字典用于计算在对应位置放置元素的索引。</li>
<li>字典的性能取决于GetHashCode()方法的实现代码。</li>
<li>除了实现GetHashCode()方法之外，键类型还必须实现<code>IEquatable&lt;T&gt;.Equals()</code>方法，或重写<code>Object</code>类的Equals()方法。因为不同的键对象可能返回相同的散列代码，所以字典使用Equals()方法来比较键。</li>
</ul>
</li>
</ul>
<h3 id="19-GetHashCode-方法的实现代码必须满足如下要求："><a href="#19-GetHashCode-方法的实现代码必须满足如下要求：" class="headerlink" title="19. GetHashCode()方法的实现代码必须满足如下要求："></a>19. GetHashCode()方法的实现代码必须满足如下要求：</h3><ul>
<li>相同的对象应总是返回相同的值。</li>
<li>不同的对象可以返回相同的值。</li>
<li>它应执行得比较快，计算的开销不大。</li>
<li>它不能抛出异常。</li>
<li>它应至少使用一个实例字段。</li>
<li>散列代码值应平均分布在<code>int</code>可以存储的整个数字范围上。</li>
<li>散列代码最好在对象的生存期中不发生变化。</li>
</ul>
<h3 id="20-Equal-方法重写"><a href="#20-Equal-方法重写" class="headerlink" title="20. Equal()方法重写"></a>20. Equal()方法重写</h3><p>如果为Equals()方法提供了重写版本，但没有提供GetHashCode()方法的重写版本，C#编译器就会显示一个编译警告。</p>
<h3 id="21-LINQ"><a href="#21-LINQ" class="headerlink" title="21. LINQ"></a>21. <code>LINQ</code></h3><ul>
<li>查询表达式必须以<code>from</code>子句开头，以<code>select</code>或<code>group</code>子句结束。在这两个子句之间，可以使用<code>where</code>、<code>orderby</code>、<code>join</code>、<code>let</code>和其他<code>from</code>子句。</li>
<li><code>LINQ</code>为<code>IEnumerable&lt;T&gt;</code>接口提供了各种扩展方法，以便用户在实现了该接口的任意集合上使用<code>LINQ</code>查询。</li>
</ul>
<h3 id="22-释放非托管的资源"><a href="#22-释放非托管的资源" class="headerlink" title="22. 释放非托管的资源"></a>22. 释放非托管的资源</h3><ul>
<li>在定义一个类时，可以使用两种机制来自动释放非托管的资源。这些机制常常放在一起实现，因为每种机制都为问题提供了略微不同的解决办法。</li>
<li>释放非托管资源的两种机制：声明一个析构函数（或终结器）；在类中实现<code>System.IDisposable</code>接口。</li>
</ul>
<h3 id="23-析构函数"><a href="#23-析构函数" class="headerlink" title="23. 析构函数"></a>23. 析构函数</h3><ul>
<li>在销毁C++对象时，其析构函数会立即运行。但由于使用C#时垃圾回收器的工作方式，无法确定C#对象的析构函数合适执行。所以，不能在析构函数中放置需要在某一时刻运行的代码，也不应使用能以任意顺序对不同类的实例调用的析构函数。如果对象占用了宝贵而重要的资源，应尽快释放这些资源，此时就不能等待垃圾回收器来释放了。</li>
<li>C#析构函数的实现会延迟对象最终从内存中删除的时间。没有析构函数的对象会在垃圾回收器的一次处理中从内存中删除，但有析构函数的对象需要两次处理才能销毁：第一次调用析构函数时，没有删除对象，第二次调用才真正删除对象。另外，运行库使用一个线程来执行所有对象的Finalize()方法。如果频繁使用析构函数，而且使用它们执行长时间的清理任务，对性能的影响就会非常显著。</li>
</ul>
<h3 id="24-IDisposable接口"><a href="#24-IDisposable接口" class="headerlink" title="24. IDisposable接口"></a>24. IDisposable接口</h3><ul>
<li>在C#中，推荐使用<code>System.IDisposable</code>接口替代析构函数。<code>IDisposable</code>接口定义了一种模式（具有语言级的支持）,该模式为释放非托管的资源提供了确定的机制，并避免产生析构函数固有的与垃圾回收器相关的问题。<code>IDisposable</code>接口声明了一个Dispos()方法，它不带参数，返回<code>void</code>。</li>
<li>Dispose()方法的实现代码显式地释放由对象直接使用的所有非托管资源，并在所有也实现<code>IDisposable</code>接口的封装对象上调用Dispose()方法。这样，Dispose()方法为何时释放非托管资源提供了精确的控制。</li>
</ul>
<blockquote>
<p>以上是「C#高级编程」前二十章的读书笔记。笔记摘录了笔者认为易忘的知识点，方便以后查阅和复习。摘抄整理过程中难免疏忽和遗漏，如有错误不当之处，请不吝指出，在此感激不尽！</p>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>「Modern OpenGL系列（一）」十步搞定OpenGL开发环境</title>
    <url>/post/%E3%80%8CModern%20OpenGL%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%8D%E5%8D%81%E6%AD%A5%E6%90%9E%E5%AE%9AOpenGL%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>OpenGL官网：<span class="exturl" data-url="aHR0cHM6Ly93d3cub3BlbmdsLm9yZy4v">https://www.opengl.org。<i class="fa fa-external-link-alt"></i></span><br>开发常用的SDK库：<span class="exturl" data-url="aHR0cHM6Ly93d3cub3BlbmdsLm9yZy9zZGsvbGlicy8=">https://www.opengl.org/sdk/libs/<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="搭建环境前的准备"><a href="#搭建环境前的准备" class="headerlink" title="搭建环境前的准备"></a>搭建环境前的准备</h3><p>在搭建OpenGL开发环境前先下载好下面的三个压缩文件：</p>
<ol>
<li>GLEW（OpenGL Extension Wrangler Library）：<span class="exturl" data-url="aHR0cDovL2dsZXcuc291cmNlZm9yZ2UubmV0Lw==">详细介绍<i class="fa fa-external-link-alt"></i></span>。压缩包下载链接：<span class="exturl" data-url="aHR0cDovL2dsZXcuc291cmNlZm9yZ2UubmV0Lw==">Binaries		Windows 32-bit and 64-bit<i class="fa fa-external-link-alt"></i></span></li>
<li>GLM（OpenGL Mathematics）：<span class="exturl" data-url="aHR0cDovL2dsbS5nLXRydWMubmV0LzAuOS43L2luZGV4Lmh0bWw=">详细介绍<i class="fa fa-external-link-alt"></i></span>。压缩包下载链接：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ctdHJ1Yy9nbG0vcmVsZWFzZXMvZG93bmxvYWQvMC45LjcuNC9nbG0tMC45LjcuNC56aXA=">glm-0.9.7.4.zip<i class="fa fa-external-link-alt"></i></span></li>
<li>SDL（Simple DirectMedia Layer）：<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlic2RsLm9yZy8=">详细介绍<i class="fa fa-external-link-alt"></i></span>。压缩包下载链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlic2RsLm9yZy9yZWxlYXNlL1NETDItZGV2ZWwtMi4wLjQtVkMuemlw">SDL2-devel-2.0.4-VC.zip<i class="fa fa-external-link-alt"></i></span> (Visual C++ 32&#x2F;64-bit)</li>
</ol>
<blockquote>
<p>上面的三个库文件我已经上传到<span class="exturl" data-url="aHR0cDovL2Rvd25sb2FkLmNzZG4ubmV0L2RldGFpbC93ZW54aW4yMDExLzk1MDc5MzM=">我的CSDN资源<i class="fa fa-external-link-alt"></i></span>中，有需要的可自行下载。</p>
</blockquote>
<h3 id="创建VS项目"><a href="#创建VS项目" class="headerlink" title="创建VS项目"></a>创建VS项目</h3><ol>
<li>打开VS2015，文件-&gt;新建-&gt;项目（或者使用快捷键<code>Ctrl+Shift+N</code>）。然后选择<code>Visual C++</code> -&gt; Win32项目。如下图所示：<img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/morden_opengl_1.png" alt="新建项目"></li>
<li>点<code>确定</code>按钮后，接着点<code>下一步</code>，接下来操作如图所示：<img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/morden_opengl_2.png" alt="项目创建前的设置"></li>
<li>在项目源文件夹下添加<code>main.cpp</code>，然后编译（或者运行）一下工程。<code>main.cpp</code>源码如下：<code>#include &lt;iostream&gt; int main()&#123; std::cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; std::endl; return 0; &#125;</code></li>
<li>将上面下载好的三个文件解压。然后在项目文件夹（<code>OpenGLProject\OpenGLProject</code>）下新建两个文件夹分别取名为<code>include</code>和<code>lib</code>。如图：<img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/morden_opengl_3.png" alt="新建文件夹"></li>
<li>拷贝<code>GLEW</code>库文件到项目中。将解压的<code>glew-1.13.0</code>文件夹下的<code>include</code>文件中的<code>GL</code>文件拷贝到新建的<code>include</code>文件夹下。将<code>glew-1.13.0\lib\Release\Win32</code>文件夹下的<code>glew32.lib</code>和<code>glew32s.lib</code>文件拷贝到新建的<code>lib</code>文件夹下。将<code>glew-1.13.0\bin\Release\Win32</code>文件夹下的<code>glew32.dll</code>拷贝到最外层的<code>Debug</code>（<code>OpenGLProject\Debug</code>）文件夹下。</li>
<li>拷贝<code>GLM</code>库文件到项目中。将解压的<code>glm</code>文件夹下的<code>glm</code>文件夹整体拷贝到新建的<code>include</code>文件夹下。</li>
<li>拷贝<code>SDL</code>库文件到项目中。将解压的<code>SDL2-2.0.4</code>文件夹下的<code>include</code>文件夹整体拷贝到新建的<code>include</code>文件夹下,并重新命名为<code>SDL2</code>。将<code>SDL2-2.0.4\lib\x86</code>文件夹下的<code>SDL2.lib</code>、<code>SDL2main.lib</code>和<code>SDL2test.lib</code>都拷贝到新建的<code>lib</code>文件夹下，同时将<code>SDL2.dll</code>文件拷贝到最外层的<code>Debug</code>（<code>OpenGLProject\Debug</code>）文件夹下。</li>
<li>设置<code>include</code>路径。在VS的<code>解决方案资源管理器</code>中选中<code>OpenGLProject</code>项目，然后右键-&gt;属性。其他设置如图：<img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/morden_opengl_4.png" alt="设置include路径"></li>
<li>设置<code>lib</code>路径。设置步骤如图所示：<img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/morden_opengl_5.png" alt="设置lib路径"></li>
<li>设置附加依赖项。具体设置如图：<img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/morden_opengl_6.png" alt="设置附加依赖项"></li>
</ol>
<p>至此，OpenGL的开发环境已经搭建完成。下一篇文章讲解如何创建一个OpenGL的窗口。</p>
<blockquote>
<p>以上文章内容整理自YouTube视频教程<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vcGxheWxpc3Q/bGlzdD1QTEVFVG5YLXVQdEJYVDlULWhEMEJqMzFEU253aW8teXdo">Intro To Modern OpenGL Tutorial<i class="fa fa-external-link-alt"></i></span>。想要翻墙看原视频教程的请自备防和谐软件。</p>
</blockquote>
<hr>
<p><strong>同系列文章</strong></p>
<p>[「Modern OpenGL系列（一）」十步搞定OpenGL开发环境](<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（一）」十步搞定OpenGL开发环境&#x2F;)</p>
<p>[「Modern OpenGL系列（二）」创建OpenGL窗口](<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（二）」创建OpenGL窗口&#x2F;)</p>
<p>[「Modern OpenGL系列（三）」用OpenGL绘制一个三角形](<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（三）」用OpenGL绘制一个三角形&#x2F;)</p>
<p>[「Modern OpenGL系列（四）」在OpenGL中使用Shader](<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（四）」在OpenGL中使用Shader&#x2F;)</p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>「Modern OpenGL系列（三）」用OpenGL绘制一个三角形</title>
    <url>/post/%E3%80%8CModern%20OpenGL%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%8D%E7%94%A8OpenGL%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    <content><![CDATA[<p>在[上一篇文章](<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（二）」创建OpenGL窗口&#x2F;)中已经介绍了OpenGL窗口的创建。本文接着说如何用OpenGL绘制一个三角形。<br>1 . 添加头文件<code>mesh.h</code>，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glm\glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL\glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Vertex</span>(<span class="type">const</span> glm::vec3&amp; pos)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pos = pos;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	glm::vec3 pos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mesh</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Mesh</span>(Vertex* vertices, <span class="type">unsigned</span> <span class="type">int</span> numVertices);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Mesh</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Mesh</span>(<span class="type">const</span> Mesh&amp; other);</span><br><span class="line">	<span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Mesh&amp; other);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">enum</span></span><br><span class="line">	&#123;</span><br><span class="line">		POSITION_VB,</span><br><span class="line">		NUM_BUFFERS</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	GLuint m_vertexArrayObject;</span><br><span class="line">	GLuint m_vertexArrayBuffers[NUM_BUFFERS];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_drawCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2 . 添加类<code>mesh.cpp</code>，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mesh.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Mesh::<span class="built_in">Mesh</span>(Vertex* vertices, <span class="type">unsigned</span> <span class="type">int</span> numVertices)</span><br><span class="line">&#123;</span><br><span class="line">	m_drawCount = numVertices;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;m_vertexArrayObject);</span><br><span class="line">	<span class="built_in">glBindVertexArray</span>(m_vertexArrayObject);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glGenBuffers</span>(NUM_BUFFERS, m_vertexArrayBuffers);</span><br><span class="line">	<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_vertexArrayBuffers[POSITION_VB]);</span><br><span class="line">	<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, numVertices * <span class="built_in">sizeof</span>(vertices[<span class="number">0</span>]),  vertices, GL_STATIC_DRAW);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mesh::~<span class="built_in">Mesh</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">glDeleteVertexArrays</span>(<span class="number">1</span>, &amp;m_vertexArrayObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mesh::Draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glBindVertexArray</span>(m_vertexArrayObject);</span><br><span class="line">	<span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, m_drawCount);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glBindVertexArray</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 . 修改主类<code>main.cpp</code>，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL\glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;display.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mesh.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 设置窗体大小和标题</span></span><br><span class="line">	<span class="function">Display <span class="title">display</span><span class="params">(<span class="number">400</span>, <span class="number">300</span>, <span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置三角形顶点</span></span><br><span class="line">	Vertex vertices[] = &#123; <span class="built_in">Vertex</span>(glm::<span class="built_in">vec3</span>(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>)), <span class="built_in">Vertex</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>)), <span class="built_in">Vertex</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>)), &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成网格</span></span><br><span class="line">	<span class="function">Mesh <span class="title">mesh</span><span class="params">(vertices, <span class="keyword">sizeof</span>(vertices) / <span class="keyword">sizeof</span>(vertices[<span class="number">0</span>]))</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!display.<span class="built_in">IsClosed</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		display.<span class="built_in">Clear</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 绘制三角形</span></span><br><span class="line">		mesh.<span class="built_in">Draw</span>();	</span><br><span class="line"></span><br><span class="line">		display.<span class="built_in">Update</span>();<span class="comment">// 刷新</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本文整理自YouTube视频教程<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj0wak1MNWZNQkRHZyZpbmRleD04Jmxpc3Q9UExFRVRuWC11UHRCWFQ5VC1oRDBCajMxRFNud2lvLXl3aA==">#3.5 Intro to Modern OpenGL Tutorial: Meshes<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<hr>
<p><strong>同系列文章</strong></p>
<p>[「Modern OpenGL系列（一）」十步搞定OpenGL开发环境](<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（一）」十步搞定OpenGL开发环境&#x2F;)</p>
<p>[「Modern OpenGL系列（二）」创建OpenGL窗口](<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（二）」创建OpenGL窗口&#x2F;)</p>
<p>[「Modern OpenGL系列（三）」用OpenGL绘制一个三角形](<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（三）」用OpenGL绘制一个三角形&#x2F;)</p>
<p>[「Modern OpenGL系列（四）」在OpenGL中使用Shader](<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（四）」在OpenGL中使用Shader&#x2F;)</p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>「Modern OpenGL系列（二）」创建OpenGL窗口</title>
    <url>/post/%E3%80%8CModern%20OpenGL%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E3%80%8D%E5%88%9B%E5%BB%BAOpenGL%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<p>在博主的[上一篇文章](<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（一）」十步搞定OpenGL开发环境&#x2F;)中已经介绍了OpenGL开发环境的搭建，本篇博文将验证开发环境是否搭建成功。同时，也是迈出OpenGL开发的第一步。我们使用上一篇文章中新建的项目，创建一个OpenGL窗口。</p>
<ol>
<li>添加头文件<code>display.h</code>。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SDL2\SDL.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Display</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Display</span>(<span class="type">int</span> width, <span class="type">int</span> height, <span class="type">const</span> std::string&amp; title);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">(<span class="type">float</span> r, <span class="type">float</span> g, <span class="type">float</span> b, <span class="type">float</span> a)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">IsClosed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Display</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Display</span>(<span class="type">const</span> Display&amp; other) &#123;&#125;</span><br><span class="line">	Display&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Display&amp; other) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	SDL_Window* m_window;</span><br><span class="line">	SDL_GLContext m_glContext;</span><br><span class="line">	<span class="type">bool</span> m_isClosed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>添加显示类<code>display.cpp</code>. <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;display.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL\glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">Display::<span class="built_in">Display</span>(<span class="type">int</span> width, <span class="type">int</span> height, <span class="type">const</span> std::string&amp; title)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">SDL_Init</span>(SDL_INIT_EVERYTHING);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">SDL_GL_SetAttribute</span>(SDL_GL_RED_SIZE, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">SDL_GL_SetAttribute</span>(SDL_GL_GREEN_SIZE, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">SDL_GL_SetAttribute</span>(SDL_GL_BLUE_SIZE, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">SDL_GL_SetAttribute</span>(SDL_GL_ALPHA_SIZE, <span class="number">8</span>);<span class="comment">// 设置颜色的四个分量所占用内存为8bit</span></span><br><span class="line">	<span class="built_in">SDL_GL_SetAttribute</span>(SDL_GL_BUFFER_SIZE, <span class="number">32</span>);</span><br><span class="line">	<span class="built_in">SDL_GL_SetAttribute</span>(SDL_GL_DOUBLEBUFFER, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	m_window = <span class="built_in">SDL_CreateWindow</span>(title.<span class="built_in">c_str</span>(), SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, width, height, SDL_WINDOW_OPENGL);</span><br><span class="line">	m_glContext = <span class="built_in">SDL_GL_CreateContext</span>(m_window);</span><br><span class="line"></span><br><span class="line">	GLenum status = <span class="built_in">glewInit</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (status != GLEW_OK)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Glew failed to initialize&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_isClosed = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Display::~<span class="built_in">Display</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">SDL_GL_DeleteContext</span>(m_glContext);</span><br><span class="line">	<span class="built_in">SDL_DestroyWindow</span>(m_window);</span><br><span class="line">	<span class="built_in">SDL_Quit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display::Clear</span><span class="params">(<span class="type">float</span> r, <span class="type">float</span> g, <span class="type">float</span> b, <span class="type">float</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glClearColor</span>(r, g, b, a);<span class="comment">// 设置窗口背景色</span></span><br><span class="line">	<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<span class="comment">// 清除颜色缓冲</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Display::IsClosed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> m_isClosed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display::Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">SDL_GL_SwapWindow</span>(m_window);</span><br><span class="line"></span><br><span class="line">	SDL_Event e;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">SDL_PollEvent</span>(&amp;e))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (e.type == SDL_QUIT)</span><br><span class="line">		&#123;</span><br><span class="line">			m_isClosed = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在<code>main</code>函数中调用显示方法。具体代码如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL\glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;display.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Display <span class="title">display</span><span class="params">(<span class="number">400</span>, <span class="number">300</span>, <span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!display.<span class="built_in">IsClosed</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		display.<span class="built_in">Clear</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">		display.<span class="built_in">Update</span>();<span class="comment">// 刷新</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>运行项目。可以使用快捷键<code>F5</code>来运行项目。运行后会显示一个绿色的OpenGL窗口。如图：<img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/morden_opengl_7.png" alt="效果图"></li>
</ol>
<p><strong>注意：</strong> </p>
<ol>
<li><p>如果<code>main</code>方法没有参数，则会报错：<code>SDL2main.lib(SDL_windows_main.obj) : error LNK2019: 无法解析的外部符号 _SDL_main，该符号在函数 _main_utf8 中被引用</code>，所以<code>main</code>方法的签名必须是<code>int main(int argc, char** argv)</code>。</p>
</li>
<li><p>本文中的项目使用的是VS2015，建议是用VS2015打开。</p>
</li>
<li><p>源码下载。<a href="http://download.csdn.net/detail/wenxin2011/9507987"><strong>点此下载源码</strong></a></p>
</li>
</ol>
<blockquote>
<p>本文整理自YouTube视频教程<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1Ea2lLZ1FSaU1SVSZpbmRleD01Jmxpc3Q9UExFRVRuWC11UHRCWFQ5VC1oRDBCajMxRFNud2lvLXl3aA==">#2 Intro to Modern OpenGL Tutorial: OpenGL Windows<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<hr>
<p><strong>同系列文章</strong></p>
<p>[「Modern OpenGL系列（一）」十步搞定OpenGL开发环境](<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（一）」十步搞定OpenGL开发环境&#x2F;)</p>
<p>[「Modern OpenGL系列（二）」创建OpenGL窗口](<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（二）」创建OpenGL窗口&#x2F;)</p>
<p>[「Modern OpenGL系列（三）」用OpenGL绘制一个三角形](<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（三）」用OpenGL绘制一个三角形&#x2F;)</p>
<p>[「Modern OpenGL系列（四）」在OpenGL中使用Shader](<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（四）」在OpenGL中使用Shader&#x2F;)</p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>「Modern OpenGL系列（四）」在OpenGL中使用Shader</title>
    <url>/post/%E3%80%8CModern%20OpenGL%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%E3%80%8D%E5%9C%A8OpenGL%E4%B8%AD%E4%BD%BF%E7%94%A8Shader/</url>
    <content><![CDATA[<p> 在[上一篇文章]( <span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（三）」用OpenGL绘制一个三角形&#x2F;)中已经介绍了OpenGL窗口的创建。本文接着说如何用OpenGL绘制一个三角形。<br>1 . 添加头文件<code>shader.h</code>，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL\glew.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Shader</span>(<span class="type">const</span> std::string&amp; fileName);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Shader</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> NUM_SHADERS = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">Shader</span>(<span class="type">const</span> Shader&amp; other)&#123;&#125;</span><br><span class="line">	<span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Shader&amp; other)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	GLuint m_program;</span><br><span class="line">	GLuint m_shaders[NUM_SHADERS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2 . 添加类<code>shader.cpp</code>，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">CheckShaderError</span><span class="params">(GLuint shader, GLuint flag, <span class="type">bool</span> isProgram, <span class="type">const</span> std::string&amp; errorMessage)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> std::string <span class="title">LoadShader</span><span class="params">(<span class="type">const</span> std::string&amp; fileName)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> GLuint <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; text, GLenum shaderType)</span></span>;</span><br><span class="line"></span><br><span class="line">Shader::<span class="built_in">Shader</span>(<span class="type">const</span> std::string&amp; fileName)</span><br><span class="line">&#123;</span><br><span class="line">	m_program = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">	m_shaders[<span class="number">0</span>] = <span class="built_in">CreateShader</span>(<span class="built_in">LoadShader</span>(fileName + <span class="string">&quot;.vs&quot;</span>), GL_VERTEX_SHADER);</span><br><span class="line">	m_shaders[<span class="number">1</span>] = <span class="built_in">CreateShader</span>(<span class="built_in">LoadShader</span>(fileName + <span class="string">&quot;.fs&quot;</span>), GL_FRAGMENT_SHADER);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_SHADERS; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">glAttachShader</span>(m_program, m_shaders[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//glBindAttribLocation(m_program, 0, &quot;position&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">glLinkProgram</span>(m_program);</span><br><span class="line">	<span class="built_in">CheckShaderError</span>(m_program, GL_LINK_STATUS, <span class="literal">true</span>, <span class="string">&quot;Error: Program linking failed!&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glValidateProgram</span>(m_program);</span><br><span class="line">	<span class="built_in">CheckShaderError</span>(m_program, GL_VALIDATE_STATUS, <span class="literal">true</span>, <span class="string">&quot;Error: Program invalid!&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shader::~<span class="built_in">Shader</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_SHADERS; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">glDetachShader</span>(m_program, m_shaders[i]);</span><br><span class="line">		<span class="built_in">glDeleteShader</span>(m_shaders[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glDeleteProgram</span>(m_program);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::Bind</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">glUseProgram</span>(m_program);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> GLuint <span class="title">CreateShader</span><span class="params">(<span class="type">const</span> std::string&amp; text, GLenum shaderType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GLuint shader = <span class="built_in">glCreateShader</span>(shaderType);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (shader == <span class="number">0</span>)</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Error: Shader creation failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> GLchar* shaderSourceStrings[<span class="number">1</span>];</span><br><span class="line">	GLint shaderSourceStringLengths[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	shaderSourceStrings[<span class="number">0</span>] = text.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">glShaderSource</span>(shader, <span class="number">1</span>, shaderSourceStrings, shaderSourceStringLengths);</span><br><span class="line">	<span class="built_in">glCompileShader</span>(shader);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CheckShaderError</span>(shader, GL_COMPILE_STATUS, <span class="literal">false</span>, <span class="string">&quot;Error: Shader compilation failed!&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> shader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> std::string <span class="title">LoadShader</span><span class="params">(<span class="type">const</span> std::string&amp; fileName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::ifstream file;</span><br><span class="line">	file.<span class="built_in">open</span>((fileName).<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">	std::string output;</span><br><span class="line">	std::string line;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (file.<span class="built_in">is_open</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (file.<span class="built_in">good</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">getline</span>(file, line);</span><br><span class="line">			output.<span class="built_in">append</span>(line + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cerr &lt;&lt; <span class="string">&quot;Unable to load shader: &quot;</span> &lt;&lt; fileName &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">CheckShaderError</span><span class="params">(GLuint shader, GLuint flag, <span class="type">bool</span> isProgram, <span class="type">const</span> std::string&amp; errorMessage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GLint success = <span class="number">0</span>;</span><br><span class="line">	GLchar error[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (isProgram)</span><br><span class="line">		<span class="built_in">glGetProgramiv</span>(shader, flag, &amp;success);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">glGetShaderiv</span>(shader, flag, &amp;success);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (success == GL_FALSE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (isProgram)</span><br><span class="line">			<span class="built_in">glGetProgramInfoLog</span>(shader, <span class="built_in">sizeof</span>(error), <span class="literal">NULL</span>, error);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">glGetShaderInfoLog</span>(shader, <span class="built_in">sizeof</span>(error), <span class="literal">NULL</span>, error);</span><br><span class="line"></span><br><span class="line">		std::cerr &lt;&lt; errorMessage &lt;&lt; <span class="string">&quot;: &#x27;&quot;</span> &lt;&lt; error &lt;&lt; <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3 . 在项目文件夹下新建<code>res</code>文件夹，如下图：<img src="http://img.blog.csdn.net/20160508204145889" alt="这里写图片描述"><br>4 . 在新建的<code>res</code>文件夹下，新建顶点着色器文件<code>basicShader.vs</code>，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#version 120</span><br><span class="line"></span><br><span class="line">attribute vec3 position;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	gl_Position = vec4(position, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5 . 在新建的<code>res</code>文件夹下，新建片元着色器文件<code>basicShader.fs</code>，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#version 120</span><br><span class="line"></span><br><span class="line">attribute vec3 position;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	gl_Position = vec4(position, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6 . 修改主类<code>main.cpp</code>，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL\glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;display.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mesh.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 设置窗体大小和标题</span></span><br><span class="line">	<span class="function">Display <span class="title">display</span><span class="params">(<span class="number">400</span>, <span class="number">300</span>, <span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置三角形顶点</span></span><br><span class="line">	Vertex vertices[] = &#123; <span class="built_in">Vertex</span>(glm::<span class="built_in">vec3</span>(<span class="number">-0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>)), <span class="built_in">Vertex</span>(glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>)), <span class="built_in">Vertex</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">0</span>)), &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生成网格</span></span><br><span class="line">	<span class="function">Mesh <span class="title">mesh</span><span class="params">(vertices, <span class="keyword">sizeof</span>(vertices) / <span class="keyword">sizeof</span>(vertices[<span class="number">0</span>]))</span></span>;</span><br><span class="line">	<span class="comment">// 加载着色器</span></span><br><span class="line">	<span class="function">Shader <span class="title">shader</span><span class="params">(<span class="string">&quot;./res/basicShader&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!display.<span class="built_in">IsClosed</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		display.<span class="built_in">Clear</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 绑定着色器</span></span><br><span class="line">		shader.<span class="built_in">Bind</span>();</span><br><span class="line">		<span class="comment">// 绘制三角形</span></span><br><span class="line">		mesh.<span class="built_in">Draw</span>();	</span><br><span class="line"></span><br><span class="line">		display.<span class="built_in">Update</span>();<span class="comment">// 刷新</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7 . 运行项目。运行后会显示一个绿色的OpenGL窗口中有一个红色三角形。如图：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/morden_opengl_8.png" alt="效果图"></p>
<p><strong>注意：</strong>本文中的项目使用的是VS2015，建议是用VS2015打开。<a href="http://download.csdn.net/detail/wenxin2011/9513816"><strong>点此下载源码</strong></a></p>
<blockquote>
<p>本文整理自YouTube视频教程<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1jc0tyVkJXQ0l0YyZpbmRleD03Jmxpc3Q9UExFRVRuWC11UHRCWFQ5VC1oRDBCajMxRFNud2lvLXl3aA==">#3.5 Intro to Modern OpenGL Tutorial: Shaders<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<hr>
<p><strong>同系列文章</strong></p>
<p>[「Modern OpenGL系列（一）」十步搞定OpenGL开发环境](<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（一）」十步搞定OpenGL开发环境&#x2F;)</p>
<p>[「Modern OpenGL系列（二）」创建OpenGL窗口](<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（二）」创建OpenGL窗口&#x2F;)</p>
<p>[「Modern OpenGL系列（三）」用OpenGL绘制一个三角形](<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（三）」用OpenGL绘制一个三角形&#x2F;)</p>
<p>[「Modern OpenGL系列（四）」在OpenGL中使用Shader](<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENNb2Rlcm4=">http://davidsheh.github.io/post/「Modern<i class="fa fa-external-link-alt"></i></span> OpenGL系列（四）」在OpenGL中使用Shader&#x2F;)</p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>「Unity游戏开发」向量在游戏开发中的应用（一）</title>
    <url>/post/%E3%80%8CUnity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E3%80%8D%E5%90%91%E9%87%8F%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>向量在游戏开发中是非常实用的，我们在学校学完向量的知识后，只知道向量的基本知识，但对于如何将所学到的向量知识运用到实际的游戏开发中却不知所措。我计划写几篇关于向量在游戏中的应用的文章，总结一下在实际工作中所遇到过的运用向量机智处理问题的技巧。接下来要写的东西都是记录在我的云笔记中，现在计划整理一下后分享出来。<br>    对于向量的那些基本性质我不想说太多，有兴趣的读者可以自行查阅相关文档，这里只说向量的大小和方向。不知道读者朋友曾经玩过安卓上一款比较火的跳跃游戏没有，游戏名字叫「涂鸦跳跃」，英文名为「Doodle Jump」，游戏截图如下：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/DoodleJump.jpeg" alt="Doodle Jump"><br>    在玩「涂鸦跳跃」时，不知道你有没有想过这么一个问题：从下往上跳跃会直接穿过平台，从上往下掉不会穿过平台，这是如何实现的？<br>    关于这个问题，我的思考是：可以利用小人运动的速度的方向来判定是否启用碰撞体，速度方向向上时禁用碰撞体，速度方向向下时启用碰撞体。可能我说的这个思路读者朋友还是不明觉厉，下面我用Unity3D写了一个小Demo来帮助理解我的思路。<br>先上动态效果图：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/CubeJump.gif" alt="CubeJump"></p>
<p>具体实现代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Vector3 jumpForce = <span class="keyword">new</span> Vector3(<span class="number">10</span>, <span class="number">35</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Rigidbody mRigidbody;</span><br><span class="line">    <span class="keyword">private</span> BoxCollider boxCollider;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否处于碰撞状态  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> stayCollision = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.mRigidbody = <span class="keyword">this</span>.GetComponent&lt;Rigidbody&gt;();</span><br><span class="line">        <span class="keyword">this</span>.boxCollider = <span class="keyword">this</span>.GetComponent&lt;BoxCollider&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当刚体静止时，按空格键跳跃才有效  </span></span><br><span class="line">        <span class="keyword">if</span> (mRigidbody.IsSleeping() &amp;&amp; Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 给刚体施加一个力，是其运动起来  </span></span><br><span class="line">            <span class="keyword">this</span>.mRigidbody.AddForce(jumpForce);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mRigidbody.velocity.y &gt; <span class="number">0</span>) <span class="comment">// 速度方向向上  </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里不能重复设置isTrigger,否则IsSleeping()方法会失效  </span></span><br><span class="line">            <span class="comment">// 这里具体原因不得而知，因为被官方封装起来了，  </span></span><br><span class="line">            <span class="comment">// 但是猜测是因为刚体规定自身方法没有调用时为休眠状态  </span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.boxCollider.isTrigger)</span><br><span class="line">                <span class="keyword">this</span>.boxCollider.isTrigger = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!stayCollision) <span class="comment">// Player没有发生碰撞  </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.boxCollider.isTrigger)</span><br><span class="line">                <span class="keyword">this</span>.boxCollider.isTrigger = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider collider</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        stayCollision = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnTriggerExit</span>(<span class="params">Collider collider</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        stayCollision = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个小案例中，运用了速度向量的方向来判断是向上碰撞还是向下碰撞。作为「向量在游戏开发中的应用」这个小系列文章的第一篇，就用这个非常简单的小案例来开始吧。后续会更精彩，但更新时间不定。</p>
<p>本Demo使用的的开发工具是Unity5.0.1f1和VS2013，建议下载源码后用Unity5.0.1f1或者更高的版本打开。源码地址：<span class="exturl" data-url="aHR0cDovL2Rvd25sb2FkLmNzZG4ubmV0L2RldGFpbC93ZW54aW4yMDExLzk0NTM2Njk=">http://download.csdn.net/detail/wenxin2011/9453669<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<p><strong>同系列文章</strong></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENVbml0eSVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFMyU4MCU4RCVFNSU5MCU5MSVFOSU4NyU4RiVFNSU5QyVBOCVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFNCVCOCVBRCVFNyU5QSU4NCVFNSVCQSU5NCVFNyU5NCVBOCVFRiVCQyU4OCVFNCVCOCU4MCVFRiVCQyU4OS8=">「Unity游戏开发」向量在游戏开发中的应用（一）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENVbml0eSVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFMyU4MCU4RCVFNSU5MCU5MSVFOSU4NyU4RiVFNSU5QyVBOCVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFNCVCOCVBRCVFNyU5QSU4NCVFNSVCQSU5NCVFNyU5NCVBOCVFRiVCQyU4OCVFNCVCQSU4QyVFRiVCQyU4OS8=">「Unity游戏开发」向量在游戏开发中的应用（二）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENVbml0eSVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFMyU4MCU4RCVFNSU5MCU5MSVFOSU4NyU4RiVFNSU5QyVBOCVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFNCVCOCVBRCVFNyU5QSU4NCVFNSVCQSU5NCVFNyU5NCVBOCVFRiVCQyU4OCVFNCVCOCU4OSVFRiVCQyU4OS8=">「Unity游戏开发」向量在游戏开发中的应用（三）<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>游戏开发</tag>
        <tag>向量</tag>
      </tags>
  </entry>
  <entry>
    <title>「Unity游戏开发」向量在游戏开发中的应用（三）</title>
    <url>/post/%E3%80%8CUnity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E3%80%8D%E5%90%91%E9%87%8F%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>在<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENVbml0eSVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFMyU4MCU4RCVFNSU5MCU5MSVFOSU4NyU4RiVFNSU5QyVBOCVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFNCVCOCVBRCVFNyU5QSU4NCVFNSVCQSU5NCVFNyU5NCVBOCVFRiVCQyU4OCVFNCVCQSU4QyVFRiVCQyU4OS8=">上一篇博客<i class="fa fa-external-link-alt"></i></span>中讲了利用向量点乘在游戏开发中应用的几种情景。本篇博客将用一个简单的小例子来讲解在实际的游戏开发中如何利用向量的叉乘来解决问题。</p>
<h4 id="向量叉乘的几何意义"><a href="#向量叉乘的几何意义" class="headerlink" title="向量叉乘的几何意义"></a>向量叉乘的几何意义</h4><ol>
<li>叉积的长度 |a×b| 可以解释成以a和b为邻边的平行四边形的面积。</li>
<li>混合积 [a b c] &#x3D; (a×b)·c可以得到以a，b，c为棱的平行六面体的体积。</li>
</ol>
<blockquote>
<p>关于向量叉乘的其他定义、规律以及应用有兴趣的朋友可以参考<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS9saW5rP3VybD1Va2lXaFJkWFBBRkNyVlJhUTI5bWlpZTZhWmNuOVdMd3BSWVNzSUhUQVpoQUwwN2ZUZGF5bUlyMVhYUUI1bnhEYUdCOGtzX2ZrSFI2c1pRY0t6YVdHYQ==">百度百科<i class="fa fa-external-link-alt"></i></span>，这里就不再啰嗦了。本篇博客不想在叉乘其他地方纠结太多，只说一下如何用叉乘判断方向。</p>
</blockquote>
<h4 id="如何用向量叉乘判断方向"><a href="#如何用向量叉乘判断方向" class="headerlink" title="如何用向量叉乘判断方向"></a>如何用向量叉乘判断方向</h4><p>在网上有很多人将向量的应用总结为一句话：点乘判断角度，叉乘判断方向。关于点乘在<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VueGluMjAxMS9hcnRpY2xlL2RldGFpbHMvNTA5NzI5NzY=">上一篇文章<i class="fa fa-external-link-alt"></i></span>中已经说完了，所以这里就说说如何用向量叉乘判断方向。<br>我们都知道在一个平面内的两个非平行向量叉乘的结果是这个平面的法向量，这个法向量是有方向的，而这个方向可以用“右手定则”来判断。具体的判断方法是：<br>若坐标系是满足右手定则的，当右手的四指从向量<strong>a</strong>以不超过180度的转角转向向量<strong>b</strong>时，竖起的大拇指指向是向量<strong>n</strong>的方向。如下图：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/vector_cross.png" alt="向量叉乘"></p>
<blockquote>
<p>在右手坐标系中，当向量<strong>a</strong>和<strong>b</strong>作叉乘运算时， 利用“右手定则”可以知道：当法向量<strong>n</strong>跟某一坐标轴同向时，四指方向为逆时针方向；当法向量<strong>n</strong>跟该坐标轴反向时，四指方向为顺时针方向。同时“右手定则”要求转角不超过180度的方向，所以用叉乘判断的转向一定是最优转向（所要转动的角度最小，转动的代价也就最小）。在游戏中可利用这点来判断一个角色是顺时针还是逆时针才能更快速的转向一个敌人。</p>
</blockquote>
<blockquote>
<p><strong>注意：Unity3D是左手坐标系，所以四指方向跟右手坐标系正好相反。</strong></p>
</blockquote>
<h4 id="向量叉乘案例"><a href="#向量叉乘案例" class="headerlink" title="向量叉乘案例"></a>向量叉乘案例</h4><p>接下来的案例将展示如何用向量叉乘判断一个方向盘的转向。老规矩，先上个案例的效果图：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/wheel_rotate.gif" alt="案例效果图"></p>
<p>案例源码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VectorCrossDemo</span> : <span class="title">MonoBehaviour</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> GameObject wheelObj;</span><br><span class="line">    <span class="keyword">private</span> Vector3 wheelPos = Vector3.zero; </span><br><span class="line">    <span class="keyword">private</span> Vector3 oldVec = Vector3.zero;</span><br><span class="line">    <span class="keyword">private</span> Vector3 currVec = Vector3.zero;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use this for initialization</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Start</span> ()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        wheelObj = GameObject.Find(<span class="string">&quot;Wheel&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> != wheelObj)</span><br><span class="line">        &#123;</span><br><span class="line">            wheelPos = wheelObj.transform.position;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Update is called once per frame</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Update</span> ()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButton(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> ray = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">            RaycastHit hit;</span><br><span class="line">            <span class="keyword">if</span> (Physics.Raycast(ray, <span class="keyword">out</span> hit)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(hit.transform.name.Equals(<span class="string">&quot;Wheel&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    RotateWheel(hit.point);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RotateWheel</span> (<span class="params">Vector3 pos</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currVec = pos - wheelPos;<span class="comment">//计算方向盘中心点到触控点的向量			</span></span><br><span class="line"></span><br><span class="line">        Vector3 normalVec = Vector3.Cross(currVec, oldVec);<span class="comment">//计算法向量</span></span><br><span class="line">        <span class="built_in">float</span> vecAngle = Vector2.Angle(currVec, oldVec);<span class="comment">//计算两个向量的夹角		</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用“右手定则”可知，当大拇指方向指向我们，四指方向为逆时针方向；</span></span><br><span class="line">        <span class="comment">// 当大拇指远离我们，四指方向为顺时针方向。</span></span><br><span class="line">        <span class="comment">// 这里叉乘后的法向量平行于z轴,所以用法向量的z分量的正负判断法向量方向</span></span><br><span class="line">        <span class="keyword">if</span> (normalVec.z &gt; <span class="number">0</span>)<span class="comment">// 和z轴同向，则顺时针转</span></span><br><span class="line">        &#123;</span><br><span class="line">            wheelObj.transform.Rotate(Vector3.forward, -vecAngle);<span class="comment">// 顺时针转</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (normalVec.z &lt; <span class="number">0</span>)<span class="comment">//和z轴反向，则逆时针转</span></span><br><span class="line">        &#123;</span><br><span class="line">            wheelObj.transform.Rotate(Vector3.forward, vecAngle);<span class="comment">// 逆时针转</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        oldVec = currVec;<span class="comment">//赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>本Demo使用的的开发工具是Unity5.0.1f1和VS2013，建议下载源码后用Unity5.0.1f1或者更高的版本打开。<span class="exturl" data-url="aHR0cDovL2Rvd25sb2FkLmNzZG4ubmV0L2RldGFpbC93ZW54aW4yMDExLzk0ODU1MTY=">源码下载<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<hr>
<p><strong>同系列文章</strong></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENVbml0eSVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFMyU4MCU4RCVFNSU5MCU5MSVFOSU4NyU4RiVFNSU5QyVBOCVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFNCVCOCVBRCVFNyU5QSU4NCVFNSVCQSU5NCVFNyU5NCVBOCVFRiVCQyU4OCVFNCVCOCU4MCVFRiVCQyU4OS8=">「Unity游戏开发」向量在游戏开发中的应用（一）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENVbml0eSVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFMyU4MCU4RCVFNSU5MCU5MSVFOSU4NyU4RiVFNSU5QyVBOCVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFNCVCOCVBRCVFNyU5QSU4NCVFNSVCQSU5NCVFNyU5NCVBOCVFRiVCQyU4OCVFNCVCQSU4QyVFRiVCQyU4OS8=">「Unity游戏开发」向量在游戏开发中的应用（二）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENVbml0eSVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFMyU4MCU4RCVFNSU5MCU5MSVFOSU4NyU4RiVFNSU5QyVBOCVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFNCVCOCVBRCVFNyU5QSU4NCVFNSVCQSU5NCVFNyU5NCVBOCVFRiVCQyU4OCVFNCVCOCU4OSVFRiVCQyU4OS8=">「Unity游戏开发」向量在游戏开发中的应用（三）<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>游戏开发</tag>
        <tag>向量</tag>
      </tags>
  </entry>
  <entry>
    <title>「Unity游戏开发」向量在游戏开发中的应用（二）</title>
    <url>/post/%E3%80%8CUnity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E3%80%8D%E5%90%91%E9%87%8F%E5%9C%A8%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>在<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENVbml0eSVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFMyU4MCU4RCVFNSU5MCU5MSVFOSU4NyU4RiVFNSU5QyVBOCVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFNCVCOCVBRCVFNyU5QSU4NCVFNSVCQSU5NCVFNyU5NCVBOCVFRiVCQyU4OCVFNCVCOCU4MCVFRiVCQyU4OS8=">上一篇博客<i class="fa fa-external-link-alt"></i></span>中讲了利用向量方向的性质来解决问题。这篇博客将继续用一个简单的小例子来讲解如何将向量的点乘性质应用到实际的游戏开发中。</p>
<h2 id="向量点乘的几何定义"><a href="#向量点乘的几何定义" class="headerlink" title="向量点乘的几何定义"></a><strong>向量点乘的几何定义</strong></h2><p>设二维空间内有两个向量<strong>U</strong>和<strong>V</strong>，它们的夹角为θ（[0, π]），则内积定义为以下实数：<br>向量点乘的公式：<strong>U·V</strong> &#x3D; **|U||V|**cosθ<br>根据该公式可以退到下面五条结论：</p>
<ol>
<li><strong>U·V</strong> &gt; 0，表示向量<strong>U</strong>和<strong>V</strong>之间的夹角小于90度（锐角）</li>
<li><strong>U·V</strong> &lt; 0，表示向量<strong>U</strong>和<strong>V</strong>之间的夹角大于90度（钝角）</li>
<li><strong>U·V</strong> &#x3D; 0，表示向量<strong>U</strong>和<strong>V</strong>之间的夹角为90度（相互垂直）</li>
<li><strong>U·V</strong> &#x3D; 1，表示向量<strong>U</strong>和<strong>V</strong>的方向相同</li>
<li><strong>U·V</strong> &#x3D; -1，表示向量<strong>U</strong>和<strong>V</strong>的方向相反</li>
</ol>
<blockquote>
<p>关于向量点乘的其他定义、规律以及应用有兴趣的朋友可以参考<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS9saW5rP3VybD1YdHEtem1yc3NSdldEQUhadUcxemxoelNvSHYyZWhyV3Bsb0k5TGdBTURrWVZDU040eVRlZDRDX0V4UEtFUzlYVURkUGM3R2xSb1V6OW1wdVNYa3c3Sw==">百度百科<i class="fa fa-external-link-alt"></i></span>，这里就不再啰嗦了。本篇博客主要讲如何将以上五条结论应用到游戏开发中。</p>
</blockquote>
<h2 id="向量点乘的应用情景"><a href="#向量点乘的应用情景" class="headerlink" title="向量点乘的应用情景"></a><strong>向量点乘的应用情景</strong></h2><ol>
<li>根据向量点乘公式求两个向量的夹角大小。</li>
<li>根据结论1和2判断两个向量的夹角，可以用来限定两个向量的夹角。</li>
<li>根据结论3判断两个向量是否垂直。</li>
<li>根据结论4和5可以判断方位。可判断一个物体位于另一个物体的前面还是后面（或者左边还是右边）。</li>
</ol>
<p>向量点乘如何判断一个物体在另一个物体的的前面还是后面呢？在「3D数学基础：图形与游戏开发」这本书中对这点做了很好的解释。下面贴出书中原话：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/vector_dot.png" alt="向量点乘"></p>
<p>既然能判断前面还是后面，当然也能判断左边还是右边了，只是选择的方向向量不同而已，这里留给读者自己思考。</p>
<hr>
<p><strong>同系列文章</strong></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENVbml0eSVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFMyU4MCU4RCVFNSU5MCU5MSVFOSU4NyU4RiVFNSU5QyVBOCVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFNCVCOCVBRCVFNyU5QSU4NCVFNSVCQSU5NCVFNyU5NCVBOCVFRiVCQyU4OCVFNCVCOCU4MCVFRiVCQyU4OS8=">「Unity游戏开发」向量在游戏开发中的应用（一）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENVbml0eSVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFMyU4MCU4RCVFNSU5MCU5MSVFOSU4NyU4RiVFNSU5QyVBOCVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFNCVCOCVBRCVFNyU5QSU4NCVFNSVCQSU5NCVFNyU5NCVBOCVFRiVCQyU4OCVFNCVCQSU4QyVFRiVCQyU4OS8=">「Unity游戏开发」向量在游戏开发中的应用（二）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOENVbml0eSVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFMyU4MCU4RCVFNSU5MCU5MSVFOSU4NyU4RiVFNSU5QyVBOCVFNiVCOCVCOCVFNiU4OCU4RiVFNSVCQyU4MCVFNSU4RiU5MSVFNCVCOCVBRCVFNyU5QSU4NCVFNSVCQSU5NCVFNyU5NCVBOCVFRiVCQyU4OCVFNCVCOCU4OSVFRiVCQyU4OS8=">「Unity游戏开发」向量在游戏开发中的应用（三）<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>游戏开发</tag>
        <tag>向量</tag>
      </tags>
  </entry>
  <entry>
    <title>「代码整洁之道」读书笔记</title>
    <url>/post/%E3%80%8C%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ol>
<li>函数要尽可能短小，最好不要超过20行。而且函数应该做一件事，做好这件事，只做这一件事。</li>
<li>函数参数尽可能的少，建议一般不要超过三个。如果函数看来需要两个、三个或三个以上参数，就说明其中一些参数应该封装为类了。</li>
<li>对于一元函数，函数和参数应当形成一种非常良好的动词&#x2F;名词对形式。如，<code>write(name)</code>。</li>
<li>函数要么做什么事，要么回答什么事，但二者不可得兼。函数应该修改某对象的状态，或是返回该对象的有关信息。两样都干常会导致混乱。</li>
<li>函数是语言的动词，类是名词。</li>
<li>如果可能尽量不写注释，而是让变量和函数本身见名知意。</li>
<li>暂时未完成的部分使用TODO注释，让开发工具将未完成的部分放到工作列表。</li>
<li>没必要在代码里添加归属与署名，因为源代码控制系统已经帮我们做了这些事，完全没必要让这样的注释搞脏代码。</li>
<li>不要保留注释掉的代码，代码被注释掉说明是无用的。源代码控制系统会记录这些删掉的代码，不用担心找不回来。</li>
<li>自上向下展示函数调用依赖顺序，被调用的函数应该放在执行调用的函数下面。</li>
<li>每行代码不要超过120个字符，而最佳长度为80到100个字符。</li>
<li>对象暴露行为，隐藏数据。便于添加新对象类型而无需修改既有行为，同时也难以在既有对象中添加新行为。数据结构暴露数据，没有明显的行为。便于向既有数据结构添加新行为，同时也难以向既有函数添加新数据结构。</li>
<li>定义一个函数最好别返回null值。返回null值基本上是再给自己增加工作量，也是在给调用者添乱。如果你打算在方法中返回null值，不如抛出异常，或是返回特例对象。如果你在调用某个第三方API中可能返回null值的方法，可以考虑用新方法打包这个方法，在新方法中抛出异常或是返回特例对象。</li>
</ol>
<blockquote>
<p>以上是「代码简洁之道」前十章的读书笔记。只记录了笔者认为在实际工作用比较实用的部分，没有长篇大论的摘抄。主要用于阅读备忘，方便以后复习。</p>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>「翻译」Unity中的AssetBundle详解（三）</title>
    <url>/post/%E3%80%8C%E7%BF%BB%E8%AF%91%E3%80%8DUnity%E4%B8%AD%E7%9A%84AssetBundle%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="构建AssetBundles"><a href="#构建AssetBundles" class="headerlink" title="构建AssetBundles"></a>构建AssetBundles</h1><p>在<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9Bc3NldEJ1bmRsZXMtQnVpbGRpbmcuaHRtbCNBc3NldEJ1bmRsZXMtV29ya2Zsb3c=">AssetBundle工作流程<i class="fa fa-external-link-alt"></i></span>的文档中，我们有一个示例代码，它将三个参数传递给<code>BuildPipeline.BuildAssetBundles</code>函数。让我们更深入地了解我们实际上在说什么。<br><em>Assets&#x2F;AssetBundles</em>：这是AssetBundles将被输出到的目录。您可以将其更改为所需的任何输出目录，只需在尝试构建之前确保文件夹实际存在。</p>
<h2 id="BuildAssetBundleOptions"><a href="#BuildAssetBundleOptions" class="headerlink" title="BuildAssetBundleOptions"></a>BuildAssetBundleOptions</h2><p>有多种不同的<code>BuildAssetBundleOptions</code>选项可以选择。相关的各个选项可以参阅脚本API文档中的关于<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9CdWlsZEFzc2V0QnVuZGxlT3B0aW9ucy5odG1s">BuildAssetBundleOptions<i class="fa fa-external-link-alt"></i></span>的内容。<br>虽然随着需求的变化和增加，您可以自由组合<code>BuildAssetBundleOptions</code>选项，但有三个特定的<code>BuildAssetBundleOptions</code>是用来处理AssetBundle压缩：</p>
<ul>
<li>BuildAssetBundleOptions.None：此bundle选项使用LZMA格式压缩，这种压缩是序列化的数据文件的单一压缩的LZMA流。 LZMA压缩的文件在使用前需要对整个bundle解压缩。这导致最小的文件大小和由于解压缩而稍微增加的加载时间。值得注意的是，当使用此<code>BuildAssetBundleOptions</code>时，为了使用捆绑包中的任何资源，必须首先解压缩整个捆绑包。一旦bundle解压缩后，将使用LZ4在磁盘上重新压缩，LZ4压缩在使用bundle中的资产时，不需要提前对整个bundle进行解压缩。这最适合用于bundle中的资产，以便从bundle中使用一个资产将意味着所有资产将被加载。打包角色或场景的所有资源都是可能使用的捆绑包的一些示例。由于较小的初始文件大小，利用LZMA压缩仅推荐用于从异地主机下载资源包。一旦文件被下载，它会缓存为lz4压缩包。</li>
<li><code>BuildAssetBundleOptions.UncompressedAssetBundle</code>: 此bundle选项以数据完全未压缩的方式构建bundle。未压缩的缺点是较大的文件下载大小。但是，一旦下载的加载时间会更快。</li>
<li><code>BuildAssetBundleOptions.ChunkBasedCompression</code>: 此bundle选项使用称为LZ4的压缩方法，这导致比LZMA更大的压缩文件大小，但不像LZMA那样在使用之前不需要整个捆绑包解压缩。 LZ4使用基于块的算法，允许将AssetBundle以切片（pieces）或“块”(chunks)的形式加载。解压缩单个块允许使用包含的资产，即使AssetBundle的其他块未被解压缩。</li>
</ul>
<p>使用ChunkBasedCompression与未压缩的bundle具有可比较的加载时间，还具有减小磁盘大小的附加优势。</p>
<h2 id="BuildTarget"><a href="#BuildTarget" class="headerlink" title="BuildTarget"></a>BuildTarget</h2><p><code>BuildTarget.Standalone</code>: 在这里，我们正在告诉构建管道，我们将使用这些AssetBundles的目标平台。<br>您可以在<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9CdWlsZFRhcmdldC5odG1s">BuildTarget<i class="fa fa-external-link-alt"></i></span>的API的脚本参考文档中找到可用的显式构建目标的列表。但是，如果您不希望在构建目标中进行硬编码，则可以随时利用EditorUserBuildSettings.activeBuildTarget，这将自动找到你目前的设置构建和构建AssetBundles基于的目标平台。<br>一旦正确设置了构建脚本，就可以构建bundles了。如果您按照上述脚本示例，请单击<strong>Assets</strong> &gt; <strong>Build AssetBundles</strong>以启动该过程。<br>现在你已经成功构建了AssetBundles，你可能会注意到你的AssetBundles目录有可能比你预期更多的文件。确切地说，是2 *（n + 1）个文件。让我们花一点时间来看看<code>BuildPipeline.BuildAssetBundles</code>的产量。</p>
<p>对于你在编辑器中指定的每个AssetBundle，你将注意到一个包含<code>AssetBundle name</code>和<code>AssetBundle name +.manifest</code>的文件。</p>
<p>将会有一个额外的bundle和manifest，它不会与您创建的任何AssetBundle共享一个名称。而是以它位于的目录（AssetBundles构建到的目录）命名。这是Manifest Bundle。我们将在以后讨论更多的内容以及如何使用它。</p>
<h2 id="The-AssetBundle-File"><a href="#The-AssetBundle-File" class="headerlink" title="The AssetBundle File"></a>The AssetBundle File</h2><p>这是缺少.manifest扩展名的文件，以及你在运行时加载的内容，以加载你的资产。<br>AssetBundle文件是一个在内部包含多个文件的存档。此存档的结构可能会稍有变化，具体取决于它是AssetBundle还是场景AssetBundle。这是一个正常的AssetBundle的结构：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/assetbundle_1.jpg" alt="ArchiveFileSystem"></p>
<p>场景AssetBundle更改自标准的AssetBundles，因为它针对场景及其内容的流加载进行了优化。该图像显示场景bundle的内部结构：</p>
<h2 id="The-Manifest-File"><a href="#The-Manifest-File" class="headerlink" title="The Manifest File"></a>The Manifest File</h2><p>对于生成的每个包，包括附加的清单包，都会生成关联的清单文件。清单文件可以使用任何文本编辑器打开，并且包含诸如循环冗余校验（CRC）数据和包的依赖性数据的信息。对于正常的AssetBundles，他们的清单文件将如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ManifestFileVersion: 0</span><br><span class="line">CRC: 2422268106</span><br><span class="line">Hashes:</span><br><span class="line">  AssetFileHash:</span><br><span class="line">    serializedVersion: 2</span><br><span class="line">    Hash: 8b6db55a2344f068cf8a9be0a662ba15</span><br><span class="line">  TypeTreeHash:</span><br><span class="line">    serializedVersion: 2</span><br><span class="line">    Hash: 37ad974993dbaa77485dd2a0c38f347a</span><br><span class="line">HashAppended: 0</span><br><span class="line">ClassTypes:</span><br><span class="line">- Class: 91</span><br><span class="line">  Script: &#123;instanceID: 0&#125;</span><br><span class="line">Assets:</span><br><span class="line">  Asset_0: Assets/Mecanim/StateMachine.controller</span><br><span class="line">Dependencies: &#123;&#125;</span><br><span class="line"></span><br><span class="line">Which shows the contained assets, dependencies, and other information.</span><br><span class="line"></span><br><span class="line">The Manifest Bundle that was generated will have a manifest, but it’ll look more like this:</span><br><span class="line"></span><br><span class="line">ManifestFileVersion: 0</span><br><span class="line">AssetBundleManifest:</span><br><span class="line">  AssetBundleInfos:</span><br><span class="line">    Info_0:</span><br><span class="line">      Name: scene1assetbundle</span><br><span class="line">      Dependencies: &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这将显示AssetBundles如何关联以及它们的依赖关系。现在，只要明白这个bundle包含了AssetBundleManifest对象，这对于找出在运行时加载哪个bundle依赖是非常有用的。要了解有关如何使用此bundle和manifest对象的更多信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9Bc3NldEJ1bmRsZXMtQnVpbGRpbmcuaHRtbCNBc3NldEJ1bmRsZXMtTmF0aXZl">使用本地AssetBundles<i class="fa fa-external-link-alt"></i></span>的文档。</p>
<blockquote>
<p>原文链接：<br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9Bc3NldEJ1bmRsZXMtQnVpbGRpbmcuaHRtbA==">Building AssetBundles<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<hr>
<p><strong>同系列文章</strong></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUI4JTgwJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（一）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUJBJThDJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（二）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUI4JTg5JUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（三）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU1JTlCJTlCJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（四）<i class="fa fa-external-link-alt"></i></span> </p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUJBJTk0JUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（五）<i class="fa fa-external-link-alt"></i></span> </p>
]]></content>
      <categories>
        <category>技术翻译</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>「翻译」Unity中的AssetBundle详解（一）</title>
    <url>/post/%E3%80%8C%E7%BF%BB%E8%AF%91%E3%80%8DUnity%E4%B8%AD%E7%9A%84AssetBundle%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="AssetBundles"><a href="#AssetBundles" class="headerlink" title="AssetBundles"></a>AssetBundles</h2><p>AssetBundle是一个存档文件，其中包含平台在运行时加载的特定资产（模型，纹理，预制，音频剪辑，甚至整个场景）。AssetBundles可以表示彼此之间的依赖关系;例如AssetBundle A中的一个材质可以引用AssetBundle B中的一个纹理。为了通过网络进行有效的传递，可以根据用例要求，选择内置算法（LZMA和LZ4）来对AssetBundles进行压缩。<br>AssetBundles可用于可下载内容（DLC），减少初始安装大小，加载为最终用户平台优化的资产，并降低运行时内存压力。</p>
<h3 id="一个AssetBundle文件中有什么？"><a href="#一个AssetBundle文件中有什么？" class="headerlink" title="一个AssetBundle文件中有什么？"></a>一个AssetBundle文件中有什么？</h3><p>好的问题，实际上“AssetBundle”可以指两个不同但有关的事情。</p>
<p>第一个是磁盘上的实际文件。我们把这叫做AssetBundle存档，或在本文档只是短期档案。存档可以被认为是一个容器，就像一个文件夹，在其中保存其他文件。这些附加文件包括两种类型：序列化文件和资源文件。序列化的文件将您的资产分成各自的对象，并写入这个文件。资源文件只是存储在某些资产（纹理和音频）中的二进制数据块，允许我们在另一个线程上有效地将其从磁盘加载到内存。</p>
<p>第二个是您通过代码从特定存档加载资源的实际的AssetBundle对象。此对象包含您添加到此存档的资源的所有文件路径的映射到属于该资产的对象，该对象在需要时需要加载。（This object contains a map of all the file paths of the assets you added to this archive to the objects that belong to that asset that need to be loaded when you ask for it.）</p>
<h2 id="AssetBundle工作流程"><a href="#AssetBundle工作流程" class="headerlink" title="AssetBundle工作流程"></a>AssetBundle工作流程</h2><p>要开始使用AssetBundles，请按照下列步骤操作。有关每个工作流程的更详细信息，请参见本部分文档中的其他页面。</p>
<h3 id="将资产分配给AssetBundles"><a href="#将资产分配给AssetBundles" class="headerlink" title="将资产分配给AssetBundles"></a>将资产分配给AssetBundles</h3><p>要将一个给定的资产分配给一个AssetBundle，请按照下列步骤操作：</p>
<ol>
<li>从“项目视图”中选中要分配给一个bundle的资产</li>
<li>检查Inspector视图中的对象</li>
<li>在Inspector视图的底部，可以看到一个部分来分配AssetBundles和Variants</li>
<li>左侧的下拉菜单分配AssetBundle，而右侧的下拉菜单则指定Variants</li>
<li>点击左侧的下拉菜单，其中显示“None”以显示当前注册的AssetBundle名称</li>
<li>如果尚未创建，你将看到上面的图像中的列表</li>
<li>点击“New…”创建一个新的AssetBundle</li>
<li>键入所需的AssetBundle名称。请注意，AssetBundle名称支持一种类型的文件夹结构，具体取决于你键入的内容。要添加子文件夹，请使用“&#x2F;”分隔文件夹名称。例如：AssetBundle名称“environment&#x2F;forest”将在environment子文件夹下创建一个名为forest的bundle</li>
<li>一旦你选择或创建了一个AssetBundle名称，你可以重复此过程，为右侧下拉菜单分配或创建一个不同的名称，以分配或创建一个Variant名称，如果你愿意的话。在构建AssetBundles时，Variant名称不是必需的。</li>
</ol>
<p>要了解有关AssetBundle分配和随附策略的更多信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9Bc3NldEJ1bmRsZXMtUHJlcGFyaW5nLmh0bWw=">Preparing Assets for AssetBundles<i class="fa fa-external-link-alt"></i></span>的文档。</p>
<h3 id="构建AssetBundles"><a href="#构建AssetBundles" class="headerlink" title="构建AssetBundles"></a>构建AssetBundles</h3><p>在项目中的Assets文件夹下创建一个名为Editor的文件夹，并在文件夹中放置以下内容的脚本：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CreateAssetBundles</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="string">&quot;Assets/Build AssetBundles&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildAllAssetBundles</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> assetBundleDirectory = <span class="string">&quot;Assets/AssetBundles&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!Directory.Exists(assetBundleDirectory)</span><br><span class="line">        &#123;</span><br><span class="line">            Directory.CreateDirectory(assetBundleDirectory);</span><br><span class="line">        &#125;</span><br><span class="line">        BuildPipeline.BuildAssetBundles(assetBundleDirectory, BuildAssetBundleOptions.None, BuildTarget.Standalone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该脚本将在Assets菜单的底部创建一个名为“Build AssetBundles”的菜单项，该菜单项将执行与该标记关联的功能中的代码。当您单击Build AssetBundles时，进度条将显示一个构建对话框。这将使那些用AssetBundle名称标记的所有资产打包进同一个文件，并将它们放在由assetBundleDirectory定义的路径上的文件夹中。</p>
<p>有关此代码正在执行的更多详细信息，请参阅有关<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9Bc3NldEJ1bmRsZXMtQnVpbGRpbmcuaHRtbA==">Building AssetBundles<i class="fa fa-external-link-alt"></i></span>的文档。</p>
<h3 id="上传AssetBundles到非本地存储"><a href="#上传AssetBundles到非本地存储" class="headerlink" title="上传AssetBundles到非本地存储"></a>上传AssetBundles到非本地存储</h3><p>这一步对于每个用户都是独一无二的，而不是一步一步可以告诉你如何做。如果您打算将AssetBundles上传到第三方托管网站，请在此处进行。如果您正在严格执行本地开发，并打算将所有AssetBundles都放在磁盘上，请跳到下一步。</p>
<h3 id="加载AssetBundles和Assets"><a href="#加载AssetBundles和Assets" class="headerlink" title="加载AssetBundles和Assets"></a>加载AssetBundles和Assets</h3><p>对于有意从本地存储加载的用户，您将对AssetBundles.LoadFromFile API感兴趣。看起来像这样：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoadFromFileExample</span> <span class="title">extends</span> <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function">function <span class="title">Start</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> myLoadedAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, <span class="string">&quot;myassetBundle&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (myLoadedAssetBundle == <span class="literal">null</span>) &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Failed to load AssetBundle!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> prefab = myLoadedAssetBundle.LoadAsset.&lt;GameObject&gt;(<span class="string">&quot;MyObject&quot;</span>);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LoadFromFile</code>获取包文件的路径。</p>
<p>如果您自己托管AssetBundles并且需要将其下载到游戏中，那么您将对UnityWebRequest API感兴趣。这里有一个例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">InstantiateObject</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> uri = <span class="string">&quot;file:///&quot;</span> + Application.dataPath + <span class="string">&quot;/AssetBundles/&quot;</span> + assetBundleName;</span><br><span class="line">    UnityEngine.Networking.UnityWebRequest request = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(uri, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> request.Send();</span><br><span class="line">    AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);</span><br><span class="line">    GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line">    GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;Sprite&quot;</span>);</span><br><span class="line">    Instantiate(cube);</span><br><span class="line">    Instantiate(sprite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GetAssetBundle(string, int)</code>获取AssetBundle的位置的uri以及要下载的包的版本。在这个例子中，我们仍然指向一个本地文件，但是字符串uri可以指向你托管AssetBundles的任何URL。</p>
<p>UnityWebRequest具有处理AssetBundles的特定句柄（DownloadHandlerAssetBundle），DownloadHandlerAssetBundle从请求中获取AssetBundle。</p>
<p>无论使用的方法如何，你现在都可以访问AssetBundle对象。从该对象中加载资源，你将需要使用<code>LoadAsset&lt;T&gt;(string)</code>方法，该方法中泛型类型T表示你所要加载的Asset的类型，方法参数为所要加载的Asset对象的名称。这将返回您从AssetBundle加载的任何对象。您可以像Unity中的任何对象一样使用这些返回的对象。例如，如果要在场景中创建一个GameObject，则只需要调用Instantiate（gameObjectFromAssetBundle）。<br>有关加载AssetBundles的API的更多信息，请参阅<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9Bc3NldEJ1bmRsZXMtTmF0aXZlLmh0bWw=">Using AssetBundles Natively<i class="fa fa-external-link-alt"></i></span>文档。</p>
<blockquote>
<p>原文链接：</p>
</blockquote>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9Bc3NldEJ1bmRsZXNJbnRyby5odG1s">AssetBundles<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9Bc3NldEJ1bmRsZXMtV29ya2Zsb3cuaHRtbA==">AssetBundle Workflow<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<hr>
<p><strong>同系列文章</strong></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUI4JTgwJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（一）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUJBJThDJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（二）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUI4JTg5JUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（三）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU1JTlCJTlCJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（四）<i class="fa fa-external-link-alt"></i></span> </p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUJBJTk0JUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（五）<i class="fa fa-external-link-alt"></i></span> </p>
]]></content>
      <categories>
        <category>技术翻译</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>「翻译」Unity中的AssetBundle详解（二）</title>
    <url>/post/%E3%80%8C%E7%BF%BB%E8%AF%91%E3%80%8DUnity%E4%B8%AD%E7%9A%84AssetBundle%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="为AssetBundles准备资源"><a href="#为AssetBundles准备资源" class="headerlink" title="为AssetBundles准备资源"></a>为AssetBundles准备资源</h2><p>使用AssetBundles时，您可以随意将任何Asset分配给所需的任何Bundle。但是，在设置Bundles时，需要考虑一些策略。这些分组策略可以使用到任何你认为适合的特定项目中。你可以随心所欲地混合和匹配这些策略。</p>
<h3 id="逻辑实体分组"><a href="#逻辑实体分组" class="headerlink" title="逻辑实体分组"></a>逻辑实体分组</h3><p>逻辑实体分组是根据其所代表的项目的功能部分将资产分配给AssetBundles的。这包括诸如用户界面、人物、环境以及在整个应用程序的整个生命周期中频繁出现的其他部分。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>把用户界面的所有纹理和布局数据打包到一起</li>
<li>把人物角色所包含的所有的模型和动画打包到一起</li>
<li>把多个关卡中共用的纹理和模型打包到一起</li>
</ul>
<p>逻辑实体分组是可下载内容（DLC）的理想选择，因为以这种方式分离的所有内容，您可以对单个实体进行更改，而不需要下载其他未更改的资产。<br>能够正确实施这一策略的最大的窍门是，开发人员将资产分配给各自的Bundle必须熟悉项目中每个资产的使用时间和位置。</p>
<h3 id="类型分组"><a href="#类型分组" class="headerlink" title="类型分组"></a>类型分组</h3><p>对于此策略，您可以将相似类型的Assets（如音轨或语言本地化文件）分配给单个AssetBundle。</p>
<p>类型分组是构建要由多个平台使用的AssetBundles的更好策略之一。例如，如果您的音频压缩设置在Windows和Mac平台之间是相同的，您可以将所有音频数据自己打包到AssetBundles中，并重复使用这些Bundles，而着色器则倾向于使用更多的平台特定选项进行编译，因此你为Mac构建的着色器包可能不能在Windows上重复使用。此外，这种方法非常适合使你的AssetBundles与更多的Unity版本兼容，如同纹理压缩格式和设置的更改频率比你的脚本或预制体的更改频率更低。</p>
<h3 id="并发内容分组（Concurrent-Content-Grouping）"><a href="#并发内容分组（Concurrent-Content-Grouping）" class="headerlink" title="并发内容分组（Concurrent Content Grouping）"></a>并发内容分组（Concurrent Content Grouping）</h3><p>并发内容分组是将要同时加载和使用的Assets捆绑在一起的想法。您可以将这些类型的Bundles用于基于关卡的游戏，其中每个关卡都包含完全独特的角色、纹理、音乐等。你要绝对肯定的是，包含在这些AssetBundles中一个Asset被使用的同时，其余的Assets也会被使用。对并发内容分组捆绑中的单个资产的依赖将导致加载时间的显著增加。你将因为这个单一Asset而被迫下载整个Bundle。</p>
<p>并发内容分组的Bundles最常用的用例是基于场景的Bundles。在此分配策略中，每个场景Bundle应该包含大部分或全部场景依赖关系。</p>
<p>注意，一个项目完全可以并且应该根据需要来组合这些策略。对于任何给定的场景使用最优资产分配策略可以极大地提高任何项目的效率。</p>
<p>例如，一个项目可能决定将其用于不同平台的用户界面（UI）元素分组到他们自己的特定于平台的UI Bundle中，但按照关卡或场景对其交互式内容进行分组。</p>
<p>不管你遵循什么策略，这里有一些额外的建议值得你铭记在心：</p>
<ul>
<li>将经常更新的对象拆分成AssetBundles，这些对象与很少更改的对象分开</li>
<li>组合可能同时加载的对象。如一个模型，它的纹理和动画</li>
<li>如果你注意到多个AssetBundles中的多个对象取决于完全不同的AssetBundle中的单个资产，请将依赖关系移动到单独的AssetBundle。如果几个AssetBundles引用了其他AssetBundles中的同一组资产，可能值得将这些依赖关系拉入共享的AssetBundle以减少重复。</li>
<li>如果两套对象不太可能同时加载，例如标清和高清资产，请确保它们在自己的资产组合中。</li>
<li>如果一个AssetBundle中经常有少于50%的Bundle在同一时间加载，那么可以考虑拆分该AssetBundle。</li>
<li>如果有一些小的AssetBundles（少于5到10个资产的）经常同时被加载，可以考虑组合这些AssetBundles。</li>
<li>如果一组对象只是同一对象的不同版本，可考虑使用AssetBundle Variants</li>
</ul>
<blockquote>
<p>原文链接：<br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9Bc3NldEJ1bmRsZXMtUHJlcGFyaW5nLmh0bWw=">Preparing Assets for AssetBundles<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<hr>
<p><strong>同系列文章</strong></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUI4JTgwJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（一）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUJBJThDJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（二）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUI4JTg5JUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（三）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU1JTlCJTlCJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（四）<i class="fa fa-external-link-alt"></i></span> </p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUJBJTk0JUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（五）<i class="fa fa-external-link-alt"></i></span> </p>
]]></content>
      <categories>
        <category>技术翻译</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>「翻译」Unity中的AssetBundle详解（五）</title>
    <url>/post/%E3%80%8C%E7%BF%BB%E8%AF%91%E3%80%8DUnity%E4%B8%AD%E7%9A%84AssetBundle%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<h2 id="AssetBundle-管理器"><a href="#AssetBundle-管理器" class="headerlink" title="AssetBundle 管理器"></a>AssetBundle 管理器</h2><p>AssetBundle Manager 可以在<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXNzZXRzdG9yZS51bml0eTNkLmNvbS9lbi8jIS9jb250ZW50LzQ1ODM2">这里<i class="fa fa-external-link-alt"></i></span>下载，是由 Unity 制作的一种工具，可以使 AssetBundles 更加精简。下载和导入 AssetBundle Manager 软件包不仅添加了一个新的API调用来加载和使用AssetBundles，而且还添加了一些编辑器功能来简化工作流。此功能可以在“资产”菜单选项下找到。此新部分将包含以下选项：</p>
<h3 id="模拟模式"><a href="#模拟模式" class="headerlink" title="模拟模式"></a>模拟模式</h3><p>启用模拟模式允许 AssetBundle Manager 使用 AssetBundles，但不需要实际构建捆绑包。编辑器会看到 Assets 已分配给 AssetBundles，并直接使用 Assets ，而不是实际上从 AssetBundle 中提取 Assets。<br>使用模拟模式的主要优点是 Assets 可以被修改、更新、添加和删除，而不需要每次重新构建和部署AssetBundles。值得注意的是，AssetBundle 变体不适用于模拟模式。如果你需要使用变体，则你需要使用本地 AssetBundle 服务器。</p>
<h3 id="本地-AssetBundle-服务器"><a href="#本地-AssetBundle-服务器" class="headerlink" title="本地 AssetBundle 服务器"></a>本地 AssetBundle 服务器</h3><p>AssetBundle Manager 还可以启动一个本地 AssetBundle 服务器，该服务器可用于在编辑器或本地构建（包括移动端）中测试 AssetBundles。获取本地 AssetBundle 服务器工作的规定是必须在项目的根目录中创建一个名为AssetBundles的文件夹，该文件夹与 Assets 文件夹的级别相同。如下图：<br><img src="https://docs.unity3d.com/uploads/Main/AssetBundles-Manager-4.png"></p>
<p>创建文件夹后，你需要将 AssetBundles 构建到此文件夹。为此，请从新菜单选项中选择Build AssetBundles。这将为你构建它们到该目录。现在你已经建立了 AssetBundles（或已经决定使用模拟模式），并准备开始加载 AssetBundles。我们来看看 AssetBundle Manager 对我们提供的新的API调用。</p>
<h4 id="AssetBundleManager-Initialize"><a href="#AssetBundleManager-Initialize" class="headerlink" title="AssetBundleManager.Initialize()"></a>AssetBundleManager.Initialize()</h4><p>此函数加载 AssetBundleManifest 对象。在使用 AssetBundle Manager 开始加载资产之前，你需要调用它。在一个非常简单的例子中，初始化 AssetBundle Manager 可能如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IEnumerator Start()</span><br><span class="line">&#123;</span><br><span class="line">    yield return StartCoroutine(Initialize());</span><br><span class="line">&#125;</span><br><span class="line">IEnumerator Initialize()</span><br><span class="line">&#123;</span><br><span class="line">    var request = AssetBundleManager.Initialize();</span><br><span class="line">    if (request != null)</span><br><span class="line">        yield return StartCoroutine(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AssetBundle Manager 使用你在 Initialize() 期间加载的清单来帮助幕后的许多功能，包括依赖关系管理。</p>
<h4 id="Loading-Assets"><a href="#Loading-Assets" class="headerlink" title="Loading Assets"></a>Loading Assets</h4><p>你正在使用 AssetBundle Manager，你已初始化它，现在你可以加载某些资产。我们来看看如何加载 AssetBundle 并从该 Bundle 中实例化一个对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IEnumerator InstantiateGameObjectAsync (string assetBundleName, string assetName)</span><br><span class="line">&#123;</span><br><span class="line">    // Load asset from assetBundle.</span><br><span class="line">    AssetBundleLoadAssetOperation request = AssetBundleManager.LoadAssetAsync(assetBundleName, assetName, typeof(GameObject));</span><br><span class="line">    if (request == null)</span><br><span class="line">        yield break;</span><br><span class="line">    yield return StartCoroutine(request);</span><br><span class="line">    // Get the asset.</span><br><span class="line">    GameObject prefab = request.GetAsset&lt;GameObject&gt; ();</span><br><span class="line">    if (prefab != null)</span><br><span class="line">        GameObject.Instantiate(prefab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AssetBundle Manager 会异步执行所有的加载操作，因此它返回一个加载操作请求，它在调用 <code>yield return StartCoroutine（request）</code>时加载 Bundle;接着我们需要做的是调用<code>GetAsset&lt;T&gt;()</code> 从 AssetBundle 加载游戏对象。</p>
<h4 id="Loading-Scenes"><a href="#Loading-Scenes" class="headerlink" title="Loading Scenes"></a>Loading Scenes</h4><p>如果你有一个 AssetBundle 名称分配给场景，并且你需要加载该场景，则需要遵循稍微不同的代码路径。模式是相同的，但有微小的差异。以下是从AssetBundle加载场景的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IEnumerator InitializeLevelAsync (string levelName, bool isAdditive)</span><br><span class="line">&#123;</span><br><span class="line">    // Load level from assetBundle.</span><br><span class="line">    AssetBundleLoadOperation request = AssetBundleManager.LoadLevelAsync(sceneAssetBundle, levelName, isAdditive);</span><br><span class="line">    if (request == null)</span><br><span class="line">        yield break;</span><br><span class="line">    yield return StartCoroutine(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你所看到的，加载场景也是一个异步的，LoadLevelAsync返回一个加载操作请求，需要传递给一个StartCoroutine 才能加载场景。</p>
<h4 id="Load-Variants"><a href="#Load-Variants" class="headerlink" title="Load Variants"></a>Load Variants</h4><p>使用 AssetBundle Manager 加载变量实际上并不会改变在场景或资产中加载的代码。所有需要完成的操作都是设置 AssetBundleManager 的 ActiveVariants 属性。ActiveVariants 属性是一个字符串数组。只需构建一个字符串数组，其中包含在将它们分配给资产时创建的变体名称。以下是如何使用 hd 变体加载场景 AssetBundle。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IEnumerator InitializeLevelAsync (string levelName, bool isAdditive, string[] variants)</span><br><span class="line">&#123;</span><br><span class="line">    //Set the activeVariants.</span><br><span class="line">    AssetBundleManager.ActiveVariants = variants;</span><br><span class="line">    // Load level from assetBundle.</span><br><span class="line">    AssetBundleLoadOperation request = AssetBundleManager.LoadLevelAsync(variantSceneAssetBundle, levelName, isAdditive);</span><br><span class="line">    if (request == null)</span><br><span class="line">        yield break;</span><br><span class="line">    yield return StartCoroutine(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码中的其他地方构建的字符串数组（可能是从按钮点击或其他一些情况）中传递的地方。如果可用，则将加载与设置的活动变体相匹配的 Bundles。</p>
<h2 id="使用-AssetBundles-进行修补"><a href="#使用-AssetBundles-进行修补" class="headerlink" title="使用 AssetBundles 进行修补"></a>使用 AssetBundles 进行修补</h2><p>修补 AssetBundles 与下载新的 AssetBundle 并替换已存在的 AssetBundle 一样简单。如果使用<code>WWW.LoadFromCacheOrDownload</code> 或 <code>UnityWebRequest</code> 来管理应用程序的缓存AssetBundles，则将不同的版本参数传递到所选的 API 将触发下载新的 AssetBundles。补丁系统中更难解决的问题是检测哪个 AssetBundles 需要被替换。补丁系统需要两个信息列表：</p>
<ul>
<li>当前下载的 AssetBundles 的列表及其版本信息</li>
<li>服务器上的 AssetBundles 列表及其版本信息</li>
</ul>
<p>修补程序应该下载服务器端 AssetBundles 的列表，并比较 AssetBundle 列表。应该重新下载缺少 AssetBundles 或版本信息已更改的 AssetBundles。还可以编写一个自定义系统来检测对 AssetBundles 的更改。编写自己系统的大多数开发人员都选择使用行业标准的数据格式来存储 AssetBundle 文件列表，例如JSON，以及用一个标准 C# 类来计算校验和，如MD5。Unity 使用确定性方式排序的数据构建 AssetBundles。这允许具有自定义下载器的应用程序实现差分补丁（differential patching）。<br>Unity 不提供用于差分修补的任何内置机制，当使用内置缓存系统时，<code>WWW.LoadFromCacheOrDownload</code> 和 <code>UnityWebRequest</code> 都不会执行差异修补。如果需要进行差分修补，则必须写入自定义下载器。</p>
<blockquote>
<p>原文链接：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9Bc3NldEJ1bmRsZXMtTWFuYWdlci5odG1s">AssetBundle Manager<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9Bc3NldEJ1bmRsZXMtUGF0Y2hpbmcuaHRtbA==">Patching with AssetBundles<i class="fa fa-external-link-alt"></i></span></li>
</ol>
</blockquote>
<hr>
<h3 id="同系列文章"><a href="#同系列文章" class="headerlink" title="同系列文章"></a>同系列文章</h3><p><strong>同系列文章</strong></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUI4JTgwJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（一）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUJBJThDJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（二）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUI4JTg5JUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（三）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU1JTlCJTlCJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（四）<i class="fa fa-external-link-alt"></i></span> </p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUJBJTk0JUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（五）<i class="fa fa-external-link-alt"></i></span> </p>
]]></content>
      <categories>
        <category>技术翻译</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>「翻译」Unity中的AssetBundle详解（六）</title>
    <url>/post/%E3%80%8C%E7%BF%BB%E8%AF%91%E3%80%8DUnity%E4%B8%AD%E7%9A%84AssetBundle%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h2><p>本节介绍通常在使用 AssetBundles 的项目中出现的几个问题。</p>
<h3 id="Asset-重复"><a href="#Asset-重复" class="headerlink" title="Asset 重复"></a>Asset 重复</h3><p>当对象被构建到 AssetBundle 中时，Unity 5 的 AssetBundle 系统会发现对象的所有依赖关系。这是使用资产数据库完成的。此依赖关系信息用于确定将包含在 AssetBundle 中的对象集。明确分配给 AssetBundle 的对象只会内置到该 AssetBundle 中。当对象的 AssetImporter 的 assetBundleName 属性设置为非空字符串时，对象将被“显式分配”。在 AssetBundle 中未明确分配的任何对象将包含在所有的 AssetBundles 中，这些 AssetBundles 含有1个或多个引用未标记对象的对象。<br>如果两个不同的对象分配给两个不同的 AssetBundles，但都有一个公共依赖对象的引用，则该依赖对象将被复制到两个 AssetBundles 中。重复的依赖关系也将被实例化，这意味着依赖对象的两个副本将被视为具有不同标识符的不同对象。这将增加应用程序的 AssetBundles 的总大小。如果应用程序加载其父对象，这也将导致将两个不同的对象副本加载到内存中。</p>
<p>有几种方法来解决这个问题：</p>
<ol>
<li><p>确保内置到不同AssetBundles中的对象不共享依赖关系。任何共享依赖关系的对象都可以放置在相同的AssetBundle中，而不会重复它们的依赖关系。</p>
<ul>
<li>这种方法通常对于具有许多共享依赖关系的项目是不可行的。它可以生成碎片的AssetBundles，以至于必须频繁地重新构建和重新下载，而不方便和高效。</li>
</ul>
</li>
<li><p>AssetBundles 切片，以便不会同时加载共享依赖的两个 AssetBundles。</p>
<ul>
<li>这种方法可能适用于某些类型的项目，例如基于关卡的游戏。然而，它仍然不必要地增加了项目的AssetBundles的大小，并且增加了构建时间和加载时间。</li>
</ul>
</li>
<li><p>确保所有依赖资产都内置在自己的 AssetBundles 中。这完全消除了重复资产的风险，但也引起了复杂性。应用程序必须跟踪 AssetBundles 之间的依赖关系，并确保在调用任何 <code>AssetBundle.LoadAsset</code> API 之前加载正确的 AssetBundles。</p>
</li>
</ol>
<p>在 Unity 5 中，通过位于 UnityEditor 命名空间中的 AssetDatabase API 跟踪对象依赖关系。正如命名空间所暗示的，此 API 仅在 Unity 编辑器中可用，而不在运行时可用。 <code>AssetDatabase.GetDependencies</code> 可用于查找特定对象或资产的所有直接依赖关系。请注意，这些依赖关系可能有自己的依赖关系。此外，AssetImporter API 可用于查询分配给任何特定对象的 AssetBundle。<br>通过组合 AssetDatabase 和 AssetImporter API，可以编写一个编辑器脚本，以确保将 AssetBundle 的所有直接或间接依赖关系分配给 AssetBundles，或者两个 AssetBundles 没有共享尚未分配给 AssetBundle 的依赖关系。由于重复资产的内存成本，建议所有项目都有这样的脚本。</p>
<h3 id="精灵图集重复"><a href="#精灵图集重复" class="headerlink" title="精灵图集重复"></a>精灵图集重复</h3><p>以下部分描述了与自动生成的精灵图集结合使用时，Unity 5 的资产依赖关系计算代码的一个奇怪癖。任何自动生成的精灵图集将被分配给包含生成精灵图集的 Sprite 对象的 AssetBundle。如果将精灵对象分配给多个 AssetBundles，则 Sprite 图集将不会分配给 AssetBundle，并将被复制。如果 Sprite 对象未分配给 AssetBundle，则 Sprite 图集也将不会分配给 AssetBundle。为了确保精灵地图集不被重复，请检查标记在同一精灵图集中的所有精灵被分配到相同的资产组合。<br>在 Unity 5.2.2p3 及更老版本中，自动生成的精灵地图集将永远不会分配给 AssetBundle。因此，它们将被包含在任何含有其组成中的精灵的任何 AssetBundles 中，以及引用其组成中的精灵的任何 AssetBundles。<br>由于这个问题，强烈建议使用 Unity 的精灵打包程序的所有 Unity 5 项目升级到 Unity 5.2.2p4, 5.3 或任何新版本的Unity。<br>对于无法升级的项目，此问题有两种解决方法：</p>
<ol>
<li>简单的：避免使用 Unity 内置的精灵封隔器。由外部工具生成的 Sprite 地图集将是正常的资产，可以正确分配给 AssetBundle。</li>
<li>困难的：将所有使用自动分配精灵的对象分配给与精灵相同的 AssetBundle。</li>
</ol>
<ul>
<li>这将确保生成的精灵图集不被视为任何其他 AssetBundles 的间接依赖关系，不会被重复。</li>
<li>该解决方案保留了使用 Unity 的精灵打包程序的工作流程，但是它降低了开发人员将资产分成不同 AssetBundles 的能力，并且在任何参考图集的组件上的任何数据更改时强制重新下载整个精灵图集，即使是图集本身没有变化。</li>
</ul>
<h3 id="Android-Textures"><a href="#Android-Textures" class="headerlink" title="Android Textures"></a>Android Textures</h3><p>由于 Android 生态系统中的设备配置差距严重，通常需要将纹理压缩成几种不同的格式。虽然所有 Android 设备都支持 ETC1，但 ETC1 不支持Alpha通道的纹理。应用程序不需要 OpenGL ES 2 的支持，解决问题的最简单的方法是使用所有Android OpenGL ES 3设备支持的 ETC2。<br>大多数应用程序需要在不支持 ETC2 的旧设备上运行。解决这个问题的一种方法是使用 Unity 5 的 AssetBundle 变体。 （有关其他选项的详细信息，请参阅 Unity 的 Android 优化指南。）要使用 AssetBundle 变体，使用 ETC1 不能被干净压缩的所有纹理必须与纹理唯一的 AssetBundles 隔离。接下来，使用供应商特定的纹理压缩格式（如 DXT5，PVRTC 和 ATITC），创建足够的这些 AssetBundles 变体来支持 Android 生态系统的非 ETC2 功能片段。对于每个 AssetBundle 变体，将包含的纹理的 TextureImporter 设置更改为适用于 Variant 的压缩格式。<br>在运行时，可以使用 <span class="exturl" data-url="aHR0cDovL2RvY3MudW5pdHkzZC5jb20vU2NyaXB0UmVmZXJlbmNlL1N5c3RlbUluZm8uU3VwcG9ydHNUZXh0dXJlRm9ybWF0Lmh0bWw/X2dhPTEuMTQxNjg3MjgyLjE3NTE0NjgyMTMuMTQ3OTEzOTg2MA==">SystemInfo.SupportsTextureFormat<i class="fa fa-external-link-alt"></i></span> API 检测不同纹理压缩格式的支持。该信息应用于选择并加载包含受支持格式压缩的纹理的 AssetBundle 变体。有关 Android 纹理压缩格式的更多信息，请点击<span class="exturl" data-url="aHR0cDovL2RldmVsb3Blci5hbmRyb2lkLmNvbS9ndWlkZS90b3BpY3MvZ3JhcGhpY3Mvb3BlbmdsLmh0bWwjdGV4dHVyZXM=">此处<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="iOS-文件句柄过度使用"><a href="#iOS-文件句柄过度使用" class="headerlink" title="iOS 文件句柄过度使用"></a>iOS 文件句柄过度使用</h3><p>以下部分中描述的问题已在 Unity 5.3.2p2 中修复。 Unity 的当前版本不受此问题的影响。在 Unity 5.3.2p2 之前的版本中，Unity 将在 AssetBundle 加载的整个时间内为 AssetBundle 保留打开的文件句柄。这在大多数平台上不是问题。但是，iOS 限制进程可能同时打开 255 的文件句柄数。如果加载 AssetBundle 超出此限制，将导致加载失败，并显示 “Too Many Open File Handles” 错误。对于试图将其内容分成数百或数千个资产分类的项目，这是一个常见的问题。对于无法升级到 Unity 修补版本的项目，临时解决方案有：</p>
<ul>
<li>通过合并相关的AssetBundles减少使用的AssetBundles数量</li>
<li>使用 AssetBundle.Unload（false）关闭 AssetBundle 的文件句柄，并手动管理加载的对象的生命周期</li>
</ul>
<h2 id="Unity-的-AssetBundle-浏览器工具"><a href="#Unity-的-AssetBundle-浏览器工具" class="headerlink" title="Unity 的 AssetBundle 浏览器工具"></a>Unity 的 AssetBundle 浏览器工具</h2><p>注意：此工具是 Unity 的标准功能的附加功能。要访问它，你必须从 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1VuaXR5LVRlY2hub2xvZ2llcy9Bc3NldEJ1bmRsZXMtQnJvd3Nlcg==">GitHub<i class="fa fa-external-link-alt"></i></span> 下载它，并从标准 Unity Editor 的下载和安装中单独安装。该工具使用户能够查看和编辑其 Unity 项目的 AssetBundle 的配置。它能防止创建无效软件包的编辑，并通知你现有软件包的任何问题。它还提供基本的构建功能。使用此工具替代选择资产并在检查器中手动设置其 AssetBundle。它可以放入 5.6 或更高版本的任何 Unity 项目中。它将在 <strong>Window</strong> &gt; <strong>AssetBundle Browser</strong> 中创建一个新的菜单项。Bundle 配置和构建功能在新窗口中分为两个选项卡。<br><img src="https://docs.unity3d.com/uploads/Main/AssetBundles-Browser-0.png"><br><strong>需要 Unity 版本在 5.6 以上</strong></p>
<h3 id="用法-——-配置"><a href="#用法-——-配置" class="headerlink" title="用法 —— 配置"></a>用法 —— 配置</h3><p>注意：此实用程序处于预发布状态，因此，我们建议在使用项目之前创建备份。此窗口提供了一个资源管理器界面，用于管理和修改项目中的 AssetBundle。当第一次打开时，该工具将解析后台中的所有 Bundle 数据，缓慢地标记警告或其检测到的错误。它可以与项目保持同步，但不能总是意识到工具之外的活动。要强制快速通过错误检测，或使用外部更改更新工具，请点击左上角的刷新按钮。窗口分为四个部分：Bundle 列表，Bundle 详细信息，资产列表和资产详细信息。<br><img src="https://docs.unity3d.com/uploads/Main/AssetBundles-Browser-1.png"></p>
<h4 id="Bundle-列表"><a href="#Bundle-列表" class="headerlink" title="Bundle 列表"></a>Bundle 列表</h4><p>左侧窗格显示项目中所有 Bundle 的列表。可用功能：</p>
<ul>
<li>选择一个 Bundle 或一组 Bundle，以查看资产列表窗格中的 Bundle 中的资产列表。</li>
<li>具有变体的 Bundle 是较暗的灰色，可以扩展以显示变体列表。</li>
<li>右键单击或缓慢双击以重命名 Bundle 或 Bundle 文件夹。</li>
<li>如果 Bundle 有任何错误、警告或信息消息，右侧将出现一个图标。鼠标悬停在图标上以获取更多信息。</li>
<li>如果 Bundle 中至少有一个场景（使其成为场景 Bundle），并且明确包含非场景属性，则会将其标记为有错误。此 Bundle 将不会建立，直到修复。</li>
<li>具有重复资产的 Bundle 将标有警告（有关资产列表部分重复的更多信息，请参见下文）</li>
<li>空 Bundle 将被标记一个信息消息。由于一些原因，空的 Bundle 并不是非常稳定，有时可能会从这个列表中消失。</li>
<li>Bundle 的文件夹将被标记为包含 Bundle 中最高的消息。</li>
<li>要修复 Bundle 中重复包含的资产，你可以：<ul>
<li>右键单击一个 Bundle 将所有确定为重复的资产移动到新的 Bundle 中。</li>
<li>右键单击多个 Bundle，将资产从所有选定的 Bundle 复制到新的 Bundle 中，或者仅在选择中共享的 Bundle 中。</li>
<li>你还可以将资产列表窗格中的重复资产拖放到 Bundle 列表中，以将其显式包含在 Bundle 中。资产清单功能的详细信息如下。</li>
</ul>
</li>
<li>右键点击或点击 DEL 删除软件包。</li>
<li>拖动 Bundle 将其移入和移出文件夹，或合并它们。</li>
<li>将资源从项目资源管理器拖动到 Bundle 上以添加它们。</li>
<li>将资源拖动到空的空间以创建新的 Bundle。</li>
<li>右键单击以创建新的 Bundle 或 Bundle 文件夹。</li>
<li>右键单击“转换为变体”<ul>
<li>这将添加一个变体（最初称为“新变量”）到选定的 Bundle。</li>
<li>所有目前在选定 Bundle 中的资产将被转移到新的变体中。</li>
<li>即将到来的功能：变体之间的不匹配检测。</li>
</ul>
</li>
</ul>
<p>图标表示 Bundle 是标准 Bundle 还是场景 Bundle。<br><img src="https://docs.unity3d.com/uploads/Main/AssetBundles-Browser-2.png"><br>标准 Bundle 图标<br><img src="https://docs.unity3d.com/uploads/Main/AssetBundles-Browser-3.png"><br>场景 Bundle 图标</p>
<h4 id="Bundle-细节"><a href="#Bundle-细节" class="headerlink" title="Bundle 细节"></a>Bundle 细节</h4><p>左下方窗格显示“捆绑列表”窗格中选择的捆绑包的详细信息。如果可用，该窗格将显示以下信息：</p>
<ul>
<li>总 Bundle 大小这是所有资产的磁盘大小的总和。</li>
<li>当前 Bundle 依赖于的 Bundle</li>
<li>与当前 Bundle 相关联的任何消息（错误&#x2F;警告&#x2F;信息）。</li>
</ul>
<h4 id="资产清单"><a href="#资产清单" class="headerlink" title="资产清单"></a>资产清单</h4><p>提供在 Bundle 列表中选择的任何 Bundle 中包含的资产列表的右上角窗格。可用功能：</p>
<blockquote>
<p>原文链接：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9Bc3NldEJ1bmRsZXMtVHJvdWJsZXNob290aW5nLmh0bWw=">Troubleshooting<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9Bc3NldEJ1bmRsZXMtQnJvd3Nlci5odG1s">Unity Asset Bundle Browser tool<i class="fa fa-external-link-alt"></i></span></li>
</ol>
</blockquote>
<hr>
<p><strong>同系列文章</strong></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUI4JTgwJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（一）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUJBJThDJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（二）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUI4JTg5JUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（三）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU1JTlCJTlCJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（四）<i class="fa fa-external-link-alt"></i></span> </p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUJBJTk0JUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（五）<i class="fa fa-external-link-alt"></i></span> </p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vMjAxNy8wOS8yNC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU1JTg1JUFEJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（六）<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>技术翻译</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>「翻译」Unity中的AssetBundle详解（四）</title>
    <url>/post/%E3%80%8C%E7%BF%BB%E8%AF%91%E3%80%8DUnity%E4%B8%AD%E7%9A%84AssetBundle%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="AssetBundle依赖关系"><a href="#AssetBundle依赖关系" class="headerlink" title="AssetBundle依赖关系"></a>AssetBundle依赖关系</h2><p>如果一个或多个UnityEngine.Objects包含位于另一个bundle中的UnityEngine.Object的引用，则AssetBundles可以依赖于其他AssetBundles。如果UnityEngine.Object包含一个在其他任何AssetBundle中都不包含的UnityEngine.Object的引用，则不会发生依赖关系。在这种情况下，在构建AssetBundles时，将bundle所依赖的对象的副本复制到捆绑包中。如果多个bundle中的多个对象包含对未分配给bundle的同一对象的引用，那么对该对象具有依赖关系的每个bundle将各自制作一个该对象的副本并将其打包到内置的AssetBundle中。<br>如果AssetBundle包含依赖关系，则在加载要尝试实例化的对象之前，加载包含这些依赖关系的bundles是重要的。 Unity不会尝试自动加载依赖关系。<br>考虑以下示例，<strong>Bundle 1</strong>中的材料引用了<strong>Bundle 2</strong>中的纹理：<br>在此示例中，加载<strong>Bundle 1</strong>中的Material之前，需要将<strong>Bundle 2</strong>加载到内存中。<strong>Bundle 1</strong>和<strong>Bundle 2</strong>的加载顺序无关紧要，重要的是在从<strong>Bundle 1</strong>加载Material之前加载<strong>Bundle 2</strong>。在下一节中，我们将讨论如何使用在<span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUI4JTg5JUVGJUJDJTg5Lw==">上一篇博客<i class="fa fa-external-link-alt"></i></span>中所涉及的AssetBundleManifest对象，在运行时确定和加载依赖关系。</p>
<h2 id="使用本地AssetBundles"><a href="#使用本地AssetBundles" class="headerlink" title="使用本地AssetBundles"></a>使用本地AssetBundles</h2><p>在 Unity 5 中，我们可以使用四种不同的 API 来加载 。它们的行为根据正在加载的平台和 AssetBundles 构建时使用的压缩方式（未压缩，LZMA，LZ4）而有所不同。<br>我们需要用到的四个 API 是：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9Bc3NldEJ1bmRsZS5Mb2FkRnJvbU1lbW9yeUFzeW5jLmh0bWw/X2dhPTEuMjI2ODAyOTY5LjU2MzcwOTc3Mi4xNDc5MjI2MjI4">AssetBundle.LoadFromMemoryAsync<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9Bc3NldEJ1bmRsZS5Mb2FkRnJvbUZpbGUuaHRtbD9fZ2E9MS4yNTkyOTc1NTAuNTYzNzA5NzcyLjE0NzkyMjYyMjg=">AssetBundle.LoadFromFile<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9XV1cuTG9hZEZyb21DYWNoZU9yRG93bmxvYWQuaHRtbD9fZ2E9MS4yMjY4MDI5NjkuNTYzNzA5NzcyLjE0NzkyMjYyMjg=">WWW.LoadfromCacheOrDownload<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9OZXR3b3JraW5nLlVuaXR5V2ViUmVxdWVzdC5odG1sP19nYT0xLjI1OTI5NzU1MC41NjM3MDk3NzIuMTQ3OTIyNjIyOA==">UnityWebRequest<i class="fa fa-external-link-alt"></i></span>’s <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9OZXR3b3JraW5nLkRvd25sb2FkSGFuZGxlckFzc2V0QnVuZGxlLmh0bWw/X2dhPTEuMjY0NTAwMjM1LjU2MzcwOTc3Mi4xNDc5MjI2MjI4">DownloadHandlerAssetBundle <i class="fa fa-external-link-alt"></i></span>(Unity 5.3 或者更高的版本)</li>
</ul>
<h3 id="AssetBundle-LoadFromMemoryAsync"><a href="#AssetBundle-LoadFromMemoryAsync" class="headerlink" title="AssetBundle.LoadFromMemoryAsync"></a>AssetBundle.LoadFromMemoryAsync</h3><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9Bc3NldEJ1bmRsZS5Mb2FkRnJvbU1lbW9yeUFzeW5jLmh0bWw=">AssetBundle.LoadFromMemoryAsync<i class="fa fa-external-link-alt"></i></span><br>此函数使用包含 AssetBundle 数据的字节数组的参数。如果需要也可以传递一个 CRC 值。如果 Bundle 是LZMA 压缩的，它将在加载时解压缩 AssetBundle。 LZ4 压缩的 Bundle 在压缩状态时被加载。<br>以下是使用此方法的一个示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">LoadFromMemoryAsync</span>(<span class="params"><span class="built_in">string</span> path</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> createRequest;</span><br><span class="line"></span><br><span class="line">    AssetBundle bundle = createRequest.assetBundle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> prefab = bundle.LoadAsset.&lt;GameObject&gt;(<span class="string">&quot;MyObject&quot;</span>);</span><br><span class="line">    Instantiate(prefab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，这不是唯一可以使用 LoadFromMemoryAsync 的策略。 可以用任何获取所需的字节数组的过程替代<code>File.ReadAllBytes(path)</code> 方法。</p>
<h3 id="AssetBundle-LoadFromFile"><a href="#AssetBundle-LoadFromFile" class="headerlink" title="AssetBundle.LoadFromFile"></a>AssetBundle.LoadFromFile</h3><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9Bc3NldEJ1bmRsZS5Mb2FkRnJvbUZpbGUuaHRtbA==">AssetBundle.LoadFromFile<i class="fa fa-external-link-alt"></i></span><br>从本地存储加载未压缩的 Bundles 时，此API非常高效。如果 Bundle 是未压缩或块（LZ4）压缩的，LoadFromFile 将直接从磁盘加载 Bundle。使用此方法加载完全压缩（LZMA）的 Bundle 将首先解压缩包，然后再将其加载到内存中。<br>如何使用 <code>LoadFromFile</code> 的一个例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoadFromFileExample</span> <span class="title">extends</span> <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function">function <span class="title">Start</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> myLoadedAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, <span class="string">&quot;myassetBundle&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (myLoadedAssetBundle == <span class="literal">null</span>) &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;Failed to load AssetBundle!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> prefab = myLoadedAssetBundle.LoadAsset.&lt;GameObject&gt;(<span class="string">&quot;MyObject&quot;</span>);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：在使用 Unity 5.3 或更早版本的Android设备上，尝试从 Streaming Assets 路径加载 AssetBundles 时，此API将失效。这是因为该路径的内容将驻留在压缩的 <code>.jar</code> 文件中。 Unity 5.4和更新版本可以使用这个API 加载 Streaming Assets 路径下的资源。</p>
<h3 id="WWW-LoadFromCacheOrDownload"><a href="#WWW-LoadFromCacheOrDownload" class="headerlink" title="WWW.LoadFromCacheOrDownload"></a><a href="WWW.LoadFromCacheOrDownload">WWW.LoadFromCacheOrDownload</a></h3><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9XV1cuTG9hZEZyb21DYWNoZU9yRG93bmxvYWQuaHRtbA==">WWW.LoadFromCacheOrDownload<i class="fa fa-external-link-alt"></i></span></p>
<p>**此 API 将被废弃 （请使用 UnityWebRequest） **</p>
<p>此API可用于从远程服务器下载 AssetBundles 或加载本地 AssetBundles。它是 UnityWebRequest API 的较旧且不太理想的版本。<br>从远程位置加载 AssetBundle 将自动缓存 AssetBundle。如果AssetBundle被压缩，那么一个工作线程将自动解压缩该包并将其写入缓存。一旦捆绑包解压缩并缓存，它将像 AssetBundle.LoadFromFile 一样加载。<br>如何使用 <code>LoadFromCacheOrDownload</code> 的一个例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoadFromCacheOrDownloadExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">Start</span> ()</span></span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Caching.ready)</span><br><span class="line">                    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> www = WWW.LoadFromCacheOrDownload(<span class="string">&quot;http://myserver.com/myassetBundle&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> www;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">string</span>.IsNullOrEmpty(www.error))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(www.error);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> myLoadedAssetBundle = www.assetBundle;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> asset = myLoadedAssetBundle.mainAsset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于缓存 AssetBundle 在 WWW 对象中的字节的内存开销，建议使用 WWW.LoadFromCacheOrDownload<br> 的所有开发人员确保其 AssetBundles 保持较小——最多为几兆字节。还建议在限制内存平台（如移动设备）上运行的开发人员确保其代码一次只下载一个 AssetBundle，以避免内存尖峰。<br>如果缓存文件夹没有用于缓存附加文件的空间，LoadFromCacheOrDownload将从缓存中迭代删除最近最少使用的AssetBundle，直到有足够的空间可用于存储新的AssetBundle。如果无法进行空间（因为硬盘已满，或者当前正在使用缓存中的所有文件）释放，LoadFromCacheOrDownload() 将绕过缓存并将文件以流的形式加入内存。<br>为了强制 LoadFromCacheOrDownload，版本参数（第二个参数）将需要更改。如果传递给该函数的版本与当前缓存的AssetBundle的版本匹配，则AssetBundle将仅从缓存加载。</p>
<h3 id="UnityWebRequest"><a href="#UnityWebRequest" class="headerlink" title="UnityWebRequest"></a>UnityWebRequest</h3><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9OZXR3b3JraW5nLlVuaXR5V2ViUmVxdWVzdC5HZXRBc3NldEJ1bmRsZS5odG1s">UnityWebRequest<i class="fa fa-external-link-alt"></i></span></p>
<p>UnityWebRequest 有一个特定的 API 调用来处理 AssetBundles。首先，你需要使用<br> UnityWebRequest.GetAssetBundle 创建您的 Web 请求。返回请求后，将请求对象传递给<code>DownloadHandlerAssetBundle.GetContent(UnityWebRequest)</code>。此 <code>GetContent</code> 函数调用将返回AssetBundle 对象。<br>你还可以在下载 Bundle 后使用 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9OZXR3b3JraW5nLkRvd25sb2FkSGFuZGxlckFzc2V0QnVuZGxlLmh0bWw=">DownloadHandlerAssetBundle<i class="fa fa-external-link-alt"></i></span> 类中的 <code>assetBundle</code> 属性，以<code>AssetBundle.LoadFromFile</code> 的效率加载 AssetBundle。<br>以下是一个如何加载包含两个 GameObject 的 AssetBundle 并实例化它们的示例。要开始这个过程，我们只需要调用 <code>StartCoroutine(InstantiateObject())</code>;</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">InstantiateObject</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> uri = <span class="string">&quot;file:///&quot;</span> + Application.dataPath + <span class="string">&quot;/AssetBundles/&quot;</span> + assetBundleName;        UnityEngine.Networking.UnityWebRequest request = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(uri, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> request.Send();</span><br><span class="line">    AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);</span><br><span class="line">    GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line">    GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;Sprite&quot;</span>);</span><br><span class="line">    Instantiate(cube);</span><br><span class="line">    Instantiate(sprite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 UnityWebRequest 的优点是它允许开发人员以更灵活的方式处理下载的数据，并可能消除不必要的内存使用情况。这是 UnityEngine.WWW 类中首选的 API。</p>
<h4 id="从-AssetBundles-载入资产"><a href="#从-AssetBundles-载入资产" class="headerlink" title="从 AssetBundles 载入资产"></a>从 AssetBundles 载入资产</h4><p>现在，您已经成功下载了 AssetBundle，是时候最终加载某些资产了。<br>通用代码段：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">T objectFromBundle = bundleObject.LoadAsset&lt;T&gt;(assetName);</span><br></pre></td></tr></table></figure>
<p><code>T</code> 是尝试加载的资产的类型。<br>决定如何加载资产时，有几种选择。分别是 LoadAsset 、LoadAllAssets 和它们的对应的异步方法 LoadAssetAsync 和 LoadAllAssetsAsync。<br>下面代码展示了如何从AssetBundles同步加载资产：<br>加载单个 GameObject：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">GameObject gameObject = loadedAssetBundle.LoadAsset&lt;GameObject&gt;(assetName);</span><br></pre></td></tr></table></figure>
<p>加载所有资产：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">Unity.Object[] objectArray = loadedAssetBundle.LoadAllAssets();</span><br></pre></td></tr></table></figure>
<p>现在，正如上文所示的方法返回的对象类型或要加载的对象的数组，异步方法返回一个 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9Bc3NldEJ1bmRsZVJlcXVlc3QuaHRtbA==">AssetBundleRequest<i class="fa fa-external-link-alt"></i></span>。访问资产之前，需要等待此操作完成。加载一个 Asset：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">AssetBundleRequest request = loadedAssetBundleObject.LoadAssetAsync&lt;GameObject&gt;(assetName);</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> request;</span><br><span class="line"><span class="keyword">var</span> loadedAsset = request.asset;</span><br></pre></td></tr></table></figure>
<p>以及</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">AssetBundleRequest request = loadedAssetBundle.LoadAllAssetsAsync();</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> request;</span><br><span class="line"><span class="keyword">var</span> loadedAssets = request.allAssets;</span><br></pre></td></tr></table></figure>
<p>一旦你加载了你所需要的 Assets，接下来就可以像使用 Unity 中任何其他对象一样使用加载的对象。</p>
<h4 id="加载-AssetBundle-清单文件（Manifests）"><a href="#加载-AssetBundle-清单文件（Manifests）" class="headerlink" title="加载 AssetBundle 清单文件（Manifests）"></a>加载 AssetBundle 清单文件（Manifests）</h4><p>加载 AssetBundle 清单文件非常有用。特别是在处理 AssetBundle 依赖项时。<br>要获得一个可用的 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9Bc3NldEJ1bmRsZU1hbmlmZXN0Lmh0bWw=">AssetBundleManifest<i class="fa fa-external-link-alt"></i></span> 对象，你需要加载额外的 AssetBundle（名称与其所在文件夹相同），并从中加载类型为 AssetBundleManifest 的对象。<br>加载清单本身与加载 AssetBundle 中的任何其他资产完全相同：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);</span><br><span class="line">AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(<span class="string">&quot;AssetBundleManifest&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>现在，你可以通过上述示例中的 manifest 对象访问 <code>AssetBundleManifest</code> API 的调用。从这里你可以使用清单来获取有关你所构建的 AssetBundles 的信息。该信息包括 AssetBundles 的依赖关系数据、散列数据和变体数据。</p>
<p>在前面的部分，当我们讨论 AssetBundle Dependencies 并且如果一个 bundle 对另一个 bundle 有依赖关系，那么在从原始 bundle 加载任何资源之前，需要加载这些 bundle。清单对象使得动态地找到加载依赖性成为可能。假设我们要加载名为 “assetBundle” 的 AssetBundle 的所有依赖项。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);</span><br><span class="line">AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(<span class="string">&quot;AssetBundleManifest&quot;</span>);</span><br><span class="line"><span class="built_in">string</span>[] dependencies = manifest.GetAllDependencies(<span class="string">&quot;assetBundle&quot;</span>); <span class="comment">//Pass the name of the bundle you want the dependencies for.</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">string</span> dependency <span class="keyword">in</span> dependencies)</span><br><span class="line">&#123;</span><br><span class="line">    AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, dependency));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示正在加载 AssetBundles、AssetBundle依赖关系和资产，现在是时候讨论管理所有这些加载的 AssetBundles 了。</p>
<h4 id="管理加载的-AssetBundles"><a href="#管理加载的-AssetBundles" class="headerlink" title="管理加载的 AssetBundles"></a>管理加载的 AssetBundles</h4><p>另请参阅：Unity 官方教程中有关 <span class="exturl" data-url="aHR0cHM6Ly91bml0eTNkLmNvbS9mci9sZWFybi90dXRvcmlhbHMvdG9waWNzL2Jlc3QtcHJhY3RpY2VzL2Fzc2V0YnVuZGxlLXVzYWdlLXBhdHRlcm5zI01hbmFnaW5nX0xvYWRlZF9Bc3NldHM=">Managing Loaded AssetBundles<i class="fa fa-external-link-alt"></i></span>的教程。</p>
<p>当它们从活动场景中删除时，Unity不会自动卸载对象。资产清理在特定时间触发，也可以手动触发。知道何时加载和卸载 AssetBundle 很重要。不正确卸载 AssetBundle 可能会导致内存中的对象复制或其他不合要求的情况（如缺少纹理）。<br>了解 AssetBundle 管理最重要的是什么时候调用 <code>AssetBundle.Unload(bool)</code>，并且在函数调用时你应该将 true 或 false 作为参数传递给函数。卸载 AssetBundle 是一个非静态的功能，此 API 卸载正在调用的 AssetBundle 的头部信息。该函数的参数表示是否也卸载从此 AssetBundle 实例化的所有对象。</p>
<p>如果使用 <code>AssetBundle.Unload(true)</code> 方法，就会卸载从 AssetBundle 中加载的所有对象，即使它们正在当前活动的场景中使用。这正是我们前面提到的，这可能会导致纹理丢失。我们假设材质 M 是从 AssetBundle AB 加载的，如下所示。如果调用 AB.Unload（true）。活动场景中的任何 M 实例也将被卸载和销毁。如果你改为调用 AB.Unload（false），它会破坏当前 M 和 AB 实例的链接。<br><img src="https://docs.unity3d.com/uploads/Main/AssetBundles-Native-1.png"><br>如果以后再次加载 AB，并调用 AB.LoadAsset()，Unity 将不会将 M 的现有副本重新链接到新加载的材质。那么 M 会加载两个副本。<br><img src="https://docs.unity3d.com/uploads/Main/AssetBundles-Native-2.png"><br><img src="https://docs.unity3d.com/uploads/Main/AssetBundles-Native-3.png"></p>
<p>一般来说，使用 AssetBundle.Unload(false) 并不会导致理想的情况。大多数项目应该使用 AssetBundle.Unload(true) 来避免在内存中复制对象。<br>大多数项目应该使用 AssetBundle.Unload(true) 并采用一种方法来确保对象不被重复。两种常见的方法是：</p>
<ul>
<li>在应用程序的生命周期中具有明确定义的地方，卸载临时 AssetBundles，例如关卡之间或加载屏幕期间。</li>
<li>维护单个对象的引用计数，并仅在其所有组成对象未使用时卸载 AssetBundles。这允许应用程序卸载和重新加载单个对象而没有重复的内存。</li>
</ul>
<p>如果应用程序必须使用 AssetBundle.Unload(false)，那么单个对象只能以两种方式卸载：</p>
<ul>
<li>在场景和代码中消除对不需要的对象的所有引用。完成之后，调用 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9SZXNvdXJjZXMuVW5sb2FkVW51c2VkQXNzZXRzLmh0bWw=">Resources.UnloadUnusedAssets<i class="fa fa-external-link-alt"></i></span>。</li>
<li>使用非叠加式加载场景。这将销毁当前场景中的所有对象并自动调用 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9SZXNvdXJjZXMuVW5sb2FkVW51c2VkQXNzZXRzLmh0bWw=">Resources.UnloadUnusedAssets<i class="fa fa-external-link-alt"></i></span>。</li>
</ul>
<p>如果你不想自己管理加载 AssetBundles、依赖关系和 Assets 本身，你可能会发现自己需要 AssetBundle Manager。</p>
<blockquote>
<p>原文链接：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9Bc3NldEJ1bmRsZXMtRGVwZW5kZW5jaWVzLmh0bWw=">AssetBundle Dependencies<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9Bc3NldEJ1bmRsZXMtTmF0aXZlLmh0bWw=">Using AssetBundles Natively<i class="fa fa-external-link-alt"></i></span></li>
</ol>
</blockquote>
<hr>
<p><strong>同系列文章</strong></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUI4JTgwJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（一）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUJBJThDJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（二）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUI4JTg5JUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（三）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU1JTlCJTlCJUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（四）<i class="fa fa-external-link-alt"></i></span> </p>
<p><span class="exturl" data-url="aHR0cDovL2Rhdmlkc2hlaC5naXRodWIuaW8vcG9zdC8lRTMlODAlOEMlRTclQkYlQkIlRTglQUYlOTElRTMlODAlOERVbml0eSVFNCVCOCVBRCVFNyU5QSU4NEFzc2V0QnVuZGxlJUU4JUFGJUE2JUU4JUE3JUEzJUVGJUJDJTg4JUU0JUJBJTk0JUVGJUJDJTg5Lw==">「翻译」Unity中的AssetBundle详解（五）<i class="fa fa-external-link-alt"></i></span> </p>
]]></content>
      <categories>
        <category>技术翻译</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>AssetBundle</tag>
      </tags>
  </entry>
  <entry>
    <title>「翻译」理解Unity的自动内存管理</title>
    <url>/post/%E3%80%8C%E7%BF%BB%E8%AF%91%E3%80%8D%E7%90%86%E8%A7%A3Unity%E7%9A%84%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>当创建对象、字符串或数组时，存储它所需的内存将从称为堆的中央池中分配。当项目不再使用时，它曾经占用的内存可以被回收并用于别的东西。在过去，通常由程序员通过适当的函数调用明确地分配和释放这些堆内存块。如今，像Unity的Mono引擎这样的运行时系统会自动为您管理内存。自动内存管理需要比显式分配&#x2F;释放更少的编码工作，并大大降低内存泄漏（内存被分配但从未随后释放的情况）的可能性。</p>
<h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><p>当调用一个函数时，它的参数值将被复制到一个保留特定调用的内存区域。只占用几个字节的数据类型可以非常快速方便地复制。然而，对象、字符串和数组要大得多，如果这些类型的数据被定期复制，那将是非常低效的。幸运的是，这是不必要的；大项目的实际存储空间是从堆中分配的，一个小的“指针”值用来记住它的位置。从那时起，只有指针在参数传递过程中需要被复制。只要运行时系统能够定位指针标识的项，就可以经常使用数据的一个副本。<br>在参数传递期间直接存储和复制的类型称为值类型。这些包括整数，浮点数，布尔和Unity的结构类型（例如Color和Vector3）。分配在堆上然后通过指针访问的类型称为引用类型，因为存储在变量中的值仅仅是“引用”到真实数据。引用类型的示例包括对象，字符串和数组。</p>
<h2 id="内存分配和垃圾收集"><a href="#内存分配和垃圾收集" class="headerlink" title="内存分配和垃圾收集"></a>内存分配和垃圾收集</h2><p>内存管理器跟踪它知道未被使用的堆中的区域。当请求一个新的内存块时（例如当一个对象被实例化时），管理器选择一个未使用的区域，从中分配该块，然后从已知的未使用的空间中移除分配的内存。后续请求以相同的方式处理，直到没有足够大的空闲区域分配所需的块大小。在这一点上，从堆中分配的所有内存仍然在使用中是非常不可能的。只要还存在可以找到它的引用变量，就只能访问堆上的引用项。如果对内存块的所有引用都消失了（即，引用变量已被重新分配，或者它们是现在超出范围的局部变量），则它占用的内存可以安全地重新分配。<br>为了确定哪些堆块不再被使用，内存管理器会搜索所有当前活动的引用变量，并将它们所指的块标记为<code>live</code>。在搜索结束时，内存管理器认为这些<code>live</code>块之间的任何空间都是空的，并且可用于后续分配。由于显而易见的原因，定位和释放未使用的内存的过程被称为垃圾回收（或简称GC）。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>垃圾收集对程序员来说是自动的、不可见的，但是收集过程实际上需要大量的CPU时间。如果正确使用，自动内存管理通常会等于或击败手动分配的整体性能。但是，对于程序员来说，重要的是要避免那些比实际需要触发更多次收集器和在执行中引入暂停的错误。有一些臭名昭著的算法，可能是GC噩梦，尽管他们乍一看是无辜的。重复字符串连接是一个典型的例子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C# script example</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleScript</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ConcatExample</span>(<span class="params"><span class="built_in">int</span>[] intArray</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> line = intArray[<span class="number">0</span>].ToString();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; intArray.Length; i++) &#123;</span><br><span class="line">            line += <span class="string">&quot;, &quot;</span> + intArray[i].ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JS script example</span></span><br><span class="line"><span class="function">function <span class="title">ConcatExample</span>(<span class="params">intArray: <span class="built_in">int</span>[]</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> line = intArray[<span class="number">0</span>].ToString();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; intArray.Length; i++) &#123;</span><br><span class="line">        line += <span class="string">&quot;, &quot;</span> + intArray[i].ToString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的关键细节是，新的部分不会被一个接一个地添加到字符串中。实际情况是，每次循环<code>line</code>变量的前一个内容都会变死——一个完整的新字符串被分配到包含原来的部分，再在最后加上新的部分。由于字符串随着<code>i</code>值的增加而变得更长，所以所消耗的堆空间数量也增加了，因此每次调用这个函数时都很容易消耗数百字节的空闲堆空间。如果你需要连接多个字符串，那么一个更好的选择是Mono库的<span class="exturl" data-url="aHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tZ2IvbGlicmFyeS9zeXN0ZW0udGV4dC5zdHJpbmdidWlsZGVyLmFzcHg=">System.Text.StringBuilder<i class="fa fa-external-link-alt"></i></span>类。然而，即使反复连接也不会引起太多麻烦，除非它被频繁调用，而在Unity中通常意味着帧更新。就像是：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C# script example</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleScript</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> GUIText scoreBoard;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">string</span> scoreText = <span class="string">&quot;Score: &quot;</span> + score.ToString();</span><br><span class="line">        scoreBoard.text = scoreText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//JS script example</span></span><br><span class="line"><span class="keyword">var</span> scoreBoard: GUIText;</span><br><span class="line"><span class="keyword">var</span> score: <span class="built_in">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">Update</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> scoreText: String = <span class="string">&quot;Score: &quot;</span> + score.ToString();</span><br><span class="line">    scoreBoard.text = scoreText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>…每次调用Update将分配新字符串，并不断生成的新垃圾。大多数情况下，只有当分数变化时才更新文本：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C# script example</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleScript</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> GUIText scoreBoard;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> scoreText;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> score;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> oldScore;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (score != oldScore) &#123;</span><br><span class="line">            scoreText = <span class="string">&quot;Score: &quot;</span> + score.ToString();</span><br><span class="line">            scoreBoard.text = scoreText;</span><br><span class="line">            oldScore = score;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//JS script example</span></span><br><span class="line"><span class="keyword">var</span> scoreBoard: GUIText;</span><br><span class="line"><span class="keyword">var</span> scoreText: String;</span><br><span class="line"><span class="keyword">var</span> score: <span class="built_in">int</span>;</span><br><span class="line"><span class="keyword">var</span> oldScore: <span class="built_in">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">Update</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (score != oldScore) &#123;</span><br><span class="line">        scoreText = <span class="string">&quot;Score: &quot;</span> + score.ToString();</span><br><span class="line">        scoreBoard.text = scoreText;</span><br><span class="line">        oldScore = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当函数返回数组值时，会发生另一个潜在的问题：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C# script example</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleScript</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function"><span class="built_in">float</span>[] <span class="title">RandomList</span>(<span class="params"><span class="built_in">int</span> numElements</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">float</span>[numElements];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; numElements; i++) &#123;</span><br><span class="line">            result[i] = Random.<span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//JS script example</span></span><br><span class="line"><span class="function">function <span class="title">RandomList</span>(<span class="params">numElements: <span class="built_in">int</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">float</span>[numElements];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numElements; i++) &#123;</span><br><span class="line">        result[i] = Random.<span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当创建一个充满值的新数组时，这种函数非常优雅和方便。但是，如果反复调用，那么每次都会分配新的内存。由于数组可能非常大，可用空间可能会迅速消耗，从而导致垃圾收集频繁。避免这个问题的一个方法是利用数组是引用类型的事实。作为参数传递给函数的数组可以在该函数内修改，结果将在函数返回后保留。<br>像上面这样的功能通常可以被替换成：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C# script example</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleScript</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RandomList</span>(<span class="params"><span class="built_in">float</span>[] arrayToFill</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arrayToFill.Length; i++) &#123;</span><br><span class="line">            arrayToFill[i] = Random.<span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//JS script example</span></span><br><span class="line"><span class="function">function <span class="title">RandomList</span>(<span class="params">arrayToFill: <span class="built_in">float</span>[]</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arrayToFill.Length; i++) &#123;</span><br><span class="line">        arrayToFill[i] = Random.<span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这只是用新值替换数组的现有内容。虽然这需要在调用代码中完成数组的初始分配（这似乎有些不雅），但是在调用该函数时不会产生任何新的垃圾。</p>
<h2 id="主动请求垃圾收集"><a href="#主动请求垃圾收集" class="headerlink" title="主动请求垃圾收集"></a>主动请求垃圾收集</h2><p>如上所述，最好尽量避免分配。然而，鉴于它们不能被完全消除，您可以使用两种主要策略来最大限度地减少其入侵游戏：</p>
<h3 id="小堆垃圾收集快速可频繁收集"><a href="#小堆垃圾收集快速可频繁收集" class="headerlink" title="小堆垃圾收集快速可频繁收集"></a>小堆垃圾收集快速可频繁收集</h3><p>这个策略通常最适合长期游戏的游戏，其中平滑的帧速率是主要的关注点。这样的游戏通常会频繁地分配小块，但这些块将仅在短时间内使用。在iOS上使用此策略时，典型的堆大小约为200KB，iPhone 3G上的垃圾收集大约需要5ms。如果堆增加到1MB，则收集大约需要7ms。因此，有时候可以以规则的帧间隔请求垃圾回收。这通常会使垃圾收集发生的次数比严格的需要的更多，但是它们将被快速处理，对游戏的影响最小：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Time.frameCount % <span class="number">30</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   System.GC.Collect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，您应该谨慎使用此技术，并检查profiler统计信息，以确保它真正减少了游戏的收集时间。</p>
<h3 id="大堆垃圾收集缓慢且不可频繁收集"><a href="#大堆垃圾收集缓慢且不可频繁收集" class="headerlink" title="大堆垃圾收集缓慢且不可频繁收集"></a>大堆垃圾收集缓慢且不可频繁收集</h3><p>这个策略对于分配（和因此收集）相对不频繁并可以在游戏暂停期间处理的游戏最适用。对于堆来说，尽可能大，而不是因为系统内存太少而导致操作系统杀死你的应用程序。但是，如果可能，Mono运行时会自动避免扩展堆。您可以通过在启动期间预先分配一些占位符空间来手动扩展堆（即，您实例化一个纯粹用于对内存管理器产生影响的“无用”对象）：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C# script example</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleScript</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> tmp = <span class="keyword">new</span> System.Object[<span class="number">1024</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// make allocations in smaller blocks to avoid them to be treated in a special way, which is designed for large blocks</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">            tmp[i] = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// release reference</span></span><br><span class="line">        tmp = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//JS script example</span></span><br><span class="line"><span class="function">function <span class="title">Start</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="keyword">new</span> System.Object[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make allocations in smaller blocks to avoid them to be treated in a special way, which is designed for large blocks</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i : <span class="built_in">int</span> = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">        tmp[i] = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release reference</span></span><br><span class="line">        tmp = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个足够大的堆不应该在游戏中的暂停期间完全被填满，这样可以容纳一次收集。当发生这样的暂停时，您可以显式地请求垃圾收集：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.GC.Collect();</span><br></pre></td></tr></table></figure>
<p>同样，在使用此策略时应该小心，并注意Profiler统计数据，而不是仅仅假定它具有所期望的效果。</p>
<h2 id="可重复使用的对象池"><a href="#可重复使用的对象池" class="headerlink" title="可重复使用的对象池"></a>可重复使用的对象池</h2><p>很多情况下，只要减少创建和销毁对象的数量，就可以避免生成垃圾。游戏中存在着某些类型的物体，如抛射体，尽管一次只会有少量的物体在游戏中，但它们可能会被反复地遇到。在这种情况下，常常可以重用对象，而不是破坏旧对象，并用新的对象替换它们。</p>
<h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p>内存管理是一个微妙而复杂的课题，它已经投入了大量的学术研究。如果您有兴趣了解更多信息，那么<span class="exturl" data-url="aHR0cDovL3d3dy5tZW1vcnltYW5hZ2VtZW50Lm9yZy8=">memorymanagement.org<i class="fa fa-external-link-alt"></i></span>是一个很好的资源，列出了许多出版物和在线文章。有关对象池的更多信息可以在<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT2JqZWN0X3Bvb2xfcGF0dGVybg==">维基百科页面<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9zb3VyY2VtYWtpbmcuY29tL2Rlc2lnbl9wYXR0ZXJucy9vYmplY3RfcG9vbA==">Sourcemaking.com<i class="fa fa-external-link-alt"></i></span>上找到。</p>
<blockquote>
<p>原文链接：<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9VbmRlcnN0YW5kaW5nQXV0b21hdGljTWVtb3J5TWFuYWdlbWVudC5odG1s">Understanding Automatic Memory Management<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>技术翻译</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title>「重构：改善代码的既有设计」读书笔记</title>
    <url>/post/%E3%80%8C%E9%87%8D%E6%9E%84%EF%BC%9A%E6%94%B9%E5%96%84%E4%BB%A3%E7%A0%81%E7%9A%84%E6%97%A2%E6%9C%89%E8%AE%BE%E8%AE%A1%E3%80%8D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="重构的几种情况"><a href="#重构的几种情况" class="headerlink" title="重构的几种情况"></a>重构的几种情况</h2><ol>
<li>代码块俞小，代码的功能就俞容易管理，代码的处理和移动也就俞轻松。（功能也就越单一）</li>
<li>任何不会被修改的变量都可以被当成参数传入新的函数，至于会被修改的变量需要慎重。如果只有一个变量会被修改，可以把它当做返回值。</li>
<li>绝大多数情况下，函数应该放在它所使用的数据的所属对象内。</li>
<li>最好不要在另一个对象的属性基础上运用switch语句。如果不得不使用，也应该在对象自己的数据上使用，而不是在别人的数据上使用。</li>
<li>使用继承来适当组织类关系后，可以用多态取代switch语句。</li>
</ol>
<h2 id="重构原则"><a href="#重构原则" class="headerlink" title="重构原则"></a>重构原则</h2><ol>
<li>三次法则：第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次在做类似的是，你就应该重构。事不过三，三则重构。</li>
<li>在重构中引入间接层的某些价值：<ul>
<li>允许逻辑共享</li>
<li>分开解释意图和实现</li>
<li>隔离变化</li>
<li>封装条件逻辑</li>
</ul>
</li>
<li>封装条件逻辑。对象有一种奇妙的机制：多态消息，可以灵活而清晰地表达条件逻辑。将条件逻辑转化为消息形式，往往能降低代码的重复、增加清晰度并提高弹性。</li>
</ol>
<h2 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h2><ol>
<li>重复代码：设法合二为一<ul>
<li>同一个类的两个函数还有相同的表达式，这时需要提炼出重复代码。</li>
<li>两个互为兄弟的子类内含有相同的表达式，可以提炼相同代码，并放到父类中。如果只是代码间相似，并非完全相同，那么可以将相似部分和差异部分拆开，构成单独的函数。然后你可以使用模板方法的设计模式。</li>
<li>如果两个毫不相关的类中出现重复代码，则可以将重复代码提炼成一个函数放到一个独立类中或者只放在某一个类中（总之要放在合适的地方），然后其他类都去调用这个函数。</li>
</ul>
</li>
<li>过长函数<br> 一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。哪怕替换后的函数调用动作比函数自身还长，只要函数名称能够解释其用途，我们也该毫不犹豫的那么做。关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。</li>
<li>过大的类<br> 类内如果有太多代码，也是代码重复、混乱并最终走向死亡的源头。最简单的解决方案是把多余的东西消弭于类内部。如果有五个“百行函数”，它们之间很多代码都相同，那么或许你可以把它们编程五个“十行函数”和十个提炼出来的“双行函数”。</li>
<li>过长参数列：用对象做参数来减少参数个数<ul>
<li>有了对象，就不必把函数需要的所有东西都以参数传递给它了，只需传给它足够的、让函数能从中获得自己需要的东西就行了。函数需要的东西多半可以在函数宿主类中找到。如果将对象传递给函数，大多数修改都将没有必要，因为你很可能只需（在函数内）增加一两条请求，就能得到更多的数据。</li>
<li>这里有一个重要的例外：有时候你明显不希望造成“被调用对象”与“较大对象”间的某种依赖关系。这时候将数据从对象中拆解出来单独作为参数，也很合情合理。</li>
</ul>
</li>
<li>发散式变化：一个类受多种变化的影响<br> 如果某个类经常因为不同的原因在不同的方向上发生变化，发散式变化的坏味道就出现了。针对某一外界变化的所有相应修改，都只应该发生在单一类中，而这个新类内的所有内容都应该反应次变化。</li>
<li>霰弹式修改：一种变化引发多个类相应修改<br> 如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是霰弹式修改。这种情况下，可以把所有需要修改的代码放进同一个类，如果没有合适的类可放，就创造一个。</li>
<li>依恋情节<ul>
<li>对象技术的全部要点在于：这是一种“将数据和对数据的操作行为包装在一起”的技术。</li>
<li>有一种经典的气味是：函数对某个类的兴趣高过对自己所处类的兴趣。这种孺慕之情最通常的焦点便是数据。</li>
<li>处理这种坏味道的原则是：判断哪个类拥有最多被此函数实用的数据，然后就把这个函数和那些数据摆在一起。</li>
<li>最根本的原则是：将总是一起变化的东西放在一块。</li>
</ul>
</li>
<li>数据泥团：总是绑在一起的数据应该拥有属于它们自己的对象<br> 一个好的评判办法是：删掉众多数据中的一项，其他数据有没有因此而失去意义？如果他们不再有意义，这就是一个明确信号：你应该为它们产生一个新对象。</li>
<li>基本类型偏执：将数据组织成有意义的形式，不偏执于基本类型<ul>
<li>对象技术的新手通常不愿意在小任务上运用小对象。</li>
<li>如果你有一组应该总是被放在一起的字段（基本类型的数据），那么可以尝试将这组数据放到一个单独类中变成结构类型的数据</li>
</ul>
</li>
<li>switch语句<br>面向对象程序的一个最明显特征就是：少用switch（或case）语句。从本质上说，switch语句的问题在于重复。面向对象中的多态概念可为此带来优雅的解决办法。</li>
<li>平行继承体系<ul>
<li>如果你发现某个继承体系的类名称前缀和另一个继承体系的类名称前缀完全相同，便是问到了这种坏味道。</li>
<li>消除这种重复性的一般策略是：让一个继承体系的实例引用另一个继承体系的实例。</li>
</ul>
</li>
<li>冗赘类</li>
<li>夸夸其谈未来性<br>当有人说“噢， 我想我们总有一天需要做这件事”，并因而企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了。</li>
<li>令人迷惑的临时字段</li>
<li>过度耦合的消息链</li>
<li>中间人</li>
<li>狎昵关系</li>
<li>异曲同工的类	</li>
<li>不完美的类库</li>
<li>纯稚的数据类<ul>
<li>纯稚的数据类是指：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。</li>
<li>这种类如果get&#x2F;set方法均是public的，则需要引起注意，应该进行适当的封装，而不是全部公有化。</li>
</ul>
</li>
<li>被拒绝的遗赠<br>子类应该继承超类的函数和数据。但如果他们不想或不需要继承所有的函数和数据，则应该为这个子类新建一个兄弟类，把所有用不到的函数和数据放到兄弟类中，他们共享的数据和函数则放到共同的超类中。</li>
<li>过多的注释<ul>
<li>当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余</li>
<li>如果你不知道该做什么的，这才是注释的良好运用时机。</li>
</ul>
</li>
</ol>
<h2 id="重新组织函数"><a href="#重新组织函数" class="headerlink" title="重新组织函数"></a>重新组织函数</h2><ol>
<li>提炼函数<ul>
<li>动机：首先，如果每个函数的粒度都很小，那么函数被服用的机会就更大；其次，这回是高层函数读起来就像一系列注释；再次，如果函数都是细粒度，那么函数的覆写也会更容易些。函数的长度不是问题，关键在于函数名称和函数本体之间的语义距离。如果提炼可以强化代码的清晰度，那么就去做，就算函数名称比提炼出来的代码还长也无所谓。</li>
<li>做法：创造一个新函数，根据这个函数的意图来对它命名（以它“做什么”来命名，而不是以它“怎样做”命名）。</li>
</ul>
</li>
<li>内联函数</li>
<li>内联临时变量</li>
<li>引入解释性变量<br> 将复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。</li>
<li>分解临时变量</li>
<li>移除对参数的赋值</li>
<li>以函数对象取代函数</li>
<li>替换算法</li>
</ol>
<h2 id="在对象之间搬移特性"><a href="#在对象之间搬移特性" class="headerlink" title="在对象之间搬移特性"></a>在对象之间搬移特性</h2><ol>
<li>在对象的设计过程中，“决定把责任放在哪儿”即使不是最重要的事，也是最重要的事之一。</li>
<li>搬移函数</li>
<li>搬移字段</li>
<li>提炼类</li>
<li>将类内联化</li>
<li>隐藏委托关系</li>
<li>移除中间人</li>
<li>引入外加函数</li>
<li>引入本地扩展</li>
</ol>
<h2 id="重新组织数据"><a href="#重新组织数据" class="headerlink" title="重新组织数据"></a>重新组织数据</h2><ol>
<li>自封装字段</li>
<li>以对象取代数据值</li>
<li>将值对象改为引用对象</li>
<li>将引用对象改为值对象<ul>
<li>值对象有一个非常重要的特性：它们应该是不可变的。</li>
<li>定义了equals()，就必须同时定义hashCode()。实现hashCode()有个简单的办法：读取equals()使用的所有字段的hash码，然后对它们进行按位异或（^）操作。</li>
</ul>
</li>
<li>以对象取代数组<blockquote>
<p>小结：用对象替代数组的好处就是就对数组的各种操作都可以封装起来。因此，对于那些需要各种操作的数组，最好封装起来。</p>
</blockquote>
</li>
<li>复制“被监视数据”</li>
<li>将单向关联改为双向关联</li>
<li>将双向关联改为单向关联</li>
<li>以字面常量取代魔法数</li>
<li>封装字段</li>
<li>封装集合</li>
<li>以数据类取代记录</li>
<li>以类取代类型码</li>
<li>以子类取代类型码</li>
<li>以State&#x2F;Strategy取代类型码</li>
<li>以字段取代子类</li>
</ol>
<h2 id="简化条件表达式"><a href="#简化条件表达式" class="headerlink" title="简化条件表达式"></a>简化条件表达式</h2><ol>
<li>分解条件表达式<blockquote>
<p>如果条件表达式中的条件太多太长，则可以把条件抽取成一个函数，增加代码可读性。</p>
</blockquote>
</li>
<li>合并条件表达式<ul>
<li>如果检查条件各不相同，最终行为却一致，就应该使用“逻辑或”和“逻辑与”将他们合并为一个条件表达式。</li>
<li>如果你认为这些检查的确彼此独立，的确不应该被视为同一次检查，那么就不要使用本项重构。</li>
</ul>
</li>
<li>合并重复的条件片段</li>
<li>移除控制标记<br> 适当的运用break语句和continue语句可以取代标志位的使用</li>
<li>以卫语句取代嵌套条件表达式<ul>
<li>卫语句，是指在方法最终返回语句前，加入其它返回语句（return语句）</li>
<li>拆分条件，然后加入适当的卫语句，以减少条件的嵌套层数</li>
<li>将条件反转，然后加入适当的卫语句，以减少条件的嵌套层数</li>
</ul>
</li>
<li>以多态取代条件表达式</li>
<li>引入<code>Null</code>对象</li>
<li>引入断言</li>
</ol>
<h2 id="简化函数调用"><a href="#简化函数调用" class="headerlink" title="简化函数调用"></a>简化函数调用</h2><ol>
<li>函数改名</li>
<li>添加参数</li>
<li>移除参数</li>
<li>将查询函数和修改函数分离</li>
<li>令函数携带参数</li>
<li>以明确函数取代参数</li>
<li>保持对象完整<ul>
<li>有时候，你会将来自同一对象的若干项数据作为参数，传递给某个函数。这样做的问题在于：万一将来被调用的函数需要新的数据项，你就必须查找并修改对此函数的所有调用。如果你把这些数据所属的整个对象传给函数，可以避免这种尴尬的处境，因为被调用函数可以向那个参数对象请求任何它想要的信息。</li>
<li>如果被调用函数使用了来自另一个对象的很多项数据，这可能意味该函数实际上应该被定义在那些数据所属的对象中。</li>
</ul>
</li>
<li>以函数取代参数<ul>
<li>如果函数可以通过其他途径获得参数值，那么它就不应该通过参数取得该值。</li>
<li>过长的参数列会增加程序阅读者的理解难度，因此我们应该尽可能缩短参数列的长度。</li>
</ul>
</li>
<li>引入参数对象<br> 某些参数总是很自然地同时出现，这时，可以用一个对象取代这些参数。</li>
<li>移除设值函数<ul>
<li>类中的某个字段应该在对象创建时被设值，然后就不再改变。这样的字段应该去掉其对应的设值函数。</li>
<li>如果你为某个字段提供了设值函数，这就暗示这个字段值可以被改变。如果你不希望在对象创建之后此字段还有机会被改变，那就不要为它提供设值函数（同时该字段设为<code>final</code>）。这样你的意图会更加清晰，并且可以排除其值被修改的可能性——这种可能性往往是非常大的。</li>
</ul>
</li>
<li>隐藏函数<ul>
<li>不会被其他任何类用到的函数的访问类型应该为<code>private</code>。</li>
<li>尽可能降低所有函数的可见度。</li>
</ul>
</li>
<li>以工厂函数取代构造函数<ul>
<li>在派生子类的过程中以工厂函数取代类型码。</li>
<li>如果要根据类型来创建不同的对象，这些对象有共同的父类，则可以在父类中添加一个工厂函数来创建不同的对象。</li>
</ul>
</li>
<li>封装向下转型<br>如果某个函数返回的对象，需要由函数调用者执行向下转型，则可以将向下转型动作移到函数中。</li>
<li>以异常取代错误码</li>
<li>以测试取代异常</li>
</ol>
<h2 id="处理概括关系"><a href="#处理概括关系" class="headerlink" title="处理概括关系"></a>处理概括关系</h2><ol>
<li><p>字段上移</p>
<ul>
<li>如果两个子类拥有相同的字段，则将该字段移至超类。</li>
<li>如果这些字段是<code>private</code>的，你必须将超类的字段声明为<code>protected</code>，这样子类才能引用它。</li>
</ul>
</li>
<li><p>将函数上移</p>
<ul>
<li>有些函数在各个子类中产生完全相同的结果，则将该函数移至超类。</li>
<li>如果你使用的是一种强类型语言，而待提升函数又调用了一个只出现于子类而未出现于超类的函数，你可以在超类中为被调用函数声明一个抽象函数。</li>
</ul>
</li>
<li><p>构造函数本体上移<br> 如果在各个子类中拥有一些构造函数，并且它们的本体几乎完全一致。那么可以在超类中新建一个构造函数，并在子类构造函数中调用它。</p>
</li>
<li><p>函数下移<br> 如果超类中的某个函数只与部分（而非全部）子类有关，则将这个函数移到相关的那些子类中去。</p>
</li>
<li><p>字段下移<br> 超类中的某个字段只被部分（而非全部）子类用到，则将这个字段移到需要它的那些子类去。</p>
</li>
<li><p>提炼子类<br> 如果类中的某些特性只被某些（而非全部）实例用到，则新建一个子类，将上面所说的那一部分特性移到子类中。</p>
</li>
<li><p>提炼超类<br> 如果两个类有相似特性，则为这两个类建立一个超类，将相同特性移至超类。</p>
</li>
<li><p>提炼接口<br> 如果某各类在不同环境下扮演截然不同的角色，使用接口就是个好主意。</p>
</li>
<li><p>折叠继承体系<br> 如果超类和子类之间无太大区别，则将它们合为一体。</p>
</li>
<li><p>塑造模板函数<br>你有一些子类，其中相应的某些函数以相同的顺序执行类似的操作，但各个操作的细节上有所不同。将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。</p>
</li>
<li><p>以委托取代继承</p>
</li>
<li><p>以继承取代委托</p>
</li>
</ol>
<h2 id="大型重构"><a href="#大型重构" class="headerlink" title="大型重构"></a>大型重构</h2><ol>
<li>梳理并分解继承体系<ul>
<li>如果某个继承体系同时承担两项责任，则可以建立两个继承体系，并通过委托关系让其中一个可以调用另一个。</li>
<li>要指出继承体系是否承担了两项不同的责任并不困难：如果继承体系中的某一特定层级上的所有类，其子类名称都以相同的形容词开始，那么这个体系可能就是承担着两项不同的责任。</li>
</ul>
</li>
<li>将过程化设计转化为对象设计</li>
<li>将领域和表述&#x2F;显示分离<br> 某些GUI类之中包含了领域逻辑，将领域逻辑分离出来，为它们建立独立的领域类。</li>
<li>提炼继承体系<br> 如果你有某个类做了太多工作，其中一部分工作是以大量条件表达式完成的，那么可以建立继承体系，以一个子类表示一种特殊情况。</li>
</ol>
<h2 id="重构，复用与现实"><a href="#重构，复用与现实" class="headerlink" title="重构，复用与现实"></a>重构，复用与现实</h2><ol>
<li>现实的检验</li>
<li>为什么开发者不愿意重构他们的程序</li>
<li>再论现实检验</li>
<li>重构的资源和参考资料</li>
<li>从重构联想到软件复用和技术传播</li>
</ol>
<h2 id="重构工具"><a href="#重构工具" class="headerlink" title="重构工具"></a>重构工具</h2><ol>
<li>使用工具进行重构</li>
<li>重构工具的技术标准</li>
<li>重构工具的实用标准</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地达成目的，那就先重构那个程序，使特性的添加比较容易进行，然后再添加新特性。</li>
<li>重构前，先检查自己是否有一套可靠的测试机制。这些测试必须有自我检验能力。</li>
<li>重构技术就是以微小的步伐修改程序。如果你犯下错误，很容易便可发现它。</li>
<li>任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀程序员。</li>
<li>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。</li>
<li>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</li>
<li>事不过三，三则重构</li>
<li>不要过早发布接口。请修改你的代码所有权政策，使重构更顺畅。</li>
<li>当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。</li>
<li>确保所有测试都完全自动化，让它们检查自己的测试结果。</li>
<li>一套测试就是一个强大的<code>bug</code>侦测器，能够大大缩减查找<code>bug</code>所需要的时间。</li>
<li>频繁地运行测试。每次编译请把测试也考虑进去——每天至少执行每个测试一次。</li>
<li>每当你收到<code>bug</code>报告，请先写一个单元测试来暴露这只<code>bug</code>。</li>
<li>编写未臻完善的测试并实际运行，好过对完美测试的无尽等待。</li>
<li>考虑可能出错的边界条件，把测试火力集中在那儿。</li>
<li>当事情被大家认为应该会出错时，别忘了检查是否抛出了预期的异常。</li>
<li>不要因为测试无法捕捉所有<code>bug</code>就不写测试，因为测试的确可以捕捉到大多数<code>bug</code>。</li>
</ol>
<blockquote>
<p>对于比较简单或者笔者暂时还没有很好理解的部分，只是一笔带过；而对于笔者在工作中遇到过相似问题的地方，则摘录地比较详细。「重构：改善代码的既有设计」一书非常经典，需要阅读、实践、再阅读、再实践。如果你也是一个注重代码简洁、美观和高效的程序员，那么这本书一定不能错过，深入阅读一定能提升代码的质量。本文会在后续继续更新完善，剔除简单和不常用的部分，完善和保留实用的部分。</p>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用Github版本控制非Github库</title>
    <url>/post/%E5%A6%82%E4%BD%95%E7%94%A8Github%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E9%9D%9EGithub%E5%BA%93/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/github_logo.jpg" alt="GitHub Logo"></p>
<p>Git的图形化客户端有很多，不同的人可能习惯用不同的客户端。本人更习惯于Github的客户端，因为上Github比较多，同步代码到Github用官方的客户端是最方便的，所以也就更习惯于使用Github的客户端。最近，工作中要用Git进行项目的版本控制，为了迎合团队中喜欢使用图形界面的同事，我研究发现居然可以使用Github客户端同步代码到非Github代码库。</p>
<p><strong>一、Github安装</strong></p>
<hr>
<p>去<span class="exturl" data-url="aHR0cHM6Ly9kZXNrdG9wLmdpdGh1Yi5jb20v">Github官网<i class="fa fa-external-link-alt"></i></span>下载GitHub的客户端安装程序，安装的过程没啥好说的。</p>
<p><strong>二、同步远程仓库</strong></p>
<hr>
<p>客户端安装完后，Win 7桌面会产生GitHub和Git Shell两个图标。先打开Git Shell，然后在命令行使用<code>git clone</code>或者<code>git remote add origin</code>命令同步远程仓库。对Git命令不太熟悉的朋友可以参考我的另一篇文章<span class="exturl" data-url="aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wL2RiMzM5NjQ3NGI5Ng==">Git快速入门<i class="fa fa-external-link-alt"></i></span>.</p>
<p><strong>三、在Github客户端添加本地仓库</strong></p>
<hr>
<p>打开桌面的GitHub后，点击左上角的加号，选择Add选项，然后点Browse按钮找到本地仓库，最后Add repository。这样就把本地仓库添加到了Github客户端，就可以使用在客户端里进行Git的各种操作了。如果对Github不熟悉的朋友，可以看看知乎的<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMDcwMDY1">怎样使用 GitHub<i class="fa fa-external-link-alt"></i></span>这个话题。</p>
<p><strong>四、Github客户端配置</strong></p>
<hr>
<p>点击Github窗口右上角的齿轮设置按钮，选择Repository settings后，在Ignored files的文本框中编写脚本忽略不想上传的文件。因为笔者从事Unity开发的工作，所以Ignore文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># =============== #</span><br><span class="line"># Unity generated #</span><br><span class="line"># =============== #</span><br><span class="line">Temp/</span><br><span class="line">Library/</span><br><span class="line"></span><br><span class="line"># =============================================== #</span><br><span class="line"># Visual Studio / MonoDevelop / VS Code generated #</span><br><span class="line"># =============================================== #</span><br><span class="line">ExportedObj/</span><br><span class="line">obj/</span><br><span class="line">*.svd</span><br><span class="line">*.userprefs</span><br><span class="line">/*.csproj</span><br><span class="line">*.pidb</span><br><span class="line">*.suo</span><br><span class="line">/*.sln</span><br><span class="line">*.user</span><br><span class="line">*.unityproj</span><br><span class="line">*.booproj</span><br><span class="line">.vs/</span><br><span class="line">.vscode/</span><br><span class="line"></span><br><span class="line"># =============== #</span><br><span class="line"># Other generated #</span><br><span class="line"># =============== #</span><br><span class="line">.svn/</span><br><span class="line">*.apk</span><br><span class="line"></span><br><span class="line"># ============ #</span><br><span class="line"># OS generated #</span><br><span class="line"># ============ #</span><br><span class="line">.DS_Store</span><br><span class="line">.DS_Store?</span><br><span class="line">._*</span><br><span class="line">.Spotlight-V100</span><br><span class="line">.Trashes</span><br><span class="line">ehthumbs.db</span><br><span class="line">Thumbs.db</span><br></pre></td></tr></table></figure>
<p>然后，选择Remote选项，在输入框中填写远程仓库的SSH地址。最后记得点OK保存。</p>
<p><strong>五、Commit的日志格式</strong></p>
<hr>
<p>我把Commit的情况分成四种：add、del、mod、fix。add表示添加一个feature或者一个文件；del(delete)表示删除文件；mod(modify)表示修改文件；fix表示修复一个bug。Summary的格式是add xxx，Description中如果有多条可以分条列出。用add举个例子，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add xxx</span><br><span class="line">1. xxx</span><br><span class="line">2. xxx</span><br></pre></td></tr></table></figure>

<p><strong>六、学习资料推荐</strong></p>
<hr>
<ol>
<li><a href="http://stackoverflow.com/questions/2785640/optimizing-iphone-opengl-es-fill-rate"><span class="exturl" data-url="aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODIyNTEyNi9ob3ctdG8tdXNlLWdpdC1mb3ItdW5pdHktc291cmNlLWNvbnRyb2w=">How to use Git for Unity source control?<i class="fa fa-external-link-alt"></i></span></a></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL05ldU9ML25ldW9sYS1sZWdhY3kvd2lraS9HaXRodWIlRTQlQkQlQkYlRTclOTQlQTglRTYlOEMlODclRTUlOEQlOTc=">Github使用指南<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<blockquote>
<p>如果本文有错误之处还请帮忙指出。</p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>快速上手Unity原生Json库</title>
    <url>/post/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BUnity%E5%8E%9F%E7%94%9FJson%E5%BA%93/</url>
    <content><![CDATA[<p>现在新版的Unity（印象中是从5.3开始）已经提供了原生的Json库，以前一直使用LitJson，研究了一下Unity用的JsonUtility工具类的使用，发现使用还挺方便的，所以打算把项目中的Json库换成Unity原生的。在Unity3D开发中Json有什么用呢？下面就来说说Json在Unity中的使用。</p>
<p><strong>一、Json有什么用？</strong></p>
<hr>
<p>Json在Unity中还是挺常用的一种数据格式的。那么，在Unity开发中哪些地方会用到Json呢？我相信没有太多编程经验的人肯定对这个问题比较感兴趣。在Unity中，有三种情况下会用到Json：</p>
<ol>
<li>跟服务器进行数据交互</li>
<li>配置文件</li>
<li>跟Android&#x2F;iOS数据交互<br>目前这三种情况在我们项目中都用到了，搞明白了Json怎么用，这些都很简单，在这里就不赘述了，直接进入正题。</li>
</ol>
<p><strong>二、Json怎么用？</strong></p>
<hr>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JsonExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 序列化</span></span><br><span class="line">        MyZone myZone = <span class="keyword">new</span> MyZone();</span><br><span class="line">        myZone.blogUrl = <span class="string">&quot;https://davidsheh.github.io/&quot;</span>;</span><br><span class="line">        myZone.blogName = <span class="string">&quot;Sheh伟伟的个人博客&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Blog blog = <span class="keyword">new</span> Blog();</span><br><span class="line">        blog.url = <span class="string">&quot;http://davidsheh.github.io/post/快速上手Unity原生Json库/&quot;</span>;</span><br><span class="line">        blog.name = <span class="string">&quot;快速上手Unity原生Json库&quot;</span>;</span><br><span class="line">        blog.time = DateTime.Now.ToString(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        myZone.blog = blog;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> json = JsonUtility.ToJson(myZone);</span><br><span class="line">        Debug.Log(json);</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 反序列化</span></span><br><span class="line">        <span class="built_in">string</span> blogStr = Resources.Load&lt;TextAsset&gt;(<span class="string">&quot;MyZone&quot;</span>).text;</span><br><span class="line">        myZone = JsonUtility.FromJson&lt;MyZone&gt;(blogStr);</span><br><span class="line">        Debug.Log(myZone.ToString());</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyZone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 博客主页地址</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> blogUrl;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 博客名</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> blogName;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 本篇博客</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> Blog blog;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.Format(<span class="string">&quot;blogUrl:&#123;0&#125;, blogName:&#123;1&#125;, blog:&#123;2&#125;&quot;</span>, blogUrl, blogName, blog.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 文章名称</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 本篇博客链接</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> url;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 博客发表时间</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.Format(<span class="string">&quot;&lt;name:&#123;0&#125;, url:&#123;1&#125;, time:&#123;2&#125;&gt;&quot;</span>, name, url, time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Json文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;blogUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://davidsheh.github.io/&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;blogName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Sheh伟伟的个人博客&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;blog&quot;</span><span class="punctuation">:</span> </span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;快速上手Unity原生Json库&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot; http://davidsheh.github.io/post/快速上手Unity原生Json库/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2016-09-27&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>三、性能怎么样？</strong></p>
<hr>
<p><span class="exturl" data-url="aHR0cDovL2phY2tzb25kdW5zdGFuLmNvbS9hcnRpY2xlcy8zMzAz">More JSON Performance Benchmarks<i class="fa fa-external-link-alt"></i></span>这篇文章里详细对比分析了JsonUtility、LitJson和Newtonsoft.Json三种方式的序列化和反序列化的性能。<br>总的来说，JsonUtility在综合表现上要略胜一筹。</p>
<p><strong>四、注意事项</strong></p>
<hr>
<p>经过测试发现JsonUtility不支持序列化DateTime、Dictionary和Hashtable，其他类型暂时还没有测试，有兴趣的可以自行测试。</p>
<p><strong>五、参考资料</strong></p>
<hr>
<p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL1NjcmlwdFJlZmVyZW5jZS9Kc29uVXRpbGl0eS5odG1s">Unity API<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5qc29uLm9yZy9qc29uLXpoLmh0bWw=">介绍 JSON<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>如果本文有错误之处还请帮忙指出。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title>最好用的Unity版本控制工具</title>
    <url>/post/%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84Unity%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>自从来到现在的公司，负责Unity组开发以来，尝试了各种版本控制工具。从一开始的TortoiseSVN，到后来为了追求逼格使用Git，尝试了Github客户端和SourceTree，发现都有各种不爽。最后，发现还是Unity的亲儿子Asset Asset Server最好使，服务器配置傻瓜化，还集成到了Unity编辑器。</p>
<p><strong>一、Asset Server安装</strong></p>
<hr>
<p>去<span class="exturl" data-url="aHR0cHM6Ly91bml0eTNkLmNvbS9jbi91bml0eS90ZWFtLWxpY2Vuc2U=">Unity官网<i class="fa fa-external-link-alt"></i></span>下载Unity资源服务器，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/unity_assetserver_1.jpg"><br>Windows版下载后安装很简单，安装过程中会弹出的账号密码对话框，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/unity_assetserver_2.jpg"><br>填写完账号密码后，会弹出控制面板，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/unity_assetserver_3.jpg"><br>Asset Server启动起来了就可以关掉，程序会在后台继续运行。</p>
<p><strong>二、Asset Server配置</strong></p>
<hr>
<p>用Unity在服务器电脑上新建一个空的项目，然后选择Edit -&gt; Project Settings -&gt; Editor打开Editor Settings，Version Control项选择Asset Server，如下图：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/unity_assetserver_4.jpg"></p>
<p>接着选择Window -&gt; Version Control打开Version Control，如下图：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/unity_assetserver_5.jpg"></p>
<p>点击Administration按钮，然后在ServerAddress中输入localhost，接着输入用户名和密码，点击Connect。如下图：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/unity_assetserver_6.jpg"></p>
<p>点击界面右边的Create按钮创建一个项目，然后就在Server视图的左下角会显示创建的项目。选中该项目，然后点击New User按钮创建允许访问的成员的信息，成员创建好了后，还必须勾选，没有勾选的不能访问该项目。如下图：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/unity_assetserver_7.jpg"></p>
<p>到此，服务器配置就完成了。只要知道服务器的IP地址和Asset Server的用户名密码就可以在其他电脑上管理资源服务器。</p>
<p><strong>三、连接Asset Server</strong></p>
<hr>
<p>服务器配置完了，那么项目的其他成员如何连接服务器进行代码同步呢？<br>项目的其他成员可以在自己电脑上先建一个空项目，然后将Version Control也设置成Asset Server，接着选择Window -&gt; Version Control打开Server面板。点击Connection按钮，然后输入Server的IP地址和为改成员创建的用户名密码，点击Show Projects或者输入Project Name后，接着点击Connect，这样就连接上了服务器。如下图：<br><img src="https://cdn.jsdelivr.net/gh/DavidSheh/BlogPictures/pictures/unity_assetserver_8.jpg"></p>
<p>时间紧迫，就写这么多吧，以后有必要再接着写代码的同步流程以及代码的对比工具。</p>
<p><strong>四、参考资料</strong></p>
<hr>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9TZXR0aW5ndXB0aGVBc3NldFNlcnZlci5odG1s">Setting up the Asset Server<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnVuaXR5M2QuY29tL01hbnVhbC9Bc3NldFNlcnZlci5odG1s">Asset Server (Team License)<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<blockquote>
<p>如果本文有错误之处还请帮忙指出。</p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
</search>
