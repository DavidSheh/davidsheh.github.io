<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sheh伟伟的博客</title>
  
  <subtitle>Attitude is a little thing that makes a big difference</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://davidsheh.github.io/"/>
  <updated>2018-01-20T08:18:32.000Z</updated>
  <id>http://davidsheh.github.io/</id>
  
  <author>
    <name>Sheh伟伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「翻译」Unity中的AssetBundle详解（六）</title>
    <link href="http://davidsheh.github.io/2017/09/24/%E3%80%8C%E7%BF%BB%E8%AF%91%E3%80%8DUnity%E4%B8%AD%E7%9A%84AssetBundle%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://davidsheh.github.io/2017/09/24/「翻译」Unity中的AssetBundle详解（六）/</id>
    <published>2017-09-24T13:35:06.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h2><p>本节介绍通常在使用 AssetBundles 的项目中出现的几个问题。</p><h3 id="Asset-重复"><a href="#Asset-重复" class="headerlink" title="Asset 重复"></a>Asset 重复</h3><p>当对象被构建到 AssetBundle 中时，Unity 5 的 AssetBundle 系统会发现对象的所有依赖关系。这是使用资产数据库完成的。此依赖关系信息用于确定将包含在 AssetBundle 中的对象集。明确分配给 AssetBundle 的对象只会内置到该 AssetBundle 中。当对象的 AssetImporter 的 assetBundleName 属性设置为非空字符串时，对象将被“显式分配”。在 AssetBundle 中未明确分配的任何对象将包含在所有的 AssetBundles 中，这些 AssetBundles 含有1个或多个引用未标记对象的对象。<br>如果两个不同的对象分配给两个不同的 AssetBundles，但都有一个公共依赖对象的引用，则该依赖对象将被复制到两个 AssetBundles 中。重复的依赖关系也将被实例化，这意味着依赖对象的两个副本将被视为具有不同标识符的不同对象。这将增加应用程序的 AssetBundles 的总大小。如果应用程序加载其父对象，这也将导致将两个不同的对象副本加载到内存中。</p><p>有几种方法来解决这个问题：</p><ol><li><p>确保内置到不同AssetBundles中的对象不共享依赖关系。任何共享依赖关系的对象都可以放置在相同的AssetBundle中，而不会重复它们的依赖关系。</p><ul><li>这种方法通常对于具有许多共享依赖关系的项目是不可行的。它可以生成碎片的AssetBundles，以至于必须频繁地重新构建和重新下载，而不方便和高效。</li></ul></li><li><p>AssetBundles 切片，以便不会同时加载共享依赖的两个 AssetBundles。</p><ul><li>这种方法可能适用于某些类型的项目，例如基于关卡的游戏。然而，它仍然不必要地增加了项目的AssetBundles的大小，并且增加了构建时间和加载时间。</li></ul></li><li><p>确保所有依赖资产都内置在自己的 AssetBundles 中。这完全消除了重复资产的风险，但也引起了复杂性。应用程序必须跟踪 AssetBundles 之间的依赖关系，并确保在调用任何 <code>AssetBundle.LoadAsset</code> API 之前加载正确的 AssetBundles。</p></li></ol><p>在 Unity 5 中，通过位于 UnityEditor 命名空间中的 AssetDatabase API 跟踪对象依赖关系。正如命名空间所暗示的，此 API 仅在 Unity 编辑器中可用，而不在运行时可用。 <code>AssetDatabase.GetDependencies</code> 可用于查找特定对象或资产的所有直接依赖关系。请注意，这些依赖关系可能有自己的依赖关系。此外，AssetImporter API 可用于查询分配给任何特定对象的 AssetBundle。<br>通过组合 AssetDatabase 和 AssetImporter API，可以编写一个编辑器脚本，以确保将 AssetBundle 的所有直接或间接依赖关系分配给 AssetBundles，或者两个 AssetBundles 没有共享尚未分配给 AssetBundle 的依赖关系。由于重复资产的内存成本，建议所有项目都有这样的脚本。</p><h3 id="精灵图集重复"><a href="#精灵图集重复" class="headerlink" title="精灵图集重复"></a>精灵图集重复</h3><p>以下部分描述了与自动生成的精灵图集结合使用时，Unity 5 的资产依赖关系计算代码的一个奇怪癖。任何自动生成的精灵图集将被分配给包含生成精灵图集的 Sprite 对象的 AssetBundle。如果将精灵对象分配给多个 AssetBundles，则 Sprite 图集将不会分配给 AssetBundle，并将被复制。如果 Sprite 对象未分配给 AssetBundle，则 Sprite 图集也将不会分配给 AssetBundle。为了确保精灵地图集不被重复，请检查标记在同一精灵图集中的所有精灵被分配到相同的资产组合。<br>在 Unity 5.2.2p3 及更老版本中，自动生成的精灵地图集将永远不会分配给 AssetBundle。因此，它们将被包含在任何含有其组成中的精灵的任何 AssetBundles 中，以及引用其组成中的精灵的任何 AssetBundles。<br>由于这个问题，强烈建议使用 Unity 的精灵打包程序的所有 Unity 5 项目升级到 Unity 5.2.2p4, 5.3 或任何新版本的Unity。<br>对于无法升级的项目，此问题有两种解决方法：</p><ol><li>简单的：避免使用 Unity 内置的精灵封隔器。由外部工具生成的 Sprite 地图集将是正常的资产，可以正确分配给 AssetBundle。</li><li>困难的：将所有使用自动分配精灵的对象分配给与精灵相同的 AssetBundle。</li></ol><ul><li>这将确保生成的精灵图集不被视为任何其他 AssetBundles 的间接依赖关系，不会被重复。</li><li>该解决方案保留了使用 Unity 的精灵打包程序的工作流程，但是它降低了开发人员将资产分成不同 AssetBundles 的能力，并且在任何参考图集的组件上的任何数据更改时强制重新下载整个精灵图集，即使是图集本身没有变化。</li></ul><h3 id="Android-Textures"><a href="#Android-Textures" class="headerlink" title="Android Textures"></a>Android Textures</h3><p>由于 Android 生态系统中的设备配置差距严重，通常需要将纹理压缩成几种不同的格式。虽然所有 Android 设备都支持 ETC1，但 ETC1 不支持Alpha通道的纹理。应用程序不需要 OpenGL ES 2 的支持，解决问题的最简单的方法是使用所有Android OpenGL ES 3设备支持的 ETC2。<br>大多数应用程序需要在不支持 ETC2 的旧设备上运行。解决这个问题的一种方法是使用 Unity 5 的 AssetBundle 变体。 （有关其他选项的详细信息，请参阅 Unity 的 Android 优化指南。）要使用 AssetBundle 变体，使用 ETC1 不能被干净压缩的所有纹理必须与纹理唯一的 AssetBundles 隔离。接下来，使用供应商特定的纹理压缩格式（如 DXT5，PVRTC 和 ATITC），创建足够的这些 AssetBundles 变体来支持 Android 生态系统的非 ETC2 功能片段。对于每个 AssetBundle 变体，将包含的纹理的 TextureImporter 设置更改为适用于 Variant 的压缩格式。<br>在运行时，可以使用 <a href="http://docs.unity3d.com/ScriptReference/SystemInfo.SupportsTextureFormat.html?_ga=1.141687282.1751468213.1479139860" target="_blank" rel="noopener">SystemInfo.SupportsTextureFormat</a> API 检测不同纹理压缩格式的支持。该信息应用于选择并加载包含受支持格式压缩的纹理的 AssetBundle 变体。有关 Android 纹理压缩格式的更多信息，请点击<a href="http://developer.android.com/guide/topics/graphics/opengl.html#textures" target="_blank" rel="noopener">此处</a>。</p><h3 id="iOS-文件句柄过度使用"><a href="#iOS-文件句柄过度使用" class="headerlink" title="iOS 文件句柄过度使用"></a>iOS 文件句柄过度使用</h3><p>以下部分中描述的问题已在 Unity 5.3.2p2 中修复。 Unity 的当前版本不受此问题的影响。在 Unity 5.3.2p2 之前的版本中，Unity 将在 AssetBundle 加载的整个时间内为 AssetBundle 保留打开的文件句柄。这在大多数平台上不是问题。但是，iOS 限制进程可能同时打开 255 的文件句柄数。如果加载 AssetBundle 超出此限制，将导致加载失败，并显示 “Too Many Open File Handles” 错误。对于试图将其内容分成数百或数千个资产分类的项目，这是一个常见的问题。对于无法升级到 Unity 修补版本的项目，临时解决方案有：</p><ul><li>通过合并相关的AssetBundles减少使用的AssetBundles数量</li><li>使用 AssetBundle.Unload（false）关闭 AssetBundle 的文件句柄，并手动管理加载的对象的生命周期</li></ul><h2 id="Unity-的-AssetBundle-浏览器工具"><a href="#Unity-的-AssetBundle-浏览器工具" class="headerlink" title="Unity 的 AssetBundle 浏览器工具"></a>Unity 的 AssetBundle 浏览器工具</h2><p>注意：此工具是 Unity 的标准功能的附加功能。要访问它，你必须从 <a href="https://github.com/Unity-Technologies/AssetBundles-Browser" target="_blank" rel="noopener">GitHub</a> 下载它，并从标准 Unity Editor 的下载和安装中单独安装。该工具使用户能够查看和编辑其 Unity 项目的 AssetBundle 的配置。它能防止创建无效软件包的编辑，并通知你现有软件包的任何问题。它还提供基本的构建功能。使用此工具替代选择资产并在检查器中手动设置其 AssetBundle。它可以放入 5.6 或更高版本的任何 Unity 项目中。它将在 <strong>Window</strong> &gt; <strong>AssetBundle Browser</strong> 中创建一个新的菜单项。Bundle 配置和构建功能在新窗口中分为两个选项卡。<br><img src="https://docs.unity3d.com/uploads/Main/AssetBundles-Browser-0.png" alt=""><br><strong>需要 Unity 版本在 5.6 以上</strong></p><h3 id="用法-——-配置"><a href="#用法-——-配置" class="headerlink" title="用法 —— 配置"></a>用法 —— 配置</h3><p>注意：此实用程序处于预发布状态，因此，我们建议在使用项目之前创建备份。此窗口提供了一个资源管理器界面，用于管理和修改项目中的 AssetBundle。当第一次打开时，该工具将解析后台中的所有 Bundle 数据，缓慢地标记警告或其检测到的错误。它可以与项目保持同步，但不能总是意识到工具之外的活动。要强制快速通过错误检测，或使用外部更改更新工具，请点击左上角的刷新按钮。窗口分为四个部分：Bundle 列表，Bundle 详细信息，资产列表和资产详细信息。<br><img src="https://docs.unity3d.com/uploads/Main/AssetBundles-Browser-1.png" alt=""></p><blockquote><p>原文链接：</p><ol><li><a href="https://docs.unity3d.com/Manual/AssetBundles-Troubleshooting.html" target="_blank" rel="noopener">Troubleshooting</a></li><li><a href="https://docs.unity3d.com/Manual/AssetBundles-Browser.html" target="_blank" rel="noopener">Unity Asset Bundle Browser tool</a></li></ol><hr><p><strong>同系列文章</strong></p></blockquote><p><a href="http://davidsheh.github.io/2017/07/14/「翻译」Unity中的AssetBundle详解（一）/">「翻译」Unity中的AssetBundle详解（一）</a></p><p><a href="http://davidsheh.github.io/2017/08/13/「翻译」Unity中的AssetBundle详解（二）/">「翻译」Unity中的AssetBundle详解（二）</a></p><p><a href="http://davidsheh.github.io/2017/08/21/「翻译」Unity中的AssetBundle详解（三）/">「翻译」Unity中的AssetBundle详解（三）</a></p><p><a href="http://davidsheh.github.io/2017/09/17/「翻译」Unity中的AssetBundle详解（四）/">「翻译」Unity中的AssetBundle详解（四）</a> </p><p><a href="http://davidsheh.github.io/2017/09/23/「翻译」Unity中的AssetBundle详解（五）/">「翻译」Unity中的AssetBundle详解（五）</a> </p><p><a href="http://davidsheh.github.io/2017/09/24/「翻译」Unity中的AssetBundle详解（六）/">「翻译」Unity中的AssetBundle详解（六）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;故障排除&quot;&gt;&lt;a href=&quot;#故障排除&quot; class=&quot;headerlink&quot; title=&quot;故障排除&quot;&gt;&lt;/a&gt;故障排除&lt;/h2&gt;&lt;p&gt;本节介绍通常在使用 AssetBundles 的项目中出现的几个问题。&lt;/p&gt;
&lt;h3 id=&quot;Asset-重复&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="技术翻译" scheme="http://davidsheh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Unity3D" scheme="http://davidsheh.github.io/tags/Unity3D/"/>
    
      <category term="AssetBundle" scheme="http://davidsheh.github.io/tags/AssetBundle/"/>
    
  </entry>
  
  <entry>
    <title>「翻译」Unity中的AssetBundle详解（五）</title>
    <link href="http://davidsheh.github.io/2017/09/23/%E3%80%8C%E7%BF%BB%E8%AF%91%E3%80%8DUnity%E4%B8%AD%E7%9A%84AssetBundle%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://davidsheh.github.io/2017/09/23/「翻译」Unity中的AssetBundle详解（五）/</id>
    <published>2017-09-23T12:15:24.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AssetBundle-管理器"><a href="#AssetBundle-管理器" class="headerlink" title="AssetBundle 管理器"></a>AssetBundle 管理器</h2><p>AssetBundle Manager 可以在<a href="https://www.assetstore.unity3d.com/en/#!/content/45836" target="_blank" rel="noopener">这里</a>下载，是由 Unity 制作的一种工具，可以使 AssetBundles 更加精简。下载和导入 AssetBundle Manager 软件包不仅添加了一个新的API调用来加载和使用AssetBundles，而且还添加了一些编辑器功能来简化工作流。此功能可以在“资产”菜单选项下找到。此新部分将包含以下选项：</p><h3 id="模拟模式"><a href="#模拟模式" class="headerlink" title="模拟模式"></a>模拟模式</h3><p>启用模拟模式允许 AssetBundle Manager 使用 AssetBundles，但不需要实际构建捆绑包。编辑器会看到 Assets 已分配给 AssetBundles，并直接使用 Assets ，而不是实际上从 AssetBundle 中提取 Assets。<br>使用模拟模式的主要优点是 Assets 可以被修改、更新、添加和删除，而不需要每次重新构建和部署AssetBundles。值得注意的是，AssetBundle 变体不适用于模拟模式。如果你需要使用变体，则你需要使用本地 AssetBundle 服务器。</p><h3 id="本地-AssetBundle-服务器"><a href="#本地-AssetBundle-服务器" class="headerlink" title="本地 AssetBundle 服务器"></a>本地 AssetBundle 服务器</h3><p>AssetBundle Manager 还可以启动一个本地 AssetBundle 服务器，该服务器可用于在编辑器或本地构建（包括移动端）中测试 AssetBundles。获取本地 AssetBundle 服务器工作的规定是必须在项目的根目录中创建一个名为AssetBundles的文件夹，该文件夹与 Assets 文件夹的级别相同。如下图：<br><img src="https://docs.unity3d.com/uploads/Main/AssetBundles-Manager-4.png" alt=""></p><p>创建文件夹后，你需要将 AssetBundles 构建到此文件夹。为此，请从新菜单选项中选择Build AssetBundles。这将为你构建它们到该目录。现在你已经建立了 AssetBundles（或已经决定使用模拟模式），并准备开始加载 AssetBundles。我们来看看 AssetBundle Manager 对我们提供的新的API调用。</p><h4 id="AssetBundleManager-Initialize"><a href="#AssetBundleManager-Initialize" class="headerlink" title="AssetBundleManager.Initialize()"></a>AssetBundleManager.Initialize()</h4><p>此函数加载 AssetBundleManifest 对象。在使用 AssetBundle Manager 开始加载资产之前，你需要调用它。在一个非常简单的例子中，初始化 AssetBundle Manager 可能如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator Start()</span><br><span class="line">&#123;</span><br><span class="line">    yield return StartCoroutine(Initialize());</span><br><span class="line">&#125;</span><br><span class="line">IEnumerator Initialize()</span><br><span class="line">&#123;</span><br><span class="line">    var request = AssetBundleManager.Initialize();</span><br><span class="line">    if (request != null)</span><br><span class="line">        yield return StartCoroutine(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AssetBundle Manager 使用你在 Initialize() 期间加载的清单来帮助幕后的许多功能，包括依赖关系管理。</p><h4 id="Loading-Assets"><a href="#Loading-Assets" class="headerlink" title="Loading Assets"></a>Loading Assets</h4><p>你正在使用 AssetBundle Manager，你已初始化它，现在你可以加载某些资产。我们来看看如何加载 AssetBundle 并从该 Bundle 中实例化一个对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator InstantiateGameObjectAsync (string assetBundleName, string assetName)</span><br><span class="line">&#123;</span><br><span class="line">    // Load asset from assetBundle.</span><br><span class="line">    AssetBundleLoadAssetOperation request = AssetBundleManager.LoadAssetAsync(assetBundleName, assetName, typeof(GameObject));</span><br><span class="line">    if (request == null)</span><br><span class="line">        yield break;</span><br><span class="line">    yield return StartCoroutine(request);</span><br><span class="line">    // Get the asset.</span><br><span class="line">    GameObject prefab = request.GetAsset&lt;GameObject&gt; ();</span><br><span class="line">    if (prefab != null)</span><br><span class="line">        GameObject.Instantiate(prefab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AssetBundle Manager 会异步执行所有的加载操作，因此它返回一个加载操作请求，它在调用 <code>yield return StartCoroutine（request）</code>时加载 Bundle;接着我们需要做的是调用<code>GetAsset&lt;T&gt;()</code> 从 AssetBundle 加载游戏对象。</p><h4 id="Loading-Scenes"><a href="#Loading-Scenes" class="headerlink" title="Loading Scenes"></a>Loading Scenes</h4><p>如果你有一个 AssetBundle 名称分配给场景，并且你需要加载该场景，则需要遵循稍微不同的代码路径。模式是相同的，但有微小的差异。以下是从AssetBundle加载场景的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator InitializeLevelAsync (string levelName, bool isAdditive)</span><br><span class="line">&#123;</span><br><span class="line">    // Load level from assetBundle.</span><br><span class="line">    AssetBundleLoadOperation request = AssetBundleManager.LoadLevelAsync(sceneAssetBundle, levelName, isAdditive);</span><br><span class="line">    if (request == null)</span><br><span class="line">        yield break;</span><br><span class="line">    yield return StartCoroutine(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>正如你所看到的，加载场景也是一个异步的，LoadLevelAsync返回一个加载操作请求，需要传递给一个StartCoroutine 才能加载场景。</p><h4 id="Load-Variants"><a href="#Load-Variants" class="headerlink" title="Load Variants"></a>Load Variants</h4><p>使用 AssetBundle Manager 加载变量实际上并不会改变在场景或资产中加载的代码。所有需要完成的操作都是设置 AssetBundleManager 的 ActiveVariants 属性。ActiveVariants 属性是一个字符串数组。只需构建一个字符串数组，其中包含在将它们分配给资产时创建的变体名称。以下是如何使用 hd 变体加载场景 AssetBundle。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator InitializeLevelAsync (string levelName, bool isAdditive, string[] variants)</span><br><span class="line">&#123;</span><br><span class="line">    //Set the activeVariants.</span><br><span class="line">    AssetBundleManager.ActiveVariants = variants;</span><br><span class="line">    // Load level from assetBundle.</span><br><span class="line">    AssetBundleLoadOperation request = AssetBundleManager.LoadLevelAsync(variantSceneAssetBundle, levelName, isAdditive);</span><br><span class="line">    if (request == null)</span><br><span class="line">        yield break;</span><br><span class="line">    yield return StartCoroutine(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在代码中的其他地方构建的字符串数组（可能是从按钮点击或其他一些情况）中传递的地方。如果可用，则将加载与设置的活动变体相匹配的 Bundles。</p><h2 id="使用-AssetBundles-进行修补"><a href="#使用-AssetBundles-进行修补" class="headerlink" title="使用 AssetBundles 进行修补"></a>使用 AssetBundles 进行修补</h2><p>修补 AssetBundles 与下载新的 AssetBundle 并替换已存在的 AssetBundle 一样简单。如果使用<code>WWW.LoadFromCacheOrDownload</code> 或 <code>UnityWebRequest</code> 来管理应用程序的缓存AssetBundles，则将不同的版本参数传递到所选的 API 将触发下载新的 AssetBundles。补丁系统中更难解决的问题是检测哪个 AssetBundles 需要被替换。补丁系统需要两个信息列表：</p><ul><li>当前下载的 AssetBundles 的列表及其版本信息</li><li>服务器上的 AssetBundles 列表及其版本信息</li></ul><p>修补程序应该下载服务器端 AssetBundles 的列表，并比较 AssetBundle 列表。应该重新下载缺少 AssetBundles 或版本信息已更改的 AssetBundles。还可以编写一个自定义系统来检测对 AssetBundles 的更改。编写自己系统的大多数开发人员都选择使用行业标准的数据格式来存储 AssetBundle 文件列表，例如JSON，以及用一个标准 C# 类来计算校验和，如MD5。Unity 使用确定性方式排序的数据构建 AssetBundles。这允许具有自定义下载器的应用程序实现差分补丁（differential patching）。<br>Unity 不提供用于差分修补的任何内置机制，当使用内置缓存系统时，<code>WWW.LoadFromCacheOrDownload</code> 和 <code>UnityWebRequest</code> 都不会执行差异修补。如果需要进行差分修补，则必须写入自定义下载器。</p><blockquote><p>原文链接：</p><ol><li><a href="https://docs.unity3d.com/Manual/AssetBundles-Manager.html" target="_blank" rel="noopener">AssetBundle Manager</a></li><li><a href="https://docs.unity3d.com/Manual/AssetBundles-Patching.html" target="_blank" rel="noopener">Patching with AssetBundles</a></li></ol><hr><p><strong>同系列文章</strong></p></blockquote><p><a href="http://davidsheh.github.io/2017/07/14/「翻译」Unity中的AssetBundle详解（一）/">「翻译」Unity中的AssetBundle详解（一）</a></p><p><a href="http://davidsheh.github.io/2017/08/13/「翻译」Unity中的AssetBundle详解（二）/">「翻译」Unity中的AssetBundle详解（二）</a></p><p><a href="http://davidsheh.github.io/2017/08/21/「翻译」Unity中的AssetBundle详解（三）/">「翻译」Unity中的AssetBundle详解（三）</a></p><p><a href="http://davidsheh.github.io/2017/09/17/「翻译」Unity中的AssetBundle详解（四）/">「翻译」Unity中的AssetBundle详解（四）</a> </p><p><a href="http://davidsheh.github.io/2017/09/23/「翻译」Unity中的AssetBundle详解（五）/">「翻译」Unity中的AssetBundle详解（五）</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AssetBundle-管理器&quot;&gt;&lt;a href=&quot;#AssetBundle-管理器&quot; class=&quot;headerlink&quot; title=&quot;AssetBundle 管理器&quot;&gt;&lt;/a&gt;AssetBundle 管理器&lt;/h2&gt;&lt;p&gt;AssetBundle Manage
      
    
    </summary>
    
      <category term="技术翻译" scheme="http://davidsheh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Unity3D" scheme="http://davidsheh.github.io/tags/Unity3D/"/>
    
      <category term="AssetBundle" scheme="http://davidsheh.github.io/tags/AssetBundle/"/>
    
  </entry>
  
  <entry>
    <title>「翻译」Unity中的AssetBundle详解（四）</title>
    <link href="http://davidsheh.github.io/2017/09/17/%E3%80%8C%E7%BF%BB%E8%AF%91%E3%80%8DUnity%E4%B8%AD%E7%9A%84AssetBundle%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://davidsheh.github.io/2017/09/17/「翻译」Unity中的AssetBundle详解（四）/</id>
    <published>2017-09-17T13:23:12.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AssetBundle依赖关系"><a href="#AssetBundle依赖关系" class="headerlink" title="AssetBundle依赖关系"></a>AssetBundle依赖关系</h2><p>如果一个或多个UnityEngine.Objects包含位于另一个bundle中的UnityEngine.Object的引用，则AssetBundles可以依赖于其他AssetBundles。如果UnityEngine.Object包含一个在其他任何AssetBundle中都不包含的UnityEngine.Object的引用，则不会发生依赖关系。在这种情况下，在构建AssetBundles时，将bundle所依赖的对象的副本复制到捆绑包中。如果多个bundle中的多个对象包含对未分配给bundle的同一对象的引用，那么对该对象具有依赖关系的每个bundle将各自制作一个该对象的副本并将其打包到内置的AssetBundle中。<br>如果AssetBundle包含依赖关系，则在加载要尝试实例化的对象之前，加载包含这些依赖关系的bundles是重要的。 Unity不会尝试自动加载依赖关系。<br>考虑以下示例，<strong>Bundle 1</strong>中的材料引用了<strong>Bundle 2</strong>中的纹理：<br>在此示例中，加载<strong>Bundle 1</strong>中的Material之前，需要将<strong>Bundle 2</strong>加载到内存中。<strong>Bundle 1</strong>和<strong>Bundle 2</strong>的加载顺序无关紧要，重要的是在从<strong>Bundle 1</strong>加载Material之前加载<strong>Bundle 2</strong>。在下一节中，我们将讨论如何使用在<a href="http://davidsheh.github.io/2017/08/21/「翻译」Unity中的AssetBundle详解（三）/">上一篇博客</a>中所涉及的AssetBundleManifest对象，在运行时确定和加载依赖关系。</p><h2 id="使用本地AssetBundles"><a href="#使用本地AssetBundles" class="headerlink" title="使用本地AssetBundles"></a>使用本地AssetBundles</h2><p>在 Unity 5 中，我们可以使用四种不同的 API 来加载 。它们的行为根据正在加载的平台和 AssetBundles 构建时使用的压缩方式（未压缩，LZMA，LZ4）而有所不同。<br>我们需要用到的四个 API 是：</p><ul><li><a href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadFromMemoryAsync.html?_ga=1.226802969.563709772.1479226228" target="_blank" rel="noopener">AssetBundle.LoadFromMemoryAsync</a></li><li><a href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadFromFile.html?_ga=1.259297550.563709772.1479226228" target="_blank" rel="noopener">AssetBundle.LoadFromFile</a></li><li><a href="https://docs.unity3d.com/ScriptReference/WWW.LoadFromCacheOrDownload.html?_ga=1.226802969.563709772.1479226228" target="_blank" rel="noopener">WWW.LoadfromCacheOrDownload</a></li><li><a href="https://docs.unity3d.com/ScriptReference/Networking.UnityWebRequest.html?_ga=1.259297550.563709772.1479226228" target="_blank" rel="noopener">UnityWebRequest</a>’s <a href="https://docs.unity3d.com/ScriptReference/Networking.DownloadHandlerAssetBundle.html?_ga=1.264500235.563709772.1479226228" target="_blank" rel="noopener">DownloadHandlerAssetBundle </a>(Unity 5.3 或者更高的版本)</li></ul><h3 id="AssetBundle-LoadFromMemoryAsync"><a href="#AssetBundle-LoadFromMemoryAsync" class="headerlink" title="AssetBundle.LoadFromMemoryAsync"></a>AssetBundle.LoadFromMemoryAsync</h3><p><a href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadFromMemoryAsync.html" target="_blank" rel="noopener">AssetBundle.LoadFromMemoryAsync</a><br>此函数使用包含 AssetBundle 数据的字节数组的参数。如果需要也可以传递一个 CRC 值。如果 Bundle 是LZMA 压缩的，它将在加载时解压缩 AssetBundle。 LZ4 压缩的 Bundle 在压缩状态时被加载。<br>以下是使用此方法的一个示例：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">LoadFromMemoryAsync</span>(<span class="params"><span class="keyword">string</span> path</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> createRequest;</span><br><span class="line"></span><br><span class="line">    AssetBundle bundle = createRequest.assetBundle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> prefab = bundle.LoadAsset.&lt;GameObject&gt;(<span class="string">"MyObject"</span>);</span><br><span class="line">    Instantiate(prefab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，这不是唯一可以使用 LoadFromMemoryAsync 的策略。 可以用任何获取所需的字节数组的过程替代<code>File.ReadAllBytes(path)</code> 方法。</p><h3 id="AssetBundle-LoadFromFile"><a href="#AssetBundle-LoadFromFile" class="headerlink" title="AssetBundle.LoadFromFile"></a>AssetBundle.LoadFromFile</h3><p><a href="https://docs.unity3d.com/ScriptReference/AssetBundle.LoadFromFile.html" target="_blank" rel="noopener">AssetBundle.LoadFromFile</a><br>从本地存储加载未压缩的 Bundles 时，此API非常高效。如果 Bundle 是未压缩或块（LZ4）压缩的，LoadFromFile 将直接从磁盘加载 Bundle。使用此方法加载完全压缩（LZMA）的 Bundle 将首先解压缩包，然后再将其加载到内存中。<br>如何使用 <code>LoadFromFile</code> 的一个例子：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoadFromFileExample</span> <span class="title">extends</span> <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function">function <span class="title">Start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> myLoadedAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, <span class="string">"myassetBundle"</span>));</span><br><span class="line">        <span class="keyword">if</span> (myLoadedAssetBundle == <span class="literal">null</span>) &#123;</span><br><span class="line">            Debug.Log(<span class="string">"Failed to load AssetBundle!"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> prefab = myLoadedAssetBundle.LoadAsset.&lt;GameObject&gt;(<span class="string">"MyObject"</span>);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：在使用 Unity 5.3 或更早版本的Android设备上，尝试从 Streaming Assets 路径加载 AssetBundles 时，此API将失效。这是因为该路径的内容将驻留在压缩的 <code>.jar</code> 文件中。 Unity 5.4和更新版本可以使用这个API 加载 Streaming Assets 路径下的资源。</p><h3 id="WWW-LoadFromCacheOrDownload"><a href="#WWW-LoadFromCacheOrDownload" class="headerlink" title="WWW.LoadFromCacheOrDownload"></a>WWW.LoadFromCacheOrDownload</h3><p><a href="https://docs.unity3d.com/ScriptReference/WWW.LoadFromCacheOrDownload.html" target="_blank" rel="noopener">WWW.LoadFromCacheOrDownload</a></p><p><strong>此 API 将被废弃 （请使用 UnityWebRequest） </strong></p><p>此API可用于从远程服务器下载 AssetBundles 或加载本地 AssetBundles。它是 UnityWebRequest API 的较旧且不太理想的版本。<br>从远程位置加载 AssetBundle 将自动缓存 AssetBundle。如果AssetBundle被压缩，那么一个工作线程将自动解压缩该包并将其写入缓存。一旦捆绑包解压缩并缓存，它将像 AssetBundle.LoadFromFile 一样加载。<br>如何使用 <code>LoadFromCacheOrDownload</code> 的一个例子：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoadFromCacheOrDownloadExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IEnumerator <span class="title">Start</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Caching.ready)</span><br><span class="line">                    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> www = WWW.LoadFromCacheOrDownload(<span class="string">"http://myserver.com/myassetBundle"</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> www;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">string</span>.IsNullOrEmpty(www.error))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(www.error);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> myLoadedAssetBundle = www.assetBundle;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> asset = myLoadedAssetBundle.mainAsset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于缓存 AssetBundle 在 WWW 对象中的字节的内存开销，建议使用 WWW.LoadFromCacheOrDownload<br> 的所有开发人员确保其 AssetBundles 保持较小——最多为几兆字节。还建议在限制内存平台（如移动设备）上运行的开发人员确保其代码一次只下载一个 AssetBundle，以避免内存尖峰。<br>如果缓存文件夹没有用于缓存附加文件的空间，LoadFromCacheOrDownload将从缓存中迭代删除最近最少使用的AssetBundle，直到有足够的空间可用于存储新的AssetBundle。如果无法进行空间（因为硬盘已满，或者当前正在使用缓存中的所有文件）释放，LoadFromCacheOrDownload() 将绕过缓存并将文件以流的形式加入内存。<br>为了强制 LoadFromCacheOrDownload，版本参数（第二个参数）将需要更改。如果传递给该函数的版本与当前缓存的AssetBundle的版本匹配，则AssetBundle将仅从缓存加载。</p><h3 id="UnityWebRequest"><a href="#UnityWebRequest" class="headerlink" title="UnityWebRequest"></a>UnityWebRequest</h3><p><a href="https://docs.unity3d.com/ScriptReference/Networking.UnityWebRequest.GetAssetBundle.html" target="_blank" rel="noopener">UnityWebRequest</a></p><p>UnityWebRequest 有一个特定的 API 调用来处理 AssetBundles。首先，你需要使用<br> UnityWebRequest.GetAssetBundle 创建您的 Web 请求。返回请求后，将请求对象传递给<code>DownloadHandlerAssetBundle.GetContent(UnityWebRequest)</code>。此 <code>GetContent</code> 函数调用将返回AssetBundle 对象。<br>你还可以在下载 Bundle 后使用 <a href="https://docs.unity3d.com/ScriptReference/Networking.DownloadHandlerAssetBundle.html" target="_blank" rel="noopener">DownloadHandlerAssetBundle</a> 类中的 <code>assetBundle</code> 属性，以<code>AssetBundle.LoadFromFile</code> 的效率加载 AssetBundle。<br>以下是一个如何加载包含两个 GameObject 的 AssetBundle 并实例化它们的示例。要开始这个过程，我们只需要调用 <code>StartCoroutine(InstantiateObject())</code>;<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">InstantiateObject</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> uri = <span class="string">"file:///"</span> + Application.dataPath + <span class="string">"/AssetBundles/"</span> + assetBundleName;        UnityEngine.Networking.UnityWebRequest request = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(uri, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> request.Send();</span><br><span class="line">    AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);</span><br><span class="line">    GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">"Cube"</span>);</span><br><span class="line">    GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">"Sprite"</span>);</span><br><span class="line">    Instantiate(cube);</span><br><span class="line">    Instantiate(sprite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 UnityWebRequest 的优点是它允许开发人员以更灵活的方式处理下载的数据，并可能消除不必要的内存使用情况。这是 UnityEngine.WWW 类中首选的 API。</p><h4 id="从-AssetBundles-载入资产"><a href="#从-AssetBundles-载入资产" class="headerlink" title="从 AssetBundles 载入资产"></a>从 AssetBundles 载入资产</h4><p>现在，您已经成功下载了 AssetBundle，是时候最终加载某些资产了。<br>通用代码段：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T objectFromBundle = bundleObject.LoadAsset&lt;T&gt;(assetName);</span><br></pre></td></tr></table></figure></p><p><code>T</code> 是尝试加载的资产的类型。<br>决定如何加载资产时，有几种选择。分别是 LoadAsset 、LoadAllAssets 和它们的对应的异步方法 LoadAssetAsync 和 LoadAllAssetsAsync。<br>下面代码展示了如何从AssetBundles同步加载资产：<br>加载单个 GameObject：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GameObject gameObject = loadedAssetBundle.LoadAsset&lt;GameObject&gt;(assetName);</span><br></pre></td></tr></table></figure></p><p>加载所有资产：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unity.Object[] objectArray = loadedAssetBundle.LoadAllAssets();</span><br></pre></td></tr></table></figure></p><p>现在，正如上文所示的方法返回的对象类型或要加载的对象的数组，异步方法返回一个 <a href="https://docs.unity3d.com/ScriptReference/AssetBundleRequest.html" target="_blank" rel="noopener">AssetBundleRequest</a>。访问资产之前，需要等待此操作完成。加载一个 Asset：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AssetBundleRequest request = loadedAssetBundleObject.LoadAssetAsync&lt;GameObject&gt;(assetName);</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> request;</span><br><span class="line"><span class="keyword">var</span> loadedAsset = request.asset;</span><br></pre></td></tr></table></figure></p><p>以及<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AssetBundleRequest request = loadedAssetBundle.LoadAllAssetsAsync();</span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> request;</span><br><span class="line"><span class="keyword">var</span> loadedAssets = request.allAssets;</span><br></pre></td></tr></table></figure></p><p>一旦你加载了你所需要的 Assets，接下来就可以像使用 Unity 中任何其他对象一样使用加载的对象。</p><h4 id="加载-AssetBundle-清单文件（Manifests）"><a href="#加载-AssetBundle-清单文件（Manifests）" class="headerlink" title="加载 AssetBundle 清单文件（Manifests）"></a>加载 AssetBundle 清单文件（Manifests）</h4><p>加载 AssetBundle 清单文件非常有用。特别是在处理 AssetBundle 依赖项时。<br>要获得一个可用的 <a href="https://docs.unity3d.com/ScriptReference/AssetBundleManifest.html" target="_blank" rel="noopener">AssetBundleManifest</a> 对象，你需要加载额外的 AssetBundle（名称与其所在文件夹相同），并从中加载类型为 AssetBundleManifest 的对象。<br>加载清单本身与加载 AssetBundle 中的任何其他资产完全相同：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);</span><br><span class="line">AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(<span class="string">"AssetBundleManifest"</span>);</span><br></pre></td></tr></table></figure></p><p>现在，你可以通过上述示例中的 manifest 对象访问 <code>AssetBundleManifest</code> API 的调用。从这里你可以使用清单来获取有关你所构建的 AssetBundles 的信息。该信息包括 AssetBundles 的依赖关系数据、散列数据和变体数据。</p><p>在前面的部分，当我们讨论 AssetBundle Dependencies 并且如果一个 bundle 对另一个 bundle 有依赖关系，那么在从原始 bundle 加载任何资源之前，需要加载这些 bundle。清单对象使得动态地找到加载依赖性成为可能。假设我们要加载名为 “assetBundle” 的 AssetBundle 的所有依赖项。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);</span><br><span class="line">AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(<span class="string">"AssetBundleManifest"</span>);</span><br><span class="line"><span class="keyword">string</span>[] dependencies = manifest.GetAllDependencies(<span class="string">"assetBundle"</span>); <span class="comment">//Pass the name of the bundle you want the dependencies for.</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">string</span> dependency <span class="keyword">in</span> dependencies)</span><br><span class="line">&#123;</span><br><span class="line">    AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, dependency));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码表示正在加载 AssetBundles、AssetBundle依赖关系和资产，现在是时候讨论管理所有这些加载的 AssetBundles 了。</p><h4 id="管理加载的-AssetBundles"><a href="#管理加载的-AssetBundles" class="headerlink" title="管理加载的 AssetBundles"></a>管理加载的 AssetBundles</h4><p>另请参阅：Unity 官方教程中有关 <a href="https://unity3d.com/fr/learn/tutorials/topics/best-practices/assetbundle-usage-patterns#Managing_Loaded_Assets" target="_blank" rel="noopener">Managing Loaded AssetBundles</a>的教程。</p><p>当它们从活动场景中删除时，Unity不会自动卸载对象。资产清理在特定时间触发，也可以手动触发。知道何时加载和卸载 AssetBundle 很重要。不正确卸载 AssetBundle 可能会导致内存中的对象复制或其他不合要求的情况（如缺少纹理）。<br>了解 AssetBundle 管理最重要的是什么时候调用 <code>AssetBundle.Unload(bool)</code>，并且在函数调用时你应该将 true 或 false 作为参数传递给函数。卸载 AssetBundle 是一个非静态的功能，此 API 卸载正在调用的 AssetBundle 的头部信息。该函数的参数表示是否也卸载从此 AssetBundle 实例化的所有对象。</p><p>如果使用 <code>AssetBundle.Unload(true)</code> 方法，就会卸载从 AssetBundle 中加载的所有对象，即使它们正在当前活动的场景中使用。这正是我们前面提到的，这可能会导致纹理丢失。我们假设材质 M 是从 AssetBundle AB 加载的，如下所示。如果调用 AB.Unload（true）。活动场景中的任何 M 实例也将被卸载和销毁。如果你改为调用 AB.Unload（false），它会破坏当前 M 和 AB 实例的链接。<br><img src="https://docs.unity3d.com/uploads/Main/AssetBundles-Native-1.png" alt=""><br>如果以后再次加载 AB，并调用 AB.LoadAsset()，Unity 将不会将 M 的现有副本重新链接到新加载的材质。那么 M 会加载两个副本。<br><img src="https://docs.unity3d.com/uploads/Main/AssetBundles-Native-2.png" alt=""><br><img src="https://docs.unity3d.com/uploads/Main/AssetBundles-Native-3.png" alt=""></p><p>一般来说，使用 AssetBundle.Unload(false) 并不会导致理想的情况。大多数项目应该使用 AssetBundle.Unload(true) 来避免在内存中复制对象。<br>大多数项目应该使用 AssetBundle.Unload(true) 并采用一种方法来确保对象不被重复。两种常见的方法是：</p><ul><li>在应用程序的生命周期中具有明确定义的地方，卸载临时 AssetBundles，例如关卡之间或加载屏幕期间。</li><li>维护单个对象的引用计数，并仅在其所有组成对象未使用时卸载 AssetBundles。这允许应用程序卸载和重新加载单个对象而没有重复的内存。</li></ul><p>如果应用程序必须使用 AssetBundle.Unload(false)，那么单个对象只能以两种方式卸载：</p><ul><li>在场景和代码中消除对不需要的对象的所有引用。完成之后，调用 <a href="https://docs.unity3d.com/ScriptReference/Resources.UnloadUnusedAssets.html" target="_blank" rel="noopener">Resources.UnloadUnusedAssets</a>。</li><li>使用非叠加式加载场景。这将销毁当前场景中的所有对象并自动调用 <a href="https://docs.unity3d.com/ScriptReference/Resources.UnloadUnusedAssets.html" target="_blank" rel="noopener">Resources.UnloadUnusedAssets</a>。</li></ul><p>如果你不想自己管理加载 AssetBundles、依赖关系和 Assets 本身，你可能会发现自己需要 AssetBundle Manager。</p><blockquote><p>原文链接：</p><ol><li><a href="https://docs.unity3d.com/Manual/AssetBundles-Dependencies.html" target="_blank" rel="noopener">AssetBundle Dependencies</a></li><li><a href="https://docs.unity3d.com/Manual/AssetBundles-Native.html" target="_blank" rel="noopener">Using AssetBundles Natively</a></li></ol></blockquote><hr><p><strong>同系列文章</strong></p><p><a href="http://davidsheh.github.io/2017/07/14/「翻译」Unity中的AssetBundle详解（一）/">「翻译」Unity中的AssetBundle详解（一）</a></p><p><a href="http://davidsheh.github.io/2017/08/13/「翻译」Unity中的AssetBundle详解（二）/">「翻译」Unity中的AssetBundle详解（二）</a></p><p><a href="http://davidsheh.github.io/2017/08/21/「翻译」Unity中的AssetBundle详解（三）/">「翻译」Unity中的AssetBundle详解（三）</a></p><p><a href="http://davidsheh.github.io/2017/09/17/「翻译」Unity中的AssetBundle详解（四）/">「翻译」Unity中的AssetBundle详解（四）</a> </p><p><a href="http://davidsheh.github.io/2017/09/23/「翻译」Unity中的AssetBundle详解（五）/">「翻译」Unity中的AssetBundle详解（五）</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AssetBundle依赖关系&quot;&gt;&lt;a href=&quot;#AssetBundle依赖关系&quot; class=&quot;headerlink&quot; title=&quot;AssetBundle依赖关系&quot;&gt;&lt;/a&gt;AssetBundle依赖关系&lt;/h2&gt;&lt;p&gt;如果一个或多个UnityEngine
      
    
    </summary>
    
      <category term="技术翻译" scheme="http://davidsheh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Unity3D" scheme="http://davidsheh.github.io/tags/Unity3D/"/>
    
      <category term="AssetBundle" scheme="http://davidsheh.github.io/tags/AssetBundle/"/>
    
  </entry>
  
  <entry>
    <title>在 Mac 上配置 C++ 环境</title>
    <link href="http://davidsheh.github.io/2017/09/16/mac-c-env/"/>
    <id>http://davidsheh.github.io/2017/09/16/mac-c-env/</id>
    <published>2017-09-16T14:49:16.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-VSCode-编写-C-程序一步到位"><a href="#使用-VSCode-编写-C-程序一步到位" class="headerlink" title="使用 VSCode 编写 C++ 程序一步到位"></a>使用 VSCode 编写 C++ 程序一步到位</h2><ol><li>安装C/C++插件，请认准微软官方出品</li><li>安装Code Runner插件</li><li>写代码，然后保存</li><li>使用快捷键<code>Ctrl+Alt+N</code>编译并运行代码</li></ol><h2 id="使用-Xcode-强大的-IDE"><a href="#使用-Xcode-强大的-IDE" class="headerlink" title="使用 Xcode 强大的 IDE"></a>使用 Xcode 强大的 IDE</h2><ol><li>打开 Xcode，点 Create a new Xcode project</li><li>选择 macOS -&gt; Command Line Tool</li><li>下一步后，填写项目的基本信息，然后，<code>Language</code> 这一项选择 <code>C++</code></li><li>项目创建完后，点击三角形的按钮就开始编译了</li></ol><h2 id="C-代码在命令行编译并运行的步骤"><a href="#C-代码在命令行编译并运行的步骤" class="headerlink" title="C++ 代码在命令行编译并运行的步骤"></a>C++ 代码在命令行编译并运行的步骤</h2><ol><li>打开终端（⌘ + 空格 输入 Terminal）</li><li>用cd命令切换到程序文件所在目录</li><li>输入命令<code>g++ main.cpp -o main</code>。前一个 <code>main.cpp</code> 表示程序入口函数所在的文件，后一个 <code>main</code> 表示生成可执行文件的名字，如果编译成功的话，就会生成一个名为 main 的可执行文件</li><li>在终端输入<code>./main</code>命令就可以执行看到结果了。<code>./</code>表示当前目录</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用-VSCode-编写-C-程序一步到位&quot;&gt;&lt;a href=&quot;#使用-VSCode-编写-C-程序一步到位&quot; class=&quot;headerlink&quot; title=&quot;使用 VSCode 编写 C++ 程序一步到位&quot;&gt;&lt;/a&gt;使用 VSCode 编写 C++ 程序一步
      
    
    </summary>
    
      <category term="技术笔记" scheme="http://davidsheh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://davidsheh.github.io/tags/C/"/>
    
      <category term="Mac" scheme="http://davidsheh.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Windows 系统的包管理器</title>
    <link href="http://davidsheh.github.io/2017/09/09/windows-chocolatey-scoop/"/>
    <id>http://davidsheh.github.io/2017/09/09/windows-chocolatey-scoop/</id>
    <published>2017-09-09T13:02:36.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>自从在 Mac 下使用了 <a href="http://davidsheh.github.io/2017/08/26/mac-homebrew/">Homebrew</a> + <a href="https://davidsheh.github.io/2017/08/27/mac-iterm2/">iTerm 2</a> + <a href="https://davidsheh.github.io/2017/08/28/mac-fishshell/">Fish shell</a> 后，瞬间感觉世界清静了不少。然后就在想 Windows 下面有没有类似的软件呢？毕竟在工作中使用 Windows 还是比较多的，然后在网上还真搜到了。对应于 Mac 下的 <a href="[http://davidsheh.github.io/2017/08/26/mac-homebrew/](http://davidsheh.github.io/2017/08/26/mac-homebrew/">Homebrew</a>) + <a href="https://davidsheh.github.io/2017/08/27/mac-iterm2/">iTerm 2</a> + <a href="https://davidsheh.github.io/2017/08/28/mac-fishshell/">Fish shell</a> ， Windows 下是 Chocolatey( + Scoop) + ConEmu + PowerShell。</p><h2 id="Chocolatey"><a href="#Chocolatey" class="headerlink" title="Chocolatey"></a>Chocolatey</h2><p>官网号称 Chocolatey 是在 Windows 上管理软件的明智方式，轻松管理 Windows 软件的各个方面（安装，配置，升级和卸载）。其他介绍请看官网：<a href="https://chocolatey.org/。" target="_blank" rel="noopener">https://chocolatey.org/。</a></p><h3 id="Chocolatey-安装"><a href="#Chocolatey-安装" class="headerlink" title="Chocolatey 安装"></a>Chocolatey 安装</h3><p>Chocolatey 的安装要求用户系统至少是 Windows 7 以上或者 Server 版本 2003 以上，PowerShell 至少是 v2 以上。还需要 <code>.NET Framework 4+</code>，不过在安装 Chocolatey 前会自动检查，如果没有就会自动安装。<br>Chocolatey 可以通过两种方式安装：使用 cmd.exe 来安装和使用 PowerShell.exe 来安装。安装的具体事项可以看官网的 <a href="https://chocolatey.org/install" target="_blank" rel="noopener">Install</a>。</p><h4 id="使用-cmd-exe-方式安装"><a href="#使用-cmd-exe-方式安装" class="headerlink" title="使用 cmd.exe 方式安装"></a>使用 cmd.exe 方式安装</h4><p>建议优先使用此方式安装，因为 cmd.exe 安装过程没有其他操作步骤。打开 CMD 命令行，然后输入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&quot;%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot;</span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong>如果安装失败，安装过程报错，报错信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Installation of Chocolatey to default folder requires Administrative permissions. Please run from elevated prompt.</span><br></pre></td></tr></table></figure></p><p>具体报错信息如下图：<br><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/chocolatey_error.jpg" alt=""><br>上面这个错误产生的原因是因为没有以管理员身份启动 cmd.exe。如何以管理员身份启动 cmd.exe 请自行搜索，这里就不再啰嗦了。</p><h4 id="使用-PowerShell-exe-方式安装"><a href="#使用-PowerShell-exe-方式安装" class="headerlink" title="使用 PowerShell.exe 方式安装"></a>使用 PowerShell.exe 方式安装</h4><p>如果 cmd.exe 方式安装不成功再尝试这种方式， PowerShell.exe 安装过程会有安全性提示，要输入命令来确认。打开 PowerShell 命令行，然后输入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy AllSigned; iex ((New-Object System.Net.WebClient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))</span><br></pre></td></tr></table></figure></p><p>安装过程可能会有安全性提示，按照提示来操作就行了。</p><blockquote><p>使用<code>Win + R</code> 快捷键，接着输入<code>cmd</code>然后回车打开 CMD，输入 <code>powershell</code> 然后回车打开 PowerShell。如果安装报错，也有可能跟第一种安装方式一样是因为没有使用管理员身份运行 PowerShell 的原因。默认以管理员身份启动 PowerShell 的设置可以参考<a href="http://www.pstips.net/set-powershell-icon-launch-to-default-to-run-as-administrator.html" target="_blank" rel="noopener">让PowerShell控制台默认以管理员启动</a> 。</p></blockquote><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">choco -h                       # 查看帮助</span><br><span class="line">choco &lt;command&gt; -h             #查看相应命令的帮助</span><br><span class="line">choco install &lt;package name&gt;   #安装软件包</span><br><span class="line">choco search &lt;keyword&gt;         #搜索软件包，会列出跟关键字相关的所有软件包</span><br><span class="line">choco upgrade &lt;package name&gt;   #升级软件包</span><br><span class="line">choco uninstall &lt;package name&gt; #卸载软件包</span><br><span class="line">choco list --local-only        #查看本地安装的软件包</span><br></pre></td></tr></table></figure><p>更多命令请参考 <a href="https://chocolatey.org/docs/commands-reference#how-to-pass-options--switches" target="_blank" rel="noopener">Command Reference</a> </p><p><strong>注意：</strong><code>choco list</code> 命令查看的是所有软件包，包括本地已安装和远程存在的软件包，所以这个命令执行很耗时。一般我们查看的都是本地已安装的软件包，所以要加上 <code>--local-only</code> 参数，如果要查看远程的软件包，直接使用 <code>choco search</code> 搜索指定软件包。</p><h3 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">choco install googlechrome #安装 Chrome 浏览器</span><br><span class="line">choco install autohotkey.portable #安装 AutoHotKey</span><br><span class="line">choco install ccleaner #安装清理工具</span><br><span class="line">choco install visualstudiocode #安装 VS Code</span><br><span class="line">choco install conemu #安装ConEmu</span><br><span class="line">choco install sourcetree #安装SourceTree</span><br><span class="line">choco install winrar #安装压缩软件</span><br><span class="line">choco install android-sdk #安装 Android SDK</span><br><span class="line">choco install git #安装Git</span><br><span class="line">choco install jdk8 #安装jdk8</span><br><span class="line">choco install nodejs #安装Node.js</span><br><span class="line">choco install virtualbox #安装虚拟机</span><br><span class="line">choco install vim #安装 Vim</span><br><span class="line">choco install docker #安装Docker</span><br><span class="line">choco install wget #安装Wget</span><br><span class="line">choco install dropbox #安装 Dropbox</span><br><span class="line">choco install tortoisesvn #安装 TortoiseSVN</span><br></pre></td></tr></table></figure><p>你所能想到的 Windows 上常用的软件差不多都能找到，想要找什么软件，直接使用 <code>choco search &lt;keyword&gt;</code> 用关键字搜索，如果不知道自己想要啥软件或者记不起来要装啥软件，可以去官网的 <a href="https://chocolatey.org/packages" target="_blank" rel="noopener">Packages</a> 页下找找，几千个软件包，慢慢找去吧。</p><h2 id="Scoop"><a href="#Scoop" class="headerlink" title="Scoop"></a>Scoop</h2><p>Scoop 是 Windows 上的命令行安装程序，主要针对命令行下的开发者工具，和程序猿更配哦。个人的感觉是，Scoop 更像 Mac 上的 <a href="http://davidsheh.github.io/2017/08/26/mac-homebrew/">Homebrew</a>， Chocolatey 更像 <a href="http://davidsheh.github.io/2017/08/26/mac-homebrew/">Homebrew-Cask</a>。关于 Scoop 的更多介绍请看官网：<a href="http://scoop.sh/，同时，Scoop" target="_blank" rel="noopener">http://scoop.sh/，同时，Scoop</a> 是开源的项目，仓库地址<a href="https://github.com/lukesampson/scoop" target="_blank" rel="noopener">点这里</a>。</p><h3 id="Scoop-安装"><a href="#Scoop-安装" class="headerlink" title="Scoop 安装"></a>Scoop 安装</h3><p>Scoop 的安装要求 Windows 上安装的 PowerShell 版本至少的 PowerShell 3，而且必须为你的用户帐户启用 PowerShell 。Windows 10 或 Windows Server 2012 应该默认安装的是 PowerShell 3，但 Windows 7 和Windows Server 2008 可能是比较老的版本。</p><h4 id="升级-PowerShell"><a href="#升级-PowerShell" class="headerlink" title="升级 PowerShell"></a>升级 PowerShell</h4><p>如果是 Windows 7 系统可能需要升级一下 PowerShell，有两种方式可以升级：一是直接下载 <a href="https://www.microsoft.com/en-us/download/details.aspx?id=34595" target="_blank" rel="noopener">PowerShell 3 的安装包</a>，二是通过 Chocolatey 升级。推荐使用第二种方式，下面重点介绍一下第二种方式的升级方法。<br>首先安装 Chocolatey ， 安装方法见上文。使用 <code>choco search powershell</code> 命令只搜索到 PowerShell 4 和 PowerShell 5。虽然在官网 <a href="https://chocolatey.org/packages" target="_blank" rel="noopener">Packages</a> 上搜索到了 <a href="https://chocolatey.org/packages/PowerShell/3.0.20121027" target="_blank" rel="noopener">PowerShell 3</a>，但是好像没通过审核，而且我强行安装失败，最后我直接安装的 PowerShell 5，在 PowerShell 命令行下输入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install powershell  #默认安装的最新版5.1</span><br></pre></td></tr></table></figure></p><p>安装过程需要同意，提示 <code>Do you want to run the script?([Y]es/[N]o/[P]rint):</code> 时，输入<code>y</code>就行了。</p><blockquote><p><strong>提示：</strong>可以使用 <code>Get-Host</code> 命令查看 PowerShell 版本，安装完后需要重启电脑，新版 PowerShell 才能生效。</p></blockquote><h4 id="开始安装-Scoop"><a href="#开始安装-Scoop" class="headerlink" title="开始安装 Scoop"></a>开始安装 Scoop</h4><p>安装 Scoop 前需要确保你已经允许 PowerShell 执行本地脚本，执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set-executionpolicy remotesigned -scope currentuser</span><br></pre></td></tr></table></figure></p><p>执行这个命令时可能会提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Do you want to change the execution policy?</span><br><span class="line">[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help (default is &quot;N&quot;):</span><br></pre></td></tr></table></figure></p><p>输入 <code>y</code> 或者 <code>a</code> 就可以了。接下来开始安装 Scoop，执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iex (new-object net.webclient).downloadstring(&apos;https://get.scoop.sh&apos;)</span><br></pre></td></tr></table></figure></p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scoop help #查看帮助</span><br><span class="line">scoop install #安装 APP</span><br><span class="line">scoop uninstall #卸载 APP</span><br><span class="line">scoop list #列出已安装的 APP</span><br><span class="line">scoop search #搜索 APP</span><br><span class="line">scoop update #更新 APP 和 Scoop 自身</span><br></pre></td></tr></table></figure><p>其实只需要记住 <code>scoop help</code> 这一个命令就行了，其他命令忘记了直接通过这个命令查看就行了。</p><h3 id="常用软件-1"><a href="#常用软件-1" class="headerlink" title="常用软件"></a>常用软件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scoop install 7zip #安装压缩软件</span><br><span class="line">scoop install git  #安装Git</span><br><span class="line">scoop install openssh #安装OpenSSH</span><br><span class="line">scoop install concfg #安装控制台配置文件导入导出工具</span><br></pre></td></tr></table></figure><p>上面的四条命令可以合并成一个命令 <code>scoop install 7zip git openssh concfg</code>。支持的更多软件看这里：<a href="https://github.com/lukesampson/scoop/tree/master/bucket" target="_blank" rel="noopener">https://github.com/lukesampson/scoop/tree/master/bucket</a> 。</p><h3 id="Scoop-的其他配置"><a href="#Scoop-的其他配置" class="headerlink" title="Scoop 的其他配置"></a>Scoop 的其他配置</h3><p><img src="https://github.com/lukesampson/scoop/raw/gh-pages/images/docs/shell-theme.png" alt=""><br>上图是 Scoop 官方给出的效果图，使用的是  <a href="http://ethanschoonover.com/solarized" target="_blank" rel="noopener">Solarized</a> 主题。主题和字体的配置需要用到 <a href="https://github.com/lukesampson/concfg" target="_blank" rel="noopener">concfg</a> 插件，<code>concfg</code> 插件是导入和导出 Windows 控制台配置（如字体和颜色）的一个工具。使用 <code>scoop install concfg</code> 命令来安装。<br>个人感觉 Scoop 最牛逼的地方在于 <a href="https://github.com/lukesampson/scoop/wiki/Buckets" target="_blank" rel="noopener">Buckets</a>，甚至是可以制作自己的 Buckets，可配置性更高了，由于篇幅的原因，这个以后有机会了再写吧。</p><h3 id="Scoop-VS-Chocolatey"><a href="#Scoop-VS-Chocolatey" class="headerlink" title="Scoop VS Chocolatey"></a>Scoop VS Chocolatey</h3><p>Scoop 和 Chocolatey 不同的地方在于下面几点：</p><ol><li>独立安装，和已有软件不冲突</li><li>没有权限对话框，因为程序安装到用户目录</li><li>不会污染路径</li><li>不使用 NuGet，无需担心依赖</li><li>不是软件包管理器，它仅读取一个关于如何安装程序的 JSON</li><li>不安装特定版本，仅仅支持最新版本</li><li><strong>专注于开发者的工具</strong></li></ol><p>更多请参考 <a href="https://github.com/lukesampson/scoop/wiki/Chocolatey-Comparison" target="_blank" rel="noopener">Chocolatey Comparison</a>。国外有人把 Windows 下主流的包管理工具做了一个对比，分别列出了各自的优缺点，还有很多人投票，网站链接： <a href="https://www.slant.co/improve/topics/1843/~windows-package-managers" target="_blank" rel="noopener">What are the best Windows package managers?</a>。</p><h2 id="一键装机"><a href="#一键装机" class="headerlink" title="一键装机"></a>一键装机</h2><p>当你在一台电脑上用 Chocolatey 和 Scoop（非程序员可以不装 Scoop） 配置过一次工作环境后，你只需要记住你所使用的软件包的名称，然后将所有的安装命令的清单云同步，那么当你换电脑了就可以很轻松的同步工作环境的配置，是不是非常酷，甚至是换工作时在新同事面前耍（装）帅（逼）。我的命令清单如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#使用 Chocolatey 安装</span><br><span class="line">choco install googlechrome #安装 Chrome 浏览器</span><br><span class="line">choco install unity #安装最新版 Unity3D 游戏引擎</span><br><span class="line">choco install visualstudiocode #安装 VS Code</span><br><span class="line">choco install sourcetree #安装SourceTree</span><br><span class="line"></span><br><span class="line">choco install autohotkey.portable #安装 AutoHotKey</span><br><span class="line">choco install conemu #安装ConEmu</span><br><span class="line"></span><br><span class="line">choco install jdk8 #安装jdk8</span><br><span class="line">choco install android-sdk #安装 Android SDK</span><br><span class="line"></span><br><span class="line">#使用 Scoop 安装</span><br><span class="line">scoop install concfg git #安装 concfg、git 等</span><br><span class="line">concfg import solarized small #导入 Solarized 主题</span><br><span class="line">scoop install pshazz #安装自定义提示和 具有Git&amp;SSH 特性的插件</span><br></pre></td></tr></table></figure></p><p>清单会持续更新，先就列这么多吧，以后再更新其他命令，欢迎关注 <a href="https://davidsheh.github.io/">Sheh 伟伟的个人博客</a>。</p><hr><p><strong>同系列文章</strong></p><p><a href="http://davidsheh.github.io/2017/09/09/windows-chocolatey-scoop/">Windows 系统的包管理器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自从在 Mac 下使用了 &lt;a href=&quot;http://davidsheh.github.io/2017/08/26/mac-homebrew/&quot;&gt;Homebrew&lt;/a&gt; + &lt;a href=&quot;https://davidsheh.github.io/2017/08/27
      
    
    </summary>
    
      <category term="开发工具" scheme="http://davidsheh.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Windows" scheme="http://davidsheh.github.io/tags/Windows/"/>
    
      <category term="Chocolatey" scheme="http://davidsheh.github.io/tags/Chocolatey/"/>
    
      <category term="Scoop" scheme="http://davidsheh.github.io/tags/Scoop/"/>
    
  </entry>
  
  <entry>
    <title>用Hexo搭建个人博客</title>
    <link href="http://davidsheh.github.io/2017/09/03/hexo-blog/"/>
    <id>http://davidsheh.github.io/2017/09/03/hexo-blog/</id>
    <published>2017-09-03T12:08:21.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><h3 id="1-安装Homebrew"><a href="#1-安装Homebrew" class="headerlink" title="1. 安装Homebrew"></a>1. 安装Homebrew</h3><p>Mac建议使用 Homebrew 安装必要的插件，Windows用户可以跳过这一步。关于 Homebrew 的介绍请看我的这篇博文 <a href="https://davidsheh.github.io/2017/08/26/mac-homebrew/">Mac开发必备工具（一）—— Homebrew</a>。</p><h3 id="2-安装Git和Node-js"><a href="#2-安装Git和Node-js" class="headerlink" title="2. 安装Git和Node.js"></a>2. 安装Git和Node.js</h3><p>Node.js 可以通过 Homebrew 安装，安装命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure></p><h3 id="3-安装-Hexo-博客框架"><a href="#3-安装-Hexo-博客框架" class="headerlink" title="3. 安装 Hexo 博客框架"></a>3. 安装 Hexo 博客框架</h3><p>Hexo 框架可以使用下面的 npm 命令来安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><h2 id="使用Hexo建站"><a href="#使用Hexo建站" class="headerlink" title="使用Hexo建站"></a>使用Hexo建站</h2><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><blockquote><p>建站步骤可参考<a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="noopener">Hexo官方文档</a></p></blockquote><p>接着执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></p><p>命令执行完毕后，在浏览器输入<code>localhost:4000</code>就可以预览本地博客效果。</p><h3 id="将Hexo部署到GitHub"><a href="#将Hexo部署到GitHub" class="headerlink" title="将Hexo部署到GitHub"></a>将Hexo部署到GitHub</h3><p>在 GitHub 上新建一个仓库，然后修改 Hexo 的配置文件<code>_config.yml</code>中的 Deployment 配置项，修改内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/xxx/xxx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注意：</strong> 上面的的 <code>repository</code> 项要换成自己新建完成的 GitHub 仓库地址，也就是把上面的xxx换成你 GitHub 的用户名。</p></blockquote><p>配置完后，接着执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p><p>这样就将博客部署到GitHub上了。可以在浏览器中输入<code>https://xxx.github.io</code>查看博客效果。我的博客效果可以<a href="https://davidsheh.github.io">点这里查看</a>。</p><blockquote><p>如果部署报错<code>ERROR Deployer not found: git</code> 或者 <code>ERROR Deployer not found: github</code>，就先执行<code>npm install hexo-deployer-git --save</code>安装部署插件后再运行<code>hexo deploy</code>命令</p></blockquote><h2 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h2><p>你可以执行下列命令来创建一篇新文章:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &lt;title&gt;</span><br></pre></td></tr></table></figure></p><p>命令执行完后，会在 Hexo 项目的<code>\source\_posts</code>目录下生成一个对应名称的<code>.md</code>文件。用编辑器打开就可以开始写文章了，注意文章得使用 Markdown 编写。文章写完后执行上面的清理、生成和部署命令将文章发布到GitHub仓库。<br>当让也可以不使用上面的生成命令，直接将事先编辑好的<code>.md</code> 文件复制到对应的目录，也是可以的。只不过用命令生成的<code>.md</code>文件会带一个<a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">Front-matter</a>，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 创建时间</span><br><span class="line">tags: 文章标签</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>所以，事先编辑好的<code>.md</code>文件里也应该包含相应的<a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">Front-matter</a>。</p><h2 id="更换博客主题"><a href="#更换博客主题" class="headerlink" title="更换博客主题"></a>更换博客主题</h2><h3 id="更换默认主题"><a href="#更换默认主题" class="headerlink" title="更换默认主题"></a>更换默认主题</h3><p>Hexo 更换主题很简单，就两步：</p><ol><li>选择喜欢的主题，可以去<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网主题页</a>选择喜欢的主题，下载主题包。然后将主题文件夹放到 Hexo 项目的 <strong>themes</strong> 文件夹下。</li><li>修改 Hexo 站点配置文件<code>_config.yml</code>中的 Extensions 配置项，修改内容如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>博主使用的是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NexT主题</a>，所以 theme 项配置的是<code>next</code>，这里配置的字段一定要和 <strong>themes</strong> 文件夹下主题包的文件夹名称相同。下文关于主题的配置均是针对于 NexT 主题，主题的具体使用说明可以参考 <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT 官方网站</a>。</p></blockquote><h3 id="NexT-主题设置"><a href="#NexT-主题设置" class="headerlink" title="NexT 主题设置"></a>NexT 主题设置</h3><p>NexT 主题的设置在官网的<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">开始使用</a>中说的很详细，我这里就不画蛇添足了，不清楚的可以直接看官网。<br>关于 NexT 主题的文档是我见过的所有 Hexo 主题中最完善的，你所能想到大部分配置都集成到主题了，基本实现了傻瓜式配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装环境&quot;&gt;&lt;a href=&quot;#安装环境&quot; class=&quot;headerlink&quot; title=&quot;安装环境&quot;&gt;&lt;/a&gt;安装环境&lt;/h2&gt;&lt;h3 id=&quot;1-安装Homebrew&quot;&gt;&lt;a href=&quot;#1-安装Homebrew&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="开发工具" scheme="http://davidsheh.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Hexo" scheme="http://davidsheh.github.io/tags/Hexo/"/>
    
      <category term="NexT" scheme="http://davidsheh.github.io/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>使用 VS Code 写 Shaderlab</title>
    <link href="http://davidsheh.github.io/2017/08/29/vscode-shaderlab/"/>
    <id>http://davidsheh.github.io/2017/08/29/vscode-shaderlab/</id>
    <published>2017-08-29T10:57:25.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Unity3D 开发中，我们一般使用 VS 写代码，但是对于写 Shader，VS 还不如自带的 MonoDeveloper 强大，而且目前我还没有发现对 Shaderlab支持比较好的 VS 扩展插件。自从试用过 VS Code 后我把电脑上的 Sublime Text 给卸载了，换成了 VS Code 一直用到现在，而且越用越觉得强大，毕竟有微软这个爸爸，发展势头还是很猛的。言归正传，这篇博客打算记录一下我使用 VS Code 写 Shaderlab 的一些经验。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>首先得安装 VS Code，这个是肯定的，没啥好说的。安装好 VS Code 后，在插件页搜索 ShaderlabVSCodeFree 扩展，然后安装重启。装好插件后，使用 VS Code 打开 Shaderlab 文件，就可以愉快的写 Shader 了。该插件支持<code>.shader</code>、<code>.cginc</code>、<code>.glslinc</code>、<code>.compute</code>四种格式的 Shaderlab 文件，同时，还支持语法高亮、基础代码补全、签名帮助 三大功能，基础代码补全这个功能用了一下感觉非常赞，要是再能支持自动格式化就完美了，不过对于免费版来说，已经非常良心了。该插件还有个收费的 <a href="https://www.assetstore.unity3d.com/en/#!/content/94653" target="_blank" rel="noopener">ShaderlabVSCode Beta</a> 版，支持的功能更多，也支持代码格式化，插件作者是中国的 Unity3D 开发者，所以，如果大家手头富裕的话，请支持一下作者，去AssetStore购买 <a href="https://www.assetstore.unity3d.com/en/#!/content/94653" target="_blank" rel="noopener">ShaderlabVSCode Beta</a> 版。</p><h2 id="添加代码片段"><a href="#添加代码片段" class="headerlink" title="添加代码片段"></a>添加代码片段</h2><p>为了写代码的方便，常用的 Shaderlab 代码块可以通过 File -&gt; Preferences -&gt; User Snippets 选项，然后找到 Shaderlab 语言，添加进 Json 配置文件，我放两个常用的代码片段：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line">// Place your snippets for Shaderlab here. Each snippet is defined under a snippet name and has a prefix, body and </span><br><span class="line">// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:</span><br><span class="line">// $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the </span><br><span class="line">// same ids are connected.</span><br><span class="line">// Example:</span><br><span class="line">"Print to console": &#123;</span><br><span class="line">"prefix": "log",</span><br><span class="line">"body": [</span><br><span class="line">"console.log('$1');",</span><br><span class="line"><span class="string">"$2"</span></span><br><span class="line">],</span><br><span class="line">"description": "Log output to console"</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">"Unity3D Shaderlab": &#123;</span><br><span class="line">"prefix": "shaderlab",</span><br><span class="line">"body": [</span><br><span class="line">"Shader \"$&#123;1:New Shader&#125;\"",</span><br><span class="line">"&#123;",</span><br><span class="line">"\tProperties",</span><br><span class="line">"\t&#123;",</span><br><span class="line">"\t\t_MainTex (\"Texture\", 2D) = \"white\" &#123;&#125;",</span><br><span class="line">"\t&#125;",</span><br><span class="line">"\tSubShader",</span><br><span class="line">"\t&#123;",</span><br><span class="line">"\t\tTags &#123; \"RenderType\"=\"$&#123;2:Opaque&#125;\" &#125;\n",</span><br><span class="line">"\t\tPass",</span><br><span class="line">"\t\t&#123;",</span><br><span class="line">"\t\t\t$3",</span><br><span class="line">"\t\t&#125;",</span><br><span class="line">"\t&#125;",</span><br><span class="line"><span class="string">"&#125;"</span></span><br><span class="line">],</span><br><span class="line">"description": "Unity3D Shaderlab"</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">"CGPROGRAM": &#123;</span><br><span class="line">"prefix": "cg",</span><br><span class="line">"body": [</span><br><span class="line">"CGPROGRAM",</span><br><span class="line">"#pragma vertex vert",</span><br><span class="line">"#pragma fragment frag\n",</span><br><span class="line">"#include \"UnityCG.cginc\"\n",</span><br><span class="line">"struct appdata",</span><br><span class="line">"&#123;",</span><br><span class="line">"\tfloat4 vertex : POSITION;",</span><br><span class="line">"\tfloat2 uv : TEXCOORD0;",</span><br><span class="line">"&#125;;\n",</span><br><span class="line">"struct v2f",</span><br><span class="line">"&#123;",</span><br><span class="line">"\tfloat2 uv : TEXCOORD0;",</span><br><span class="line">"\tfloat4 vertex : SV_POSITION;",</span><br><span class="line">"&#125;;\n",</span><br><span class="line">"sampler2D _MainTex;\n",</span><br><span class="line">"v2f vert(appdata v)",</span><br><span class="line">"&#123;",</span><br><span class="line">"\tv2f o;",</span><br><span class="line">"\to.vertex = UnityObjectToClipPos(v.vertex);",</span><br><span class="line">"\to.uv = TRANSFORM_TEX(v.uv, _MainTex);\n",</span><br><span class="line"></span><br><span class="line">"\treturn o;",</span><br><span class="line">"&#125;\n",</span><br><span class="line"></span><br><span class="line">"fixed4 frag(v2f i) : SV_Target",</span><br><span class="line">"&#123;",</span><br><span class="line">"\t// sample the texture",</span><br><span class="line">"\tfixed4 col = tex2D(_MainTex, i.uv);",</span><br><span class="line">"\treturn col;",</span><br><span class="line">"&#125;",</span><br><span class="line"><span class="string">"ENDCG"</span></span><br><span class="line">],</span><br><span class="line">"description": "Unity3D Shaderlab CGPROGRAM"</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保存后，可以新建一个扩展名为 <code>.shader</code> 的文本文件，然后输入<code>shaderlab</code>后回车就会自动生成一个标准的 Shaderlab 结构代码块。输入<code>cg</code>后回车就会生成一段 CGPROGRAM 代码块，赶快试试吧！<br>刚开始使用VS Code 写 Shader 先放上两个代码片段，后期再增加其他代码片段。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Unity3D 开发中，我们一般使用 VS 写代码，但是对于写 Shader，VS 还不如自带的 MonoDeveloper 强大，而且目前我还没有发现对 Shaderlab支持比较好的 VS 扩展插件。自从试用过 VS Code 后我把电脑上的 Sublime Text 
      
    
    </summary>
    
      <category term="开发工具" scheme="http://davidsheh.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Unity3D" scheme="http://davidsheh.github.io/tags/Unity3D/"/>
    
      <category term="VS Code" scheme="http://davidsheh.github.io/tags/VS-Code/"/>
    
      <category term="Shaderlab" scheme="http://davidsheh.github.io/tags/Shaderlab/"/>
    
  </entry>
  
  <entry>
    <title>Mac开发必备工具（三）—— Fish shell</title>
    <link href="http://davidsheh.github.io/2017/08/28/mac-fishshell/"/>
    <id>http://davidsheh.github.io/2017/08/28/mac-fishshell/</id>
    <published>2017-08-28T14:53:41.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fish-shell"><a href="#Fish-shell" class="headerlink" title="Fish shell"></a>Fish shell</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>fish 可以根据输入自动匹配历史命令。它的一大特点是开箱即用，没有zsh那些繁琐的配置。官网：<a href="http://www.fishshell.com/。" target="_blank" rel="noopener">http://www.fishshell.com/。</a></p><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p>在终端里使用Homebrew安装，直接输入 <code>brew install fish</code> 等待安装完成即可。安装完了以后还不能用，因为没把fish添加到 mac 的 shell 列表里，切换到 fish shell 时显示找不到fish shell，所以我们要先添加 fish 并设置一下 shell 。首先，用 shell 命令<code>sudo vim /etc/shells</code>在 vim 中打开 Mac 的 shell 列表，执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># List of acceptable shells for chpass(1).</span><br><span class="line"># Ftpd will not allow users to connect who are not using</span><br><span class="line"># one of these shells.</span><br><span class="line"></span><br><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br></pre></td></tr></table></figure><p>按<code>i</code>键，进入插入模式，然后在列表末尾加上<code>/usr/local/bin/fish</code>。最后文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># List of acceptable shells for chpass(1).</span><br><span class="line"># Ftpd will not allow users to connect who are not using</span><br><span class="line"># one of these shells.</span><br><span class="line"></span><br><span class="line">/bin/bash</span><br><span class="line">/bin/csh</span><br><span class="line">/bin/ksh</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/zsh</span><br><span class="line">/usr/local/bin/fish</span><br></pre></td></tr></table></figure><p>最后，按 esc 键跳到命令模式，输入<code>:wq</code> 命令保存文件并退出vim。当前模式还是 bash shell 模式，要切换到 fish shell 需要输入 <code>fish</code> 命令。每次都输入命令切换 shell 比较繁琐，我们可以通过如下命令从 bash 切换到 fish ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /usr/local/bin/fish</span><br></pre></td></tr></table></figure></p><p>也可以通过如下命令切回到 bash：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/bash</span><br></pre></td></tr></table></figure></p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ol><li>自动建议<br>Fish 会自动在光标后面给出建议，颜色为灰色。按下<code>→</code>或<code>Control + F</code>表示采纳建议，按下<code>Alt + →</code>表示只采纳一部分。</li><li>Tab 键补全<br>按下 <code>Tab</code> 键，Fish 将尝试自动补全命令、参数或路径，如果有多条补全建议，可以继续使用 <code>Tab</code> 键在不同建议间切换。</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>因为博主并不是天天跟命令行打交道，shell 也根本不会，只是在学习和工作中偶尔会用到命令行，敲几行命令执行一些操作，所以这篇文章只是简单的介绍 Fish shell，作为一个学习的记录，想深入了解的可以访问<a href="https://www.fishshell.com/" target="_blank" rel="noopener">官网</a>。<br>有了 Homebrew + iTerm 2 + Fish shell，对命令行有畏惧和抵触情绪的「终端恐惧症患者」再也不用头疼了。关于 Homebrew 和 iTerm 2 的介绍请看我的另外两篇文章：<a href="http://davidsheh.github.io/2017/08/26/mac-homebrew/">Mac开发必备工具（一）—— Homebrew</a>、<a href="http://davidsheh.github.io/2017/08/27/mac-iterm2/">Mac开发必备工具（二）—— iTerm 2</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.fishshell.com/docs/current/tutorial.html" target="_blank" rel="noopener">fish tutorial</a></p><hr><p><strong>同系列文章</strong></p><p><a href="http://davidsheh.github.io/2017/08/26/mac-homebrew/">Mac开发必备工具（一）—— Homebrew</a></p><p><a href="http://davidsheh.github.io/2017/08/27/mac-iterm2/">Mac开发必备工具（二）—— iTerm 2</a></p><p><a href="http://davidsheh.github.io/2017/08/28/mac-fishshell/">Mac开发必备工具（三）—— Fish shell</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Fish-shell&quot;&gt;&lt;a href=&quot;#Fish-shell&quot; class=&quot;headerlink&quot; title=&quot;Fish shell&quot;&gt;&lt;/a&gt;Fish shell&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="开发工具" scheme="http://davidsheh.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Mac" scheme="http://davidsheh.github.io/tags/Mac/"/>
    
      <category term="Fish shell" scheme="http://davidsheh.github.io/tags/Fish-shell/"/>
    
      <category term="Shell" scheme="http://davidsheh.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Mac开发必备工具（二）—— iTerm 2</title>
    <link href="http://davidsheh.github.io/2017/08/27/mac-iterm2/"/>
    <id>http://davidsheh.github.io/2017/08/27/mac-iterm2/</id>
    <published>2017-08-27T10:20:12.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iTerm-2"><a href="#iTerm-2" class="headerlink" title="iTerm 2"></a>iTerm 2</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>iTerm 2 is a terminal emulator for Mac OS X that does amazing things.</p></blockquote><p>iTerm 2 有很多能够提升效率的实用功能。比如说窗口分割、热键窗口、智能搜索、自动完成、快速复制等等，其他功能可查看<a href="https://www.iterm2.com/features.html" target="_blank" rel="noopener">官网的Features页</a>。</p><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>有两种方式可以安装iTerm 2：</p><ol><li>直接从<a href="https://www.iterm2.com/index.html" target="_blank" rel="noopener">官网</a>下载安装包。</li><li>使用 Homebrew 命令<code>brew install iTerm2</code>安装。</li></ol><p>个人推荐使用第二种方式安装。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>关于 iTerm 2 的配置可以参考官网介绍，然后根据自己的喜好配置。这里介绍一个实用的快捷键配置和一个主题配置。</p><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>快速显示和隐藏 iTerm 2 的快捷键设置如下图：<br><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/iterm2_hotkey.jpg" alt="iTerm 2 Hotkey"><br>快捷键的设置可以根据自己的使用习惯来设置。</p><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>经过多款主题的对比，最终选择了推荐最多的一款主题<a href="http://ethanschoonover.com/solarized" target="_blank" rel="noopener">Solarized</a>。选择这款主题是因为它有自己的<a href="http://ethanschoonover.com/solarized" target="_blank" rel="noopener">官网</a>，同时支持主流的编辑器和 IDE。主题配置步骤如下：</p><ol><li>先去<a href="http://ethanschoonover.com/solarized" target="_blank" rel="noopener">官网</a>下载主题压缩包，<a href="http://ethanschoonover.com/solarized/files/solarized.zip" target="_blank" rel="noopener">直接下载链接点这里</a>。</li><li>下载后解压，然后<code>⌘+,</code>打开 iTerm 2 的首选项，接着 Profiles -&gt; Colors -&gt; Color Presets -&gt; Import，选择刚解压的文件夹<code>solarized/iterm2-colors-solarized</code>下的<code>Solarized Dark.itermcolors</code>文件。</li><li>在Color Presets 下拉菜单中选中 Solarized Dark 主题，大功告成。</li><li>配置截图如下：<br><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/iterm2_theme.jpg" alt="iTerm 2 Hotkey"></li></ol><p>这里放一张效果图简单的预览一下主题的效果。<br><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/iterm2_preview.jpg" alt="Solarized Preview"></p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ol><li><code>⌘+T</code> 打开一个新的标签页</li><li><code>⌘+;</code> 弹出自动补齐窗口</li><li><code>⌘+Shift+;</code> 弹出历史命令记录窗口</li><li><code>⌘+Shift+H</code> 弹出历史粘贴记录窗口</li><li><code>⌘+←</code>、<code>⌘+→</code>、 <code>⌘+{</code>, <code>⌘+}</code>、<code>⌘+&lt;number&gt;</code> 切换标签页</li><li><code>⌘+F</code> 智能查找，支持正则查找</li><li><code>⌘+[</code>、<code>⌘+]</code>、<code>⌘+Option+方向键</code> 切换 pane</li><li><code>⌘+D</code>  水平切分屏幕，<code>⌘+Shift+D</code> 垂直切分屏幕</li><li><code>⌘+Enter</code> 进入与返回全屏模式</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>当然，iTerm 2 的功能远远不止这些，本文只是博主在使用过程中的一个记录和总结，后续用到其他高级功能了再来补充，待续…</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.iterm2.com/documentation.html" target="_blank" rel="noopener">iTerm2官方文档</a></p><hr><p><strong>同系列文章</strong></p><p><a href="http://davidsheh.github.io/2017/08/26/mac-homebrew/">Mac开发必备工具（一）—— Homebrew</a></p><p><a href="http://davidsheh.github.io/2017/08/27/mac-iterm2/">Mac开发必备工具（二）—— iTerm 2</a></p><p><a href="http://davidsheh.github.io/2017/08/28/mac-fishshell/">Mac开发必备工具（三）—— Fish shell</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iTerm-2&quot;&gt;&lt;a href=&quot;#iTerm-2&quot; class=&quot;headerlink&quot; title=&quot;iTerm 2&quot;&gt;&lt;/a&gt;iTerm 2&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简
      
    
    </summary>
    
      <category term="开发工具" scheme="http://davidsheh.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Mac" scheme="http://davidsheh.github.io/tags/Mac/"/>
    
      <category term="iTerm 2" scheme="http://davidsheh.github.io/tags/iTerm-2/"/>
    
      <category term="Solarized" scheme="http://davidsheh.github.io/tags/Solarized/"/>
    
  </entry>
  
  <entry>
    <title>Mac开发必备工具（一）—— Homebrew</title>
    <link href="http://davidsheh.github.io/2017/08/26/mac-homebrew/"/>
    <id>http://davidsheh.github.io/2017/08/26/mac-homebrew/</id>
    <published>2017-08-26T15:18:42.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>macOS 缺失的软件包管理器。使用 Homebrew 安装 Apple 没有预装但 <a href="https://github.com/Homebrew/homebrew-core/tree/master/Formula" target="_blank" rel="noopener">你需要的东西</a>。<a href="https://brew.sh/" target="_blank" rel="noopener">官网</a>有中文说明。</p><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p>Homebrew 的安装非常简单，将下面这条命令粘贴到终端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></p><p>等待命令执行完毕。其他配置见<a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="noopener">官网中文说明</a>。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ol><li><code>brew help</code> 查看帮助</li><li><code>brew install &lt;package name&gt;</code> 安装软件包</li><li><code>brew uninstall &lt;package name&gt;</code> 卸载软件包</li><li><code>brew list [--versions]</code> 列出已安装的软件包(包括版本)</li><li><code>brew search &lt;package name&gt;</code> 查找软件包</li><li><code>brew info &lt;package name&gt;</code> 查看软件包信息</li><li><code>brew update</code> 更新brew</li><li><code>brew outdated</code> 列出过时的软件包（已安装但不是最新版本）</li><li><code>brew upgrade [&lt;package name&gt;]</code> 更新过时的软件包（不指定软件包表示更新全部）</li><li><code>brew doctor</code> 检查brew运行状态</li></ol><h2 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">brew install wget</span><br><span class="line">brew install curl</span><br><span class="line">brew install openssl</span><br><span class="line"></span><br><span class="line">brew install fish      #安装fish shell</span><br><span class="line">brew install git-flow  #安装git-flow</span><br><span class="line">brew install python    #安装python</span><br></pre></td></tr></table></figure><h2 id="Homebrew-Cask"><a href="#Homebrew-Cask" class="headerlink" title="Homebrew-Cask"></a>Homebrew-Cask</h2><p>Homebrew-Cask 是 Homebrew 的一个扩展。它能够优雅、简单、快速的安装和管理 macOS 图形界面程序，比如Google Chrome 和Dropbox等等。官网 <a href="https://caskroom.github.io/。" target="_blank" rel="noopener">https://caskroom.github.io/。</a></p><h3 id="Cask-必装的理由"><a href="#Cask-必装的理由" class="headerlink" title="Cask 必装的理由"></a>Cask 必装的理由</h3><p>有图形界面的软件可以直接在 App Stroe 中下载更新，为啥还需要 Cask 呢？因为有的很好用的免费 Mac 软件并没有选择在 App Store 上架，对于没有上架的软件我们只能是通过搜索找到官网然后在下载安装包，这样不够优雅也不方便管理，而使用 Cask 可以通过一行命令就搞定安装了，还可以统一更新升级所有的软件，实现从非 App Store 途径安装的软件的统一管理。<br>Cask 从软件官方网站下载软件包，然后在后台安装并将 <code>.app</code> 移动到 <code>Applications</code>。通过 Cask 安装的软件也会在 Lanuchpad 显示，跟从 App Store 安装的软件没啥区别。对于那些收费的软件，用 Cask 安装只是比普通安装方法节省了时间和步骤，没啥其他的区别。</p><h3 id="Cask-常用命令"><a href="#Cask-常用命令" class="headerlink" title="Cask 常用命令"></a>Cask 常用命令</h3><ol><li><code>brew cask -help</code> 查看帮助</li><li><code>brew cask install &lt;software name&gt;</code> 安装软件</li><li><code>brew cask uninstall &lt;software name&gt;</code> 卸载软件</li><li><code>brew cask search &lt;software name&gt;</code> 搜索软件</li><li><code>brew cask info  &lt;software name&gt;</code> 查看软件相关信息</li><li><code>brew cask list</code> 列出通过 Homebrew-Cask 安装的包</li></ol><blockquote><p>经过测试，虽然 <code>-help</code> 是未知命令，但是仍然可查看 Cask 的命令，其他帮助命令（如 <code>brew cask -h</code> 和 <code>brew cask --help</code>）好像都不行。还有其他的命令就不一一介绍了，其他命令可以通过<code>brew cask -help</code>查看。</p></blockquote><h3 id="Cask-常用软件"><a href="#Cask-常用软件" class="headerlink" title="Cask 常用软件"></a>Cask 常用软件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">brew cask install iterm2         #安装iTerm 2</span><br><span class="line">brew cask install launchrocket   #管理软件后台服务</span><br><span class="line">brew cask install google-chrome  #安装Chrome</span><br><span class="line">brew cask install the-unarchiver #解压软件</span><br><span class="line">brew cask install alfred         #效率软件</span><br><span class="line">brew cask install qq             #腾讯QQ</span><br><span class="line">brew cask install evernote       #云笔记软件</span><br><span class="line">brew cask install sublime-text   #文本编辑器</span><br><span class="line">brew cask install skitch         #ervernote配套的截图软件</span><br><span class="line">brew cask install dropbox        #文件同步软件</span><br><span class="line">brew cask install zotero         #网页收藏与文献管理软件</span><br><span class="line">brew cask install anki           #记忆软件</span><br><span class="line">brew cask install virtualbox     #虚拟机，可以装个Windows</span><br><span class="line">brew cask install self-control   #避免分心的软件</span><br><span class="line">brew cask install vlc            #视频软件</span><br><span class="line">brew cask install appcleaner     #应用清理</span><br><span class="line"></span><br><span class="line">#Quick Look 系列</span><br><span class="line">brew cask install qlcolorcode    #预览脚本时自动代码配色</span><br><span class="line">brew cask install qlstephen      #预览未知拓展名的纯文本文件</span><br><span class="line">brew cask install qlmarkdown     #预览Markdown文件</span><br><span class="line">brew cask install quicklook-json #预览JSON文件</span><br><span class="line">brew cask install quicklook-csv  #预览CSV文件</span><br></pre></td></tr></table></figure><p>Homebrew-Cask 是一个开源项目，其详细信息可以看<a href="https://github.com/caskroom/homebrew-cask" target="_blank" rel="noopener">其开源项目介绍</a>，所支持的软件列表在这里：<a href="https://github.com/caskroom/homebrew-cask/tree/master/Casks" target="_blank" rel="noopener">https://github.com/caskroom/homebrew-cask/tree/master/Casks</a> 。<br>如果觉得管理软件在后台运行的服务很麻烦，可以装个<a href="https://github.com/jimbojsb/launchrocket" target="_blank" rel="noopener">LaunchRocket</a>，这也是个开源项目。<br>关于 Quick Look 的介绍可以看这篇文章<a href="https://sspai.com/post/31927" target="_blank" rel="noopener">加强你的「一指禅」：Mac QuickLook「快速预览」兼容性扩展教程</a>，同时<a href="https://github.com/sindresorhus/quick-look-plugins" target="_blank" rel="noopener">Quick Look plugins</a>这个开源项目列出了所有支持 Homebrew-Cask 的 Quick Look 扩展，据说支持的都是程序员必备。</p><h2 id="轻松实现一键装机"><a href="#轻松实现一键装机" class="headerlink" title="轻松实现一键装机"></a>轻松实现一键装机</h2><p>在使用 Mac 的过程中，总想着有没有方便、简单的办法实现在不同Mac 上同步开发环境的办法，今天在整理 Homebrew 使用笔记的时候突然冒出一个想法，如果我把所有的 Homebrew 安装命令列成一个清单形式，当在另一台新的 Mac 上工作时，那么就可以先装一个 Homebrew 然后将命令清单中的所有命令复制粘贴到终端中，等待命令执行完毕后，新的 Mac 的大部分开发环境就跟常用的 Mac 开发环境一致了。下面列出笔者的常用命令清单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#安装 Homebrew</span><br><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line"></span><br><span class="line">#安装基础套件</span><br><span class="line">brew install fish      #安装fish shell</span><br><span class="line">brew install git-flow  #安装git-flow</span><br><span class="line">brew install python    #安装python</span><br><span class="line"></span><br><span class="line">#Homebrew-Cask</span><br><span class="line">brew tap caskroom/cask</span><br><span class="line"></span><br><span class="line"># 安装Cask基础软件</span><br><span class="line">brew cask install iterm2         #安装iTerm 2</span><br><span class="line">brew cask install visual-studio-code#微软出品的文本编辑器，可替代 Sublime Text</span><br><span class="line">brew cask install google-chrome  #安装Chrome</span><br><span class="line">brew cask install the-unarchiver #解压软件</span><br><span class="line">brew cask install alfred         #效率软件</span><br><span class="line">brew cask install qq             #腾讯QQ</span><br><span class="line">brew cask install sourcetree     #Git GUI 客户端</span><br><span class="line">brew cask install cheatsheet     # 显示当前程序的快捷键列表，默认的快捷键是长按⌘</span><br></pre></td></tr></table></figure></p><p>这份清单会随着我对 Mac 的不断深入了解而持续更新，欢迎关注 <a href="https://davidsheh.github.io/">Sheh 伟伟的个人博客</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://aaaaaashu.gitbooks.io/mac-dev-setup/content/Homebrew/index.html" target="_blank" rel="noopener">Mac 开发配置手册</a></p><hr><p><strong>同系列文章</strong></p><p><a href="http://davidsheh.github.io/2017/08/26/mac-homebrew/">Mac开发必备工具（一）—— Homebrew</a></p><p><a href="http://davidsheh.github.io/2017/08/27/mac-iterm2/">Mac开发必备工具（二）—— iTerm 2</a></p><p><a href="http://davidsheh.github.io/2017/08/28/mac-fishshell/">Mac开发必备工具（三）—— Fish shell</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Homebrew&quot;&gt;&lt;a href=&quot;#Homebrew&quot; class=&quot;headerlink&quot; title=&quot;Homebrew&quot;&gt;&lt;/a&gt;Homebrew&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="开发工具" scheme="http://davidsheh.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Mac" scheme="http://davidsheh.github.io/tags/Mac/"/>
    
      <category term="Homebrew" scheme="http://davidsheh.github.io/tags/Homebrew/"/>
    
      <category term="Homebrew-Cask" scheme="http://davidsheh.github.io/tags/Homebrew-Cask/"/>
    
  </entry>
  
  <entry>
    <title>「翻译」Unity中的AssetBundle详解（三）</title>
    <link href="http://davidsheh.github.io/2017/08/21/%E3%80%8C%E7%BF%BB%E8%AF%91%E3%80%8DUnity%E4%B8%AD%E7%9A%84AssetBundle%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://davidsheh.github.io/2017/08/21/「翻译」Unity中的AssetBundle详解（三）/</id>
    <published>2017-08-21T14:19:08.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构建AssetBundles"><a href="#构建AssetBundles" class="headerlink" title="构建AssetBundles"></a>构建AssetBundles</h1><p>在<a href="https://docs.unity3d.com/Manual/AssetBundles-Building.html#AssetBundles-Workflow" target="_blank" rel="noopener">AssetBundle工作流程</a>的文档中，我们有一个示例代码，它将三个参数传递给<code>BuildPipeline.BuildAssetBundles</code>函数。让我们更深入地了解我们实际上在说什么。<br><em>Assets/AssetBundles</em>：这是AssetBundles将被输出到的目录。您可以将其更改为所需的任何输出目录，只需在尝试构建之前确保文件夹实际存在。</p><h2 id="BuildAssetBundleOptions"><a href="#BuildAssetBundleOptions" class="headerlink" title="BuildAssetBundleOptions"></a>BuildAssetBundleOptions</h2><p>有多种不同的<code>BuildAssetBundleOptions</code>选项可以选择。相关的各个选项可以参阅脚本API文档中的关于<a href="https://docs.unity3d.com/ScriptReference/BuildAssetBundleOptions.html" target="_blank" rel="noopener">BuildAssetBundleOptions</a>的内容。<br>虽然随着需求的变化和增加，您可以自由组合<code>BuildAssetBundleOptions</code>选项，但有三个特定的<code>BuildAssetBundleOptions</code>是用来处理AssetBundle压缩：</p><ul><li>BuildAssetBundleOptions.None：此bundle选项使用LZMA格式压缩，这种压缩是序列化的数据文件的单一压缩的LZMA流。 LZMA压缩的文件在使用前需要对整个bundle解压缩。这导致最小的文件大小和由于解压缩而稍微增加的加载时间。值得注意的是，当使用此<code>BuildAssetBundleOptions</code>时，为了使用捆绑包中的任何资源，必须首先解压缩整个捆绑包。一旦bundle解压缩后，将使用LZ4在磁盘上重新压缩，LZ4压缩在使用bundle中的资产时，不需要提前对整个bundle进行解压缩。这最适合用于bundle中的资产，以便从bundle中使用一个资产将意味着所有资产将被加载。打包角色或场景的所有资源都是可能使用的捆绑包的一些示例。由于较小的初始文件大小，利用LZMA压缩仅推荐用于从异地主机下载资源包。一旦文件被下载，它会缓存为lz4压缩包。</li><li><code>BuildAssetBundleOptions.UncompressedAssetBundle</code>: 此bundle选项以数据完全未压缩的方式构建bundle。未压缩的缺点是较大的文件下载大小。但是，一旦下载的加载时间会更快。</li><li><code>BuildAssetBundleOptions.ChunkBasedCompression</code>: 此bundle选项使用称为LZ4的压缩方法，这导致比LZMA更大的压缩文件大小，但不像LZMA那样在使用之前不需要整个捆绑包解压缩。 LZ4使用基于块的算法，允许将AssetBundle以切片（pieces）或“块”(chunks)的形式加载。解压缩单个块允许使用包含的资产，即使AssetBundle的其他块未被解压缩。</li></ul><p>使用ChunkBasedCompression与未压缩的bundle具有可比较的加载时间，还具有减小磁盘大小的附加优势。</p><h2 id="BuildTarget"><a href="#BuildTarget" class="headerlink" title="BuildTarget"></a>BuildTarget</h2><p><code>BuildTarget.Standalone</code>: 在这里，我们正在告诉构建管道，我们将使用这些AssetBundles的目标平台。<br>您可以在<a href="https://docs.unity3d.com/ScriptReference/BuildTarget.html" target="_blank" rel="noopener">BuildTarget</a>的API的脚本参考文档中找到可用的显式构建目标的列表。但是，如果您不希望在构建目标中进行硬编码，则可以随时利用EditorUserBuildSettings.activeBuildTarget，这将自动找到你目前的设置构建和构建AssetBundles基于的目标平台。<br>一旦正确设置了构建脚本，就可以构建bundles了。如果您按照上述脚本示例，请单击<strong>Assets</strong> &gt; <strong>Build AssetBundles</strong>以启动该过程。<br>现在你已经成功构建了AssetBundles，你可能会注意到你的AssetBundles目录有可能比你预期更多的文件。确切地说，是2 *（n + 1）个文件。让我们花一点时间来看看<code>BuildPipeline.BuildAssetBundles</code>的产量。</p><p>对于你在编辑器中指定的每个AssetBundle，你将注意到一个包含<code>AssetBundle name</code>和<code>AssetBundle name +.manifest</code>的文件。</p><p>将会有一个额外的bundle和manifest，它不会与您创建的任何AssetBundle共享一个名称。而是以它位于的目录（AssetBundles构建到的目录）命名。这是Manifest Bundle。我们将在以后讨论更多的内容以及如何使用它。</p><h2 id="The-AssetBundle-File"><a href="#The-AssetBundle-File" class="headerlink" title="The AssetBundle File"></a>The AssetBundle File</h2><p>这是缺少.manifest扩展名的文件，以及你在运行时加载的内容，以加载你的资产。<br>AssetBundle文件是一个在内部包含多个文件的存档。此存档的结构可能会稍有变化，具体取决于它是AssetBundle还是场景AssetBundle。这是一个正常的AssetBundle的结构：<br><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/assetbundle_1.jpg" alt="ArchiveFileSystem"></p><p>场景AssetBundle更改自标准的AssetBundles，因为它针对场景及其内容的流加载进行了优化。该图像显示场景bundle的内部结构：</p><h2 id="The-Manifest-File"><a href="#The-Manifest-File" class="headerlink" title="The Manifest File"></a>The Manifest File</h2><p>对于生成的每个包，包括附加的清单包，都会生成关联的清单文件。清单文件可以使用任何文本编辑器打开，并且包含诸如循环冗余校验（CRC）数据和包的依赖性数据的信息。对于正常的AssetBundles，他们的清单文件将如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ManifestFileVersion: 0</span><br><span class="line">CRC: 2422268106</span><br><span class="line">Hashes:</span><br><span class="line">  AssetFileHash:</span><br><span class="line">    serializedVersion: 2</span><br><span class="line">    Hash: 8b6db55a2344f068cf8a9be0a662ba15</span><br><span class="line">  TypeTreeHash:</span><br><span class="line">    serializedVersion: 2</span><br><span class="line">    Hash: 37ad974993dbaa77485dd2a0c38f347a</span><br><span class="line">HashAppended: 0</span><br><span class="line">ClassTypes:</span><br><span class="line">- Class: 91</span><br><span class="line">  Script: &#123;instanceID: 0&#125;</span><br><span class="line">Assets:</span><br><span class="line">  Asset_0: Assets/Mecanim/StateMachine.controller</span><br><span class="line">Dependencies: &#123;&#125;</span><br><span class="line"></span><br><span class="line">Which shows the contained assets, dependencies, and other information.</span><br><span class="line"></span><br><span class="line">The Manifest Bundle that was generated will have a manifest, but it’ll look more like this:</span><br><span class="line"></span><br><span class="line">ManifestFileVersion: 0</span><br><span class="line">AssetBundleManifest:</span><br><span class="line">  AssetBundleInfos:</span><br><span class="line">    Info_0:</span><br><span class="line">      Name: scene1assetbundle</span><br><span class="line">      Dependencies: &#123;&#125;</span><br></pre></td></tr></table></figure><p>这将显示AssetBundles如何关联以及它们的依赖关系。现在，只要明白这个bundle包含了AssetBundleManifest对象，这对于找出在运行时加载哪个bundle依赖是非常有用的。要了解有关如何使用此bundle和manifest对象的更多信息，请参阅<a href="https://docs.unity3d.com/Manual/AssetBundles-Building.html#AssetBundles-Native" target="_blank" rel="noopener">使用本地AssetBundles</a>的文档。</p><blockquote><p>原文链接：<br><a href="https://docs.unity3d.com/Manual/AssetBundles-Building.html" target="_blank" rel="noopener">Building AssetBundles</a></p></blockquote><hr><p><strong>同系列文章</strong></p><p><a href="http://davidsheh.github.io/2017/07/14/「翻译」Unity中的AssetBundle详解（一）/">「翻译」Unity中的AssetBundle详解（一）</a></p><p><a href="http://davidsheh.github.io/2017/08/13/「翻译」Unity中的AssetBundle详解（二）/">「翻译」Unity中的AssetBundle详解（二）</a></p><p><a href="http://davidsheh.github.io/2017/08/21/「翻译」Unity中的AssetBundle详解（三）/">「翻译」Unity中的AssetBundle详解（三）</a></p><p><a href="http://davidsheh.github.io/2017/09/17/「翻译」Unity中的AssetBundle详解（四）/">「翻译」Unity中的AssetBundle详解（四）</a> </p><p><a href="http://davidsheh.github.io/2017/09/23/「翻译」Unity中的AssetBundle详解（五）/">「翻译」Unity中的AssetBundle详解（五）</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构建AssetBundles&quot;&gt;&lt;a href=&quot;#构建AssetBundles&quot; class=&quot;headerlink&quot; title=&quot;构建AssetBundles&quot;&gt;&lt;/a&gt;构建AssetBundles&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;https://docs
      
    
    </summary>
    
      <category term="技术翻译" scheme="http://davidsheh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Unity3D" scheme="http://davidsheh.github.io/tags/Unity3D/"/>
    
      <category term="AssetBundle" scheme="http://davidsheh.github.io/tags/AssetBundle/"/>
    
  </entry>
  
  <entry>
    <title>「翻译」Unity中的AssetBundle详解（二）</title>
    <link href="http://davidsheh.github.io/2017/08/13/%E3%80%8C%E7%BF%BB%E8%AF%91%E3%80%8DUnity%E4%B8%AD%E7%9A%84AssetBundle%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://davidsheh.github.io/2017/08/13/「翻译」Unity中的AssetBundle详解（二）/</id>
    <published>2017-08-13T14:34:01.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为AssetBundles准备资源"><a href="#为AssetBundles准备资源" class="headerlink" title="为AssetBundles准备资源"></a>为AssetBundles准备资源</h2><p>使用AssetBundles时，您可以随意将任何Asset分配给所需的任何Bundle。但是，在设置Bundles时，需要考虑一些策略。这些分组策略可以使用到任何你认为适合的特定项目中。你可以随心所欲地混合和匹配这些策略。</p><h3 id="逻辑实体分组"><a href="#逻辑实体分组" class="headerlink" title="逻辑实体分组"></a>逻辑实体分组</h3><p>逻辑实体分组是根据其所代表的项目的功能部分将资产分配给AssetBundles的。这包括诸如用户界面、人物、环境以及在整个应用程序的整个生命周期中频繁出现的其他部分。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul><li>把用户界面的所有纹理和布局数据打包到一起</li><li>把人物角色所包含的所有的模型和动画打包到一起</li><li>把多个关卡中共用的纹理和模型打包到一起</li></ul><p>逻辑实体分组是可下载内容（DLC）的理想选择，因为以这种方式分离的所有内容，您可以对单个实体进行更改，而不需要下载其他未更改的资产。<br>能够正确实施这一策略的最大的窍门是，开发人员将资产分配给各自的Bundle必须熟悉项目中每个资产的使用时间和位置。</p><h3 id="类型分组"><a href="#类型分组" class="headerlink" title="类型分组"></a>类型分组</h3><p>对于此策略，您可以将相似类型的Assets（如音轨或语言本地化文件）分配给单个AssetBundle。</p><p>类型分组是构建要由多个平台使用的AssetBundles的更好策略之一。例如，如果您的音频压缩设置在Windows和Mac平台之间是相同的，您可以将所有音频数据自己打包到AssetBundles中，并重复使用这些Bundles，而着色器则倾向于使用更多的平台特定选项进行编译，因此你为Mac构建的着色器包可能不能在Windows上重复使用。此外，这种方法非常适合使你的AssetBundles与更多的Unity版本兼容，如同纹理压缩格式和设置的更改频率比你的脚本或预制体的更改频率更低。</p><h3 id="并发内容分组（Concurrent-Content-Grouping）"><a href="#并发内容分组（Concurrent-Content-Grouping）" class="headerlink" title="并发内容分组（Concurrent Content Grouping）"></a>并发内容分组（Concurrent Content Grouping）</h3><p>并发内容分组是将要同时加载和使用的Assets捆绑在一起的想法。您可以将这些类型的Bundles用于基于关卡的游戏，其中每个关卡都包含完全独特的角色、纹理、音乐等。你要绝对肯定的是，包含在这些AssetBundles中一个Asset被使用的同时，其余的Assets也会被使用。对并发内容分组捆绑中的单个资产的依赖将导致加载时间的显著增加。你将因为这个单一Asset而被迫下载整个Bundle。</p><p>并发内容分组的Bundles最常用的用例是基于场景的Bundles。在此分配策略中，每个场景Bundle应该包含大部分或全部场景依赖关系。</p><p>注意，一个项目完全可以并且应该根据需要来组合这些策略。对于任何给定的场景使用最优资产分配策略可以极大地提高任何项目的效率。</p><p>例如，一个项目可能决定将其用于不同平台的用户界面（UI）元素分组到他们自己的特定于平台的UI Bundle中，但按照关卡或场景对其交互式内容进行分组。</p><p>不管你遵循什么策略，这里有一些额外的建议值得你铭记在心：</p><ul><li>将经常更新的对象拆分成AssetBundles，这些对象与很少更改的对象分开</li><li>组合可能同时加载的对象。如一个模型，它的纹理和动画</li><li>如果你注意到多个AssetBundles中的多个对象取决于完全不同的AssetBundle中的单个资产，请将依赖关系移动到单独的AssetBundle。如果几个AssetBundles引用了其他AssetBundles中的同一组资产，可能值得将这些依赖关系拉入共享的AssetBundle以减少重复。</li><li>如果两套对象不太可能同时加载，例如标清和高清资产，请确保它们在自己的资产组合中。</li><li>如果一个AssetBundle中经常有少于50%的Bundle在同一时间加载，那么可以考虑拆分该AssetBundle。</li><li>如果有一些小的AssetBundles（少于5到10个资产的）经常同时被加载，可以考虑组合这些AssetBundles。</li><li>如果一组对象只是同一对象的不同版本，可考虑使用AssetBundle Variants</li></ul><blockquote><p>原文链接：<br><a href="https://docs.unity3d.com/Manual/AssetBundles-Preparing.html" target="_blank" rel="noopener">Preparing Assets for AssetBundles</a></p></blockquote><hr><p><strong>同系列文章</strong></p><p><a href="http://davidsheh.github.io/2017/07/14/「翻译」Unity中的AssetBundle详解（一）/">「翻译」Unity中的AssetBundle详解（一）</a></p><p><a href="http://davidsheh.github.io/2017/08/13/「翻译」Unity中的AssetBundle详解（二）/">「翻译」Unity中的AssetBundle详解（二）</a></p><p><a href="http://davidsheh.github.io/2017/08/21/「翻译」Unity中的AssetBundle详解（三）/">「翻译」Unity中的AssetBundle详解（三）</a></p><p><a href="http://davidsheh.github.io/2017/09/17/「翻译」Unity中的AssetBundle详解（四）/">「翻译」Unity中的AssetBundle详解（四）</a> </p><p><a href="http://davidsheh.github.io/2017/09/23/「翻译」Unity中的AssetBundle详解（五）/">「翻译」Unity中的AssetBundle详解（五）</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为AssetBundles准备资源&quot;&gt;&lt;a href=&quot;#为AssetBundles准备资源&quot; class=&quot;headerlink&quot; title=&quot;为AssetBundles准备资源&quot;&gt;&lt;/a&gt;为AssetBundles准备资源&lt;/h2&gt;&lt;p&gt;使用AssetBun
      
    
    </summary>
    
      <category term="技术翻译" scheme="http://davidsheh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Unity3D" scheme="http://davidsheh.github.io/tags/Unity3D/"/>
    
      <category term="AssetBundle" scheme="http://davidsheh.github.io/tags/AssetBundle/"/>
    
  </entry>
  
  <entry>
    <title>「翻译」Unity中的AssetBundle详解（一）</title>
    <link href="http://davidsheh.github.io/2017/07/14/%E3%80%8C%E7%BF%BB%E8%AF%91%E3%80%8DUnity%E4%B8%AD%E7%9A%84AssetBundle%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://davidsheh.github.io/2017/07/14/「翻译」Unity中的AssetBundle详解（一）/</id>
    <published>2017-07-14T05:34:32.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AssetBundles"><a href="#AssetBundles" class="headerlink" title="AssetBundles"></a>AssetBundles</h2><p>AssetBundle是一个存档文件，其中包含平台在运行时加载的特定资产（模型，纹理，预制，音频剪辑，甚至整个场景）。AssetBundles可以表示彼此之间的依赖关系;例如AssetBundle A中的一个材质可以引用AssetBundle B中的一个纹理。为了通过网络进行有效的传递，可以根据用例要求，选择内置算法（LZMA和LZ4）来对AssetBundles进行压缩。<br>AssetBundles可用于可下载内容（DLC），减少初始安装大小，加载为最终用户平台优化的资产，并降低运行时内存压力。</p><h3 id="一个AssetBundle文件中有什么？"><a href="#一个AssetBundle文件中有什么？" class="headerlink" title="一个AssetBundle文件中有什么？"></a>一个AssetBundle文件中有什么？</h3><p>好的问题，实际上“AssetBundle”可以指两个不同但有关的事情。</p><p>第一个是磁盘上的实际文件。我们把这叫做AssetBundle存档，或在本文档只是短期档案。存档可以被认为是一个容器，就像一个文件夹，在其中保存其他文件。这些附加文件包括两种类型：序列化文件和资源文件。序列化的文件将您的资产分成各自的对象，并写入这个文件。资源文件只是存储在某些资产（纹理和音频）中的二进制数据块，允许我们在另一个线程上有效地将其从磁盘加载到内存。</p><p>第二个是您通过代码从特定存档加载资源的实际的AssetBundle对象。此对象包含您添加到此存档的资源的所有文件路径的映射到属于该资产的对象，该对象在需要时需要加载。（This object contains a map of all the file paths of the assets you added to this archive to the objects that belong to that asset that need to be loaded when you ask for it.）</p><h2 id="AssetBundle工作流程"><a href="#AssetBundle工作流程" class="headerlink" title="AssetBundle工作流程"></a>AssetBundle工作流程</h2><p>要开始使用AssetBundles，请按照下列步骤操作。有关每个工作流程的更详细信息，请参见本部分文档中的其他页面。</p><h3 id="将资产分配给AssetBundles"><a href="#将资产分配给AssetBundles" class="headerlink" title="将资产分配给AssetBundles"></a>将资产分配给AssetBundles</h3><p>要将一个给定的资产分配给一个AssetBundle，请按照下列步骤操作：</p><ol><li>从“项目视图”中选中要分配给一个bundle的资产</li><li>检查Inspector视图中的对象</li><li>在Inspector视图的底部，可以看到一个部分来分配AssetBundles和Variants</li><li>左侧的下拉菜单分配AssetBundle，而右侧的下拉菜单则指定Variants</li><li>点击左侧的下拉菜单，其中显示“None”以显示当前注册的AssetBundle名称</li><li>如果尚未创建，你将看到上面的图像中的列表</li><li>点击“New…”创建一个新的AssetBundle</li><li>键入所需的AssetBundle名称。请注意，AssetBundle名称支持一种类型的文件夹结构，具体取决于你键入的内容。要添加子文件夹，请使用“/”分隔文件夹名称。例如：AssetBundle名称“environment/forest”将在environment子文件夹下创建一个名为forest的bundle</li><li>一旦你选择或创建了一个AssetBundle名称，你可以重复此过程，为右侧下拉菜单分配或创建一个不同的名称，以分配或创建一个Variant名称，如果你愿意的话。在构建AssetBundles时，Variant名称不是必需的。</li></ol><p>要了解有关AssetBundle分配和随附策略的更多信息，请参阅<a href="https://docs.unity3d.com/Manual/AssetBundles-Preparing.html" target="_blank" rel="noopener">Preparing Assets for AssetBundles</a>的文档。</p><h3 id="构建AssetBundles"><a href="#构建AssetBundles" class="headerlink" title="构建AssetBundles"></a>构建AssetBundles</h3><p>在项目中的Assets文件夹下创建一个名为Editor的文件夹，并在文件夹中放置以下内容的脚本：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CreateAssetBundles</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">"Assets/Build AssetBundles"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildAllAssetBundles</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">string</span> assetBundleDirectory = <span class="string">"Assets/AssetBundles"</span>;</span><br><span class="line">        <span class="keyword">if</span>(!Directory.Exists(assetBundleDirectory)</span><br><span class="line">        &#123;</span><br><span class="line">            Directory.CreateDirectory(assetBundleDirectory);</span><br><span class="line">        &#125;</span><br><span class="line">        BuildPipeline.BuildAssetBundles(assetBundleDirectory, BuildAssetBundleOptions.None, BuildTarget.Standalone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该脚本将在Assets菜单的底部创建一个名为“Build AssetBundles”的菜单项，该菜单项将执行与该标记关联的功能中的代码。当您单击Build AssetBundles时，进度条将显示一个构建对话框。这将使那些用AssetBundle名称标记的所有资产打包进同一个文件，并将它们放在由assetBundleDirectory定义的路径上的文件夹中。</p><p>有关此代码正在执行的更多详细信息，请参阅有关<a href="https://docs.unity3d.com/Manual/AssetBundles-Building.html" target="_blank" rel="noopener">Building AssetBundles</a>的文档。</p><h3 id="上传AssetBundles到非本地存储"><a href="#上传AssetBundles到非本地存储" class="headerlink" title="上传AssetBundles到非本地存储"></a>上传AssetBundles到非本地存储</h3><p>这一步对于每个用户都是独一无二的，而不是一步一步可以告诉你如何做。如果您打算将AssetBundles上传到第三方托管网站，请在此处进行。如果您正在严格执行本地开发，并打算将所有AssetBundles都放在磁盘上，请跳到下一步。</p><h3 id="加载AssetBundles和Assets"><a href="#加载AssetBundles和Assets" class="headerlink" title="加载AssetBundles和Assets"></a>加载AssetBundles和Assets</h3><p>对于有意从本地存储加载的用户，您将对AssetBundles.LoadFromFile API感兴趣。看起来像这样：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoadFromFileExample</span> <span class="title">extends</span> <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function">function <span class="title">Start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> myLoadedAssetBundle = AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, <span class="string">"myassetBundle"</span>));</span><br><span class="line">        <span class="keyword">if</span> (myLoadedAssetBundle == <span class="literal">null</span>) &#123;</span><br><span class="line">            Debug.Log(<span class="string">"Failed to load AssetBundle!"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> prefab = myLoadedAssetBundle.LoadAsset.&lt;GameObject&gt;(<span class="string">"MyObject"</span>);</span><br><span class="line">        Instantiate(prefab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>LoadFromFile</code>获取包文件的路径。</p><p>如果您自己托管AssetBundles并且需要将其下载到游戏中，那么您将对UnityWebRequest API感兴趣。这里有一个例子：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">InstantiateObject</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> uri = <span class="string">"file:///"</span> + Application.dataPath + <span class="string">"/AssetBundles/"</span> + assetBundleName;</span><br><span class="line">    UnityEngine.Networking.UnityWebRequest request = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(uri, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> request.Send();</span><br><span class="line">    AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request);</span><br><span class="line">    GameObject cube = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">"Cube"</span>);</span><br><span class="line">    GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;(<span class="string">"Sprite"</span>);</span><br><span class="line">    Instantiate(cube);</span><br><span class="line">    Instantiate(sprite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>GetAssetBundle(string, int)</code>获取AssetBundle的位置的uri以及要下载的包的版本。在这个例子中，我们仍然指向一个本地文件，但是字符串uri可以指向你托管AssetBundles的任何URL。</p><p>UnityWebRequest具有处理AssetBundles的特定句柄（DownloadHandlerAssetBundle），DownloadHandlerAssetBundle从请求中获取AssetBundle。</p><p>无论使用的方法如何，你现在都可以访问AssetBundle对象。从该对象中加载资源，你将需要使用<code>LoadAsset&lt;T&gt;(string)</code>方法，该方法中泛型类型T表示你所要加载的Asset的类型，方法参数为所要加载的Asset对象的名称。这将返回您从AssetBundle加载的任何对象。您可以像Unity中的任何对象一样使用这些返回的对象。例如，如果要在场景中创建一个GameObject，则只需要调用Instantiate（gameObjectFromAssetBundle）。<br>有关加载AssetBundles的API的更多信息，请参阅<a href="https://docs.unity3d.com/Manual/AssetBundles-Native.html" target="_blank" rel="noopener">Using AssetBundles Natively</a>文档。</p><blockquote><p>原文链接：</p><ol><li><a href="https://docs.unity3d.com/Manual/AssetBundlesIntro.html" target="_blank" rel="noopener">AssetBundles</a></li><li><a href="https://docs.unity3d.com/Manual/AssetBundles-Workflow.html" target="_blank" rel="noopener">AssetBundle Workflow</a></li></ol></blockquote><hr><p><strong>同系列文章</strong></p><p><a href="http://davidsheh.github.io/2017/07/14/「翻译」Unity中的AssetBundle详解（一）/">「翻译」Unity中的AssetBundle详解（一）</a></p><p><a href="http://davidsheh.github.io/2017/08/13/「翻译」Unity中的AssetBundle详解（二）/">「翻译」Unity中的AssetBundle详解（二）</a></p><p><a href="http://davidsheh.github.io/2017/08/21/「翻译」Unity中的AssetBundle详解（三）/">「翻译」Unity中的AssetBundle详解（三）</a></p><p><a href="http://davidsheh.github.io/2017/09/17/「翻译」Unity中的AssetBundle详解（四）/">「翻译」Unity中的AssetBundle详解（四）</a> </p><p><a href="http://davidsheh.github.io/2017/09/23/「翻译」Unity中的AssetBundle详解（五）/">「翻译」Unity中的AssetBundle详解（五）</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AssetBundles&quot;&gt;&lt;a href=&quot;#AssetBundles&quot; class=&quot;headerlink&quot; title=&quot;AssetBundles&quot;&gt;&lt;/a&gt;AssetBundles&lt;/h2&gt;&lt;p&gt;AssetBundle是一个存档文件，其中包含平台在运行时加
      
    
    </summary>
    
      <category term="技术翻译" scheme="http://davidsheh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Unity3D" scheme="http://davidsheh.github.io/tags/Unity3D/"/>
    
      <category term="AssetBundle" scheme="http://davidsheh.github.io/tags/AssetBundle/"/>
    
  </entry>
  
  <entry>
    <title>「翻译」理解Unity的自动内存管理</title>
    <link href="http://davidsheh.github.io/2017/07/13/%E3%80%8C%E7%BF%BB%E8%AF%91%E3%80%8D%E7%90%86%E8%A7%A3Unity%E7%9A%84%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://davidsheh.github.io/2017/07/13/「翻译」理解Unity的自动内存管理/</id>
    <published>2017-07-13T04:16:41.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>当创建对象、字符串或数组时，存储它所需的内存将从称为堆的中央池中分配。当项目不再使用时，它曾经占用的内存可以被回收并用于别的东西。在过去，通常由程序员通过适当的函数调用明确地分配和释放这些堆内存块。如今，像Unity的Mono引擎这样的运行时系统会自动为您管理内存。自动内存管理需要比显式分配/释放更少的编码工作，并大大降低内存泄漏（内存被分配但从未随后释放的情况）的可能性。</p><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><p>当调用一个函数时，它的参数值将被复制到一个保留特定调用的内存区域。只占用几个字节的数据类型可以非常快速方便地复制。然而，对象、字符串和数组要大得多，如果这些类型的数据被定期复制，那将是非常低效的。幸运的是，这是不必要的；大项目的实际存储空间是从堆中分配的，一个小的“指针”值用来记住它的位置。从那时起，只有指针在参数传递过程中需要被复制。只要运行时系统能够定位指针标识的项，就可以经常使用数据的一个副本。<br>在参数传递期间直接存储和复制的类型称为值类型。这些包括整数，浮点数，布尔和Unity的结构类型（例如Color和Vector3）。分配在堆上然后通过指针访问的类型称为引用类型，因为存储在变量中的值仅仅是“引用”到真实数据。引用类型的示例包括对象，字符串和数组。</p><h2 id="内存分配和垃圾收集"><a href="#内存分配和垃圾收集" class="headerlink" title="内存分配和垃圾收集"></a>内存分配和垃圾收集</h2><p>内存管理器跟踪它知道未被使用的堆中的区域。当请求一个新的内存块时（例如当一个对象被实例化时），管理器选择一个未使用的区域，从中分配该块，然后从已知的未使用的空间中移除分配的内存。后续请求以相同的方式处理，直到没有足够大的空闲区域分配所需的块大小。在这一点上，从堆中分配的所有内存仍然在使用中是非常不可能的。只要还存在可以找到它的引用变量，就只能访问堆上的引用项。如果对内存块的所有引用都消失了（即，引用变量已被重新分配，或者它们是现在超出范围的局部变量），则它占用的内存可以安全地重新分配。<br>为了确定哪些堆块不再被使用，内存管理器会搜索所有当前活动的引用变量，并将它们所指的块标记为<code>live</code>。在搜索结束时，内存管理器认为这些<code>live</code>块之间的任何空间都是空的，并且可用于后续分配。由于显而易见的原因，定位和释放未使用的内存的过程被称为垃圾回收（或简称GC）。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>垃圾收集对程序员来说是自动的、不可见的，但是收集过程实际上需要大量的CPU时间。如果正确使用，自动内存管理通常会等于或击败手动分配的整体性能。但是，对于程序员来说，重要的是要避免那些比实际需要触发更多次收集器和在执行中引入暂停的错误。有一些臭名昭著的算法，可能是GC噩梦，尽管他们乍一看是无辜的。重复字符串连接是一个典型的例子：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C# script example</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleScript</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ConcatExample</span>(<span class="params"><span class="keyword">int</span>[] intArray</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">string</span> line = intArray[<span class="number">0</span>].ToString();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; intArray.Length; i++) &#123;</span><br><span class="line">            line += <span class="string">", "</span> + intArray[i].ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//JS script example</span></span><br><span class="line"><span class="function">function <span class="title">ConcatExample</span>(<span class="params">intArray: <span class="keyword">int</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> line = intArray[<span class="number">0</span>].ToString();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; intArray.Length; i++) &#123;</span><br><span class="line">        line += <span class="string">", "</span> + intArray[i].ToString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的关键细节是，新的部分不会被一个接一个地添加到字符串中。实际情况是，每次循环<code>line</code>变量的前一个内容都会变死——一个完整的新字符串被分配到包含原来的部分，再在最后加上新的部分。由于字符串随着<code>i</code>值的增加而变得更长，所以所消耗的堆空间数量也增加了，因此每次调用这个函数时都很容易消耗数百字节的空闲堆空间。如果你需要连接多个字符串，那么一个更好的选择是Mono库的<a href="https://msdn.microsoft.com/en-gb/library/system.text.stringbuilder.aspx" target="_blank" rel="noopener">System.Text.StringBuilder</a>类。然而，即使反复连接也不会引起太多麻烦，除非它被频繁调用，而在Unity中通常意味着帧更新。就像是：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C# script example</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleScript</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> GUIText scoreBoard;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">string</span> scoreText = <span class="string">"Score: "</span> + score.ToString();</span><br><span class="line">        scoreBoard.text = scoreText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//JS script example</span></span><br><span class="line"><span class="keyword">var</span> scoreBoard: GUIText;</span><br><span class="line"><span class="keyword">var</span> score: <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">Update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scoreText: String = <span class="string">"Score: "</span> + score.ToString();</span><br><span class="line">    scoreBoard.text = scoreText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>…每次调用Update将分配新字符串，并不断生成的新垃圾。大多数情况下，只有当分数变化时才更新文本：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C# script example</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleScript</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> GUIText scoreBoard;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> scoreText;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> oldScore;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (score != oldScore) &#123;</span><br><span class="line">            scoreText = <span class="string">"Score: "</span> + score.ToString();</span><br><span class="line">            scoreBoard.text = scoreText;</span><br><span class="line">            oldScore = score;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//JS script example</span></span><br><span class="line"><span class="keyword">var</span> scoreBoard: GUIText;</span><br><span class="line"><span class="keyword">var</span> scoreText: String;</span><br><span class="line"><span class="keyword">var</span> score: <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">var</span> oldScore: <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">Update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (score != oldScore) &#123;</span><br><span class="line">        scoreText = <span class="string">"Score: "</span> + score.ToString();</span><br><span class="line">        scoreBoard.text = scoreText;</span><br><span class="line">        oldScore = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当函数返回数组值时，会发生另一个潜在的问题：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C# script example</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleScript</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">float</span>[] <span class="title">RandomList</span>(<span class="params"><span class="keyword">int</span> numElements</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="keyword">float</span>[numElements];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numElements; i++) &#123;</span><br><span class="line">            result[i] = Random.<span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//JS script example</span></span><br><span class="line"><span class="function">function <span class="title">RandomList</span>(<span class="params">numElements: <span class="keyword">int</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="keyword">float</span>[numElements];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numElements; i++) &#123;</span><br><span class="line">        result[i] = Random.<span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当创建一个充满值的新数组时，这种函数非常优雅和方便。但是，如果反复调用，那么每次都会分配新的内存。由于数组可能非常大，可用空间可能会迅速消耗，从而导致垃圾收集频繁。避免这个问题的一个方法是利用数组是引用类型的事实。作为参数传递给函数的数组可以在该函数内修改，结果将在函数返回后保留。<br>像上面这样的功能通常可以被替换成：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C# script example</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleScript</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RandomList</span>(<span class="params"><span class="keyword">float</span>[] arrayToFill</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayToFill.Length; i++) &#123;</span><br><span class="line">            arrayToFill[i] = Random.<span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//JS script example</span></span><br><span class="line"><span class="function">function <span class="title">RandomList</span>(<span class="params">arrayToFill: <span class="keyword">float</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arrayToFill.Length; i++) &#123;</span><br><span class="line">        arrayToFill[i] = Random.<span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这只是用新值替换数组的现有内容。虽然这需要在调用代码中完成数组的初始分配（这似乎有些不雅），但是在调用该函数时不会产生任何新的垃圾。</p><h2 id="主动请求垃圾收集"><a href="#主动请求垃圾收集" class="headerlink" title="主动请求垃圾收集"></a>主动请求垃圾收集</h2><p>如上所述，最好尽量避免分配。然而，鉴于它们不能被完全消除，您可以使用两种主要策略来最大限度地减少其入侵游戏：</p><h3 id="小堆垃圾收集快速可频繁收集"><a href="#小堆垃圾收集快速可频繁收集" class="headerlink" title="小堆垃圾收集快速可频繁收集"></a>小堆垃圾收集快速可频繁收集</h3><p>这个策略通常最适合长期游戏的游戏，其中平滑的帧速率是主要的关注点。这样的游戏通常会频繁地分配小块，但这些块将仅在短时间内使用。在iOS上使用此策略时，典型的堆大小约为200KB，iPhone 3G上的垃圾收集大约需要5ms。如果堆增加到1MB，则收集大约需要7ms。因此，有时候可以以规则的帧间隔请求垃圾回收。这通常会使垃圾收集发生的次数比严格的需要的更多，但是它们将被快速处理，对游戏的影响最小：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Time.frameCount % <span class="number">30</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   System.GC.Collect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，您应该谨慎使用此技术，并检查profiler统计信息，以确保它真正减少了游戏的收集时间。</p><h3 id="大堆垃圾收集缓慢且不可频繁收集"><a href="#大堆垃圾收集缓慢且不可频繁收集" class="headerlink" title="大堆垃圾收集缓慢且不可频繁收集"></a>大堆垃圾收集缓慢且不可频繁收集</h3><p>这个策略对于分配（和因此收集）相对不频繁并可以在游戏暂停期间处理的游戏最适用。对于堆来说，尽可能大，而不是因为系统内存太少而导致操作系统杀死你的应用程序。但是，如果可能，Mono运行时会自动避免扩展堆。您可以通过在启动期间预先分配一些占位符空间来手动扩展堆（即，您实例化一个纯粹用于对内存管理器产生影响的“无用”对象）：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C# script example</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleScript</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> tmp = <span class="keyword">new</span> System.Object[<span class="number">1024</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// make allocations in smaller blocks to avoid them to be treated in a special way, which is designed for large blocks</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">            tmp[i] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// release reference</span></span><br><span class="line">        tmp = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//JS script example</span></span><br><span class="line"><span class="function">function <span class="title">Start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="keyword">new</span> System.Object[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make allocations in smaller blocks to avoid them to be treated in a special way, which is designed for large blocks</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i : <span class="keyword">int</span> = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">        tmp[i] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release reference</span></span><br><span class="line">        tmp = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个足够大的堆不应该在游戏中的暂停期间完全被填满，这样可以容纳一次收集。当发生这样的暂停时，您可以显式地请求垃圾收集：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.GC.Collect();</span><br></pre></td></tr></table></figure></p><p>同样，在使用此策略时应该小心，并注意Profiler统计数据，而不是仅仅假定它具有所期望的效果。</p><h2 id="可重复使用的对象池"><a href="#可重复使用的对象池" class="headerlink" title="可重复使用的对象池"></a>可重复使用的对象池</h2><p>很多情况下，只要减少创建和销毁对象的数量，就可以避免生成垃圾。游戏中存在着某些类型的物体，如抛射体，尽管一次只会有少量的物体在游戏中，但它们可能会被反复地遇到。在这种情况下，常常可以重用对象，而不是破坏旧对象，并用新的对象替换它们。</p><h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p>内存管理是一个微妙而复杂的课题，它已经投入了大量的学术研究。如果您有兴趣了解更多信息，那么<a href="http://www.memorymanagement.org/" target="_blank" rel="noopener">memorymanagement.org</a>是一个很好的资源，列出了许多出版物和在线文章。有关对象池的更多信息可以在<a href="https://en.wikipedia.org/wiki/Object_pool_pattern" target="_blank" rel="noopener">维基百科页面</a>和<a href="https://sourcemaking.com/design_patterns/object_pool" target="_blank" rel="noopener">Sourcemaking.com</a>上找到。</p><blockquote><p>原文链接：<a href="https://docs.unity3d.com/Manual/UnderstandingAutomaticMemoryManagement.html" target="_blank" rel="noopener">Understanding Automatic Memory Management</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当创建对象、字符串或数组时，存储它所需的内存将从称为堆的中央池中分配。当项目不再使用时，它曾经占用的内存可以被回收并用于别的东西。在过去，通常由程序员通过适当的函数调用明确地分配和释放这些堆内存块。如今，像Unity的Mono引擎这样的运行时系统会自动为您管理内存。自动内存
      
    
    </summary>
    
      <category term="技术翻译" scheme="http://davidsheh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Unity3D" scheme="http://davidsheh.github.io/tags/Unity3D/"/>
    
  </entry>
  
  <entry>
    <title>Unity3D集成腾讯语音GVoiceSDK</title>
    <link href="http://davidsheh.github.io/2017/05/27/Unity3D%E9%9B%86%E6%88%90%E8%85%BE%E8%AE%AF%E8%AF%AD%E9%9F%B3GVoiceSDK/"/>
    <id>http://davidsheh.github.io/2017/05/27/Unity3D集成腾讯语音GVoiceSDK/</id>
    <published>2017-05-27T05:15:37.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>友情提示：最近发现腾讯GVoice有另一个官网，叫做<a href="http://gcloud.qq.com/product/6" target="_blank" rel="noopener">腾讯游戏服务</a>，经过对比发现这个网站才是最新的，下面我介绍的那个估计是已经废弃的，但不知道为啥老的网站没有直接链接到新网址而是仍然保留了。不过新官网的文档更加详细，SDK也有所更新，所以建议去新官网下载SDK和Demo，接入流程基本没有啥大变化。</p></blockquote><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>我们项目中用到了实时语音功能，在最初语音 SDK 技术选型的时候测试过融云、声网和腾讯的 GVoice 。融云和声网我都在我们项目中使用过，但是效果都不如王者荣耀游戏中的实时语音效果，这两天好好研究了一下腾讯的 GVoice，终于成功集成。由于腾讯 GVoice 官网的接入流程并不是很详细，如果只懂 Unity3D 不懂 Android 基础知识的朋友，可能接入过程不会一帆风顺。我虽了解一点点 Android 基础，但仍趟过了好几个坑，下面我就分享一下我在 Android 平台接入 GVoice 的过程。</p><h2 id="资源准备"><a href="#资源准备" class="headerlink" title="资源准备"></a>资源准备</h2><p>进入<a href="https://www.qcloud.com/document/product/556/7673" target="_blank" rel="noopener">腾讯GVoice官网</a>下载 GVoice SDK 和 Unity3D Demo。如下图：</p><p><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/gvoice_1.jpg" alt="GVoice SDK.png"></p><h2 id="接入流程"><a href="#接入流程" class="headerlink" title="接入流程"></a>接入流程</h2><h3 id="1-导入SDK"><a href="#1-导入SDK" class="headerlink" title="1. 导入SDK"></a>1. 导入SDK</h3><p>先创建一个空的 Unity 项目 GVoiceDemo，按照官网的接入流程，我们直接将下载的SDK压缩包解压后将其中的 Plugins 和 Scripts 两个文件夹都拷贝到 Unity 项目中。</p><h3 id="2-创建-Jar-包"><a href="#2-创建-Jar-包" class="headerlink" title="2. 创建 Jar 包"></a>2. 创建 Jar 包</h3><p>将Unity项目导出成安卓项目，导出路径选择某个指定的文件夹，我这里在桌面新建了一个叫 unity_gvoicedemo 的文件夹，将项目导出到该文件夹中，操作如下图：</p><p><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/gvoice_2.jpg" alt="Export Project.png"><br>导出成功后会生成 GCloudVoice 和 GVoiceDemo 两个文件夹，用 eclipse 将这两个项目一起导入，如下图</p><p><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/gvoice_3.jpg" alt="Import Projects.png"></p><p>导入成功后，在 UnityPlayerActivity 项目下新建一个 MainActivity 类，继承自 UnityPlayerActivity，详细代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shehweiwei.gvoicedemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tencent.gcloud.voice.GCloudVoiceEngine;</span><br><span class="line"><span class="comment">// 注意：下面这句代码必须有，如果没有可能会导致闪退</span></span><br><span class="line"><span class="keyword">import</span> com.unity3d.player.UnityPlayerActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">UnityPlayerActivity</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">GCloudVoiceEngine.getInstance().init(getApplicationContext(), <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意：代码中一定要引入<code>com.unity3d.player.UnityPlayerActivity</code>这个包，如果没有引入则进入应用就闪退，这里是个大坑，我好不容易才爬出来。</strong><br>然后，选中 MainActivity.java 文件，右键选择 Export -&gt; Java -&gt; JAR file， 然后点击 Next 按钮， 接下来操作如下图：</p><p><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/gvoice_4.jpg" alt="JAR Export.png"></p><p>最后，生成一个 GVoiceDemo.jar 文件。</p><h3 id="3-导入其他文件"><a href="#3-导入其他文件" class="headerlink" title="3. 导入其他文件"></a>3. 导入其他文件</h3><p>将下载的 unity_demo.zip 压缩包解压后将其中的 <code>unity_demo\Assets\Plugins\Android</code> 目录下的 AndroidManifest.xml 和 android-support-v4.jar 两个文件拷贝到项目的 <code>Plugins\Android</code> 目录下。注意还有个GCloudVoiceDemo.jar 文件我们没有拷贝，这里我们使用上一步创建的 GVoiceDemo.jar 文件来替代。注意 jar 包中的包名必须与 AndroidManifest.xml 文件和 Unity 编辑器中PlayerSettings的 Bundle Identifier 包名保持一致。所以，要把 AndroidManifest.xml 文件中的 <code>package=&quot;com.example.gcloudu3ddemo&quot;</code> 这一句代码修改成 <code>package=&quot;com.shehweiwei.gvoicedemo&quot;</code>。</p><p><strong>注意：</strong>AndroidManifest.xml 文件中的入口 Activity 的名字必须和创建的 Jar 包中的新建的 Activity 名字保持一致。这里的入口 Activity 叫 MainActivity，所以 AndroidManifest.xml  文件中的代码为<code>android:name=&quot;.MainActivity&quot;</code>，当然也可以写成 <code>android:name=&quot;com.example.gcloudu3ddemo.MainActivity&quot;</code></p><h3 id="4-构建Unity场景"><a href="#4-构建Unity场景" class="headerlink" title="4. 构建Unity场景"></a>4. 构建Unity场景</h3><p>这里我用uGUI搭建了一个简单的界面，有六个按钮分别调用 GVoice SDK 的六个 API ，然后一个 Text 用来显示回调结果。界面效果如下图：<br><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/gvoice_5.jpg" alt="Create UI.png"><br>然后新建一个 GVoiceDemo 的 C# 脚本，脚本代码如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> gcloud_voice;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GVoiceDemo</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用来显示调用API返回的结果</span></span><br><span class="line">    <span class="keyword">public</span> Text result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IGCloudVoice m_voiceengine = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 这里的appId和appKey使用的是官方提供的测试值，正式项目中可使用申请的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">string</span> appId = <span class="string">"932849489"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">string</span> appKey = <span class="string">"d94749efe9fce61333121de84123ef9b"</span>;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 这里使用的是测试账号，所以房间名使用默认的100，正式项目中可根据实际情况赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> roomName = <span class="string">"100"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_voiceengine == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_voiceengine = GCloudVoice.GetEngine();</span><br><span class="line">            TimeSpan ts = DateTime.UtcNow - <span class="keyword">new</span> DateTime(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">string</span> strTime = System.Convert.ToInt64(ts.TotalSeconds).ToString();</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 这里用时间模拟了一个openId，在正式项目中应该把这里的strTime换成用户唯一ID</span></span><br><span class="line">            m_voiceengine.SetAppInfo(appId, appKey, strTime);</span><br><span class="line">            m_voiceengine.Init();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册SDK常用回调监听</span></span><br><span class="line">            m_voiceengine.OnJoinRoomComplete += OnJoinRoom;</span><br><span class="line">            m_voiceengine.OnQuitRoomComplete += OnExitRoom;</span><br><span class="line">            m_voiceengine.OnMemberVoice += OnMemberVoice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_voiceengine != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不断检测GVoice引擎回调</span></span><br><span class="line">            m_voiceengine.Poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnApplicationPause</span>(<span class="params"><span class="keyword">bool</span> pauseStatus</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_voiceengine == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应用暂停时GVoice引擎也暂停，应用重新开始时引擎继续</span></span><br><span class="line">        <span class="keyword">if</span> (pauseStatus)</span><br><span class="line">        &#123;</span><br><span class="line">            m_voiceengine.Pause();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_voiceengine.Resume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 加入房间，BtnJoin按钮点击调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">JoinRoom</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_voiceengine.SetMode(GCloudVoiceMode.RealTime);</span><br><span class="line">        <span class="keyword">int</span> ret = m_voiceengine.JoinTeamRoom(roomName, <span class="number">15000</span>);</span><br><span class="line"></span><br><span class="line">        result.text += <span class="string">"\nJoinRoom:"</span> + ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 退出房间，BtnExit按钮点击调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExitRoom</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = m_voiceengine.QuitRoom(roomName, <span class="number">6000</span>);</span><br><span class="line">        result.text += <span class="string">"\nExitRoom:"</span> + ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 打开麦克风，BtnOpenMic按钮点击调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OpenMic</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = m_voiceengine.OpenMic();</span><br><span class="line">        result.text += <span class="string">"\nOpenMic:"</span> + ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 关闭麦克风，BtnCloseMic按钮点击调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CloseMic</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = m_voiceengine.CloseMic();</span><br><span class="line">        result.text += <span class="string">"\nCloseMic:"</span> + ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 打开扬声器，BtnOpenSpeaker按钮点击调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OpenSpeaker</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = m_voiceengine.OpenSpeaker();</span><br><span class="line">        result.text += <span class="string">"\nOpenSpeaker:"</span> + ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 关闭扬声器，BtnCloseSpeaker按钮点击调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CloseSpeaker</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = m_voiceengine.CloseSpeaker();</span><br><span class="line">        result.text += <span class="string">"\nCloseSpeaker:"</span> + ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 加入房间回调</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="code"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="roomName"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="memberID"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnJoinRoom</span>(<span class="params">IGCloudVoice.GCloudVoiceCompleteCode code, <span class="keyword">string</span> roomName, <span class="keyword">int</span> memberID</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result.text += <span class="keyword">string</span>.Format(<span class="string">"\nOnJoinRoom ---&gt; code: &#123;0&#125;, roomName: &#123;1&#125;, memberID: &#123;2&#125;"</span>, code, roomName, memberID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 退出房间回调</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="code"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="roomName"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="memberID"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnExitRoom</span>(<span class="params">IGCloudVoice.GCloudVoiceCompleteCode code, <span class="keyword">string</span> roomName, <span class="keyword">int</span> memberID</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result.text += <span class="keyword">string</span>.Format(<span class="string">"\nOnExitRoom ---&gt; code: &#123;0&#125;, roomName: &#123;1&#125;, memberID: &#123;2&#125;"</span>, code, roomName, memberID);</span><br><span class="line"></span><br><span class="line">        m_voiceengine.OnJoinRoomComplete -= OnJoinRoom;</span><br><span class="line">        m_voiceengine.OnQuitRoomComplete -= OnExitRoom;</span><br><span class="line">        m_voiceengine.OnMemberVoice -= OnMemberVoice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 有成员说话时回调</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="members"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="count"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnMemberVoice</span>(<span class="params"><span class="keyword">int</span>[] members, <span class="keyword">int</span> count</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result.text += <span class="keyword">string</span>.Format(<span class="string">"\nOnMemberVoice ---&gt; count: &#123;0&#125;, roomName: &#123;1&#125;, memberID: &#123;2&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将 GVoiceDemo 脚本添加到Canvas对象上，然后将脚本中对应的方法注册到对应的按钮的OnClick事件上，保存场景，然后运行到手机上，使用两个手机就可以语音聊天了，效果如下图：</p><p><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/gvoice_6.jpg" alt="App.png"></p><h2 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h2><p>按照上面的流程集成完的项目并不能在PC上运行，如果要在PC上运行不报错，可以将下载的 unity_demo.zip 文件解压后的 <code>unity_demo\Assets\Plugins</code> 目录下的 X86 和 x86_64 两个文件夹拷贝到项目的 Plugins 文件夹下，这样PC上运行就不会报错。因为我这里没有麦克风设备，不知道在PC上能不能使用语音聊天，有条件的朋友可以试试，有结果了可以反馈给我，先谢过了！</p><h2 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h2><p>我把项目的源码托管在了Github上了， 有需要的朋友自取。<a href="https://github.com/DavidSheh/GVoiceDemo/" target="_blank" rel="noopener">项目链接点这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;友情提示：最近发现腾讯GVoice有另一个官网，叫做&lt;a href=&quot;http://gcloud.qq.com/product/6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;腾讯游戏服务&lt;/a&gt;，经过对比发现这个网站才是最新的
      
    
    </summary>
    
      <category term="技术笔记" scheme="http://davidsheh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Unity3D" scheme="http://davidsheh.github.io/tags/Unity3D/"/>
    
      <category term="GVoice" scheme="http://davidsheh.github.io/tags/GVoice/"/>
    
  </entry>
  
  <entry>
    <title>TextMeshPro插件使用备忘</title>
    <link href="http://davidsheh.github.io/2017/04/26/TextMeshPro%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/"/>
    <id>http://davidsheh.github.io/2017/04/26/TextMeshPro插件使用备忘/</id>
    <published>2017-04-26T11:37:27.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h2><p>TextMeshPro 插件版本：<a href="https://www.assetstore.unity3d.com/cn/#" target="_blank" rel="noopener">1.0.55.0b8</a> (Mar 31, 2017)</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>TextMeshPro字体的制作需要字体文件和字库文件。这里我用到的是黑体常规字体，这种字体可以直接去 Windows 系统的 <code>C:\Windows\Fonts</code> 目录下找。Unity开发中常用的有两种字库文件，一种是3500常用字库，一种是7000常用字库。如果应用中没有聊天功能，一般来说3500常用字库就够用了，出现个别不包含的文字，可以单独加进字库。这两种字库文件我都上传到了Github（<a href="https://github.com/DavidSheh/CommonChineseCharacter" target="_blank" rel="noopener">字库链接点我</a>），有需要的可以自取。</p><h2 id="字体的制作"><a href="#字体的制作" class="headerlink" title="字体的制作"></a>字体的制作</h2><ol><li>将字体文件拖入到 Font Source 选项。接着设置Atlas Resolution 为2048 x 2048，设置 Character Set 选项为 Characters from File，其他选项保持默认就行。</li><li>设置完成后，点击 Generate Font Atlas 按钮，耐心等待程序处理完毕。稍等一会，按钮的下面会有个进度条开始走进度。</li><li>进度走完后， Save TextMeshPro Font Asset 按钮状态变为可点状态，点击按钮将生成的文件保存到 <code>TextMesh Pro/Resources/Fonts &amp; Materials</code>文件夹下。<blockquote><p>3500常用字和7000常用字的图集分辨率都建议设置为2048 x 2048，这种分辨率对这两种字库的显示效果是比较合适的。如果字库比较小的话，可以考虑其他分辨率，这个需要根据实际情况来定。</p></blockquote></li></ol><h2 id="替换插件默认设置"><a href="#替换插件默认设置" class="headerlink" title="替换插件默认设置"></a>替换插件默认设置</h2><p>字体制作完成后，使用菜单创建 TextMeshPro 组件，发现字体不是指定的字体，但是可以手动改变 Font Asset ， 这也太不智能了！能不能自动将默认的字体换成指定的字体呢？答案是肯定的。<br>在<code>TextMesh Pro/Resources</code> 目录下找到 TMP Settings 文件，然后选中该文件，在 Inspector 面板中有个 Default Font Asset 选项，接着将生成的字体文件拖入到该选项后，重新创建 TextMeshPro 组件时的字体就成了指定的字体了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简要说明&quot;&gt;&lt;a href=&quot;#简要说明&quot; class=&quot;headerlink&quot; title=&quot;简要说明&quot;&gt;&lt;/a&gt;简要说明&lt;/h2&gt;&lt;p&gt;TextMeshPro 插件版本：&lt;a href=&quot;https://www.assetstore.unity3d.com/c
      
    
    </summary>
    
      <category term="技术笔记" scheme="http://davidsheh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Unity3D" scheme="http://davidsheh.github.io/tags/Unity3D/"/>
    
      <category term="TextMeshPro" scheme="http://davidsheh.github.io/tags/TextMeshPro/"/>
    
  </entry>
  
  <entry>
    <title>Unity路径的相关总结</title>
    <link href="http://davidsheh.github.io/2017/02/09/Unity%E8%B7%AF%E5%BE%84%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
    <id>http://davidsheh.github.io/2017/02/09/Unity路径的相关总结/</id>
    <published>2017-02-09T09:43:25.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Unity中的路径变量"><a href="#一、Unity中的路径变量" class="headerlink" title="一、Unity中的路径变量"></a>一、Unity中的路径变量</h3><ol><li>Application.dataPath<br>应用数据文件夹的路径，只读。</li><li>Application.streamingAssetsPath<br>应用的流式数据缓存目录，该目录下可以保存一些外部数据文件。</li><li>Application.temporaryCachePath<br>设备的临时数据缓存目录。</li><li>Application.persistentDataPath<br>iOS/Android设备中的持久化数据存储目录，可以在此路径下存储一些持久化的数据文件，该目录下的文件不会因为App升级而删除。</li></ol><h3 id="二、不同平台下的路径"><a href="#二、不同平台下的路径" class="headerlink" title="二、不同平台下的路径"></a>二、不同平台下的路径</h3><table><thead><tr><th style="text-align:left">路径变量</th><th style="text-align:left">Windows</th><th style="text-align:left">Android</th><th style="text-align:left">iOS</th></tr></thead><tbody><tr><td style="text-align:left">Application.dataPath</td><td style="text-align:left">应用的路径/appname _Data</td><td style="text-align:left">/data/app/package name-1/base.apk</td><td style="text-align:left">/var/containers/Bundle/Application/app sandbox/xxx.app/Data</td></tr><tr><td style="text-align:left">Application.streamingAssetsPath</td><td style="text-align:left">应用路径/appname _Data /StreamingAssets</td><td style="text-align:left">jar:file:///data/app/package name-1/base.apk!/assets</td><td style="text-align:left">/var/containers/Bundle/Application/app sandbox/test.app/Data/Raw</td></tr><tr><td style="text-align:left">Application.temporaryCachePath</td><td style="text-align:left">C:\Users\username\AppData\Local\Temp\company name\product name</td><td style="text-align:left"><strong>Internal Only:</strong> /data/user/0/package name/cache <strong>External(SDCard):</strong>  /storage/emulated/0/Android/data/package name/cache</td><td style="text-align:left">/var/mobile/Containers/Data/Application/app sandbox/Library/Caches</td></tr><tr><td style="text-align:left">Application.persistentDataPath</td><td style="text-align:left">C:\Users\username\AppData\LocalLow\company name\product name</td><td style="text-align:left"><strong>Internal Only:</strong> /data/user/0/ package name/files            <strong>External(SDCard):</strong>  /storage/emulated/0/Android/data/package name/files</td><td style="text-align:left">/var/mobile/Containers/Data/Application/app sandbox/Documents</td></tr></tbody></table><blockquote><p>说明：Android平台下的路径会根据SD卡的访问权限不同而不同。至于iOS有没有类似的情况，由于没有相关设备，暂时没有测试。有条件的朋友可以帮我测试一下，我用5.3.4f1版本的Unity写了个简单的测试程序，项目链接：<a href="http://pan.baidu.com/s/1gfqmORh。" target="_blank" rel="noopener">http://pan.baidu.com/s/1gfqmORh。</a> 欢迎测试反馈，不胜感激！</p></blockquote><h3 id="三、常用工具方法"><a href="#三、常用工具方法" class="headerlink" title="三、常用工具方法"></a>三、常用工具方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取不同平台的流式加载路径</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="filename"&gt;</span>文件名<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">GetStreamingFilePath</span>(<span class="params"><span class="keyword">string</span> filename</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">string</span> path = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Application.platform == RuntimePlatform.OSXEditor || Application.platform == RuntimePlatform.OSXPlayer ||</span><br><span class="line">            Application.platform == RuntimePlatform.WindowsEditor || Application.platform == RuntimePlatform.WindowsPlayer)</span><br><span class="line">        &#123;</span><br><span class="line">            path = Application.dataPath + <span class="string">"/StreamingAssets/"</span> + filename;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Application.platform == RuntimePlatform.IPhonePlayer)</span><br><span class="line">        &#123;</span><br><span class="line">            path = Application.dataPath + <span class="string">"/Raw/"</span> + filename;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Application.platform == RuntimePlatform.Android)</span><br><span class="line">        &#123;</span><br><span class="line">            path = <span class="string">"jar:file://"</span> + Application.dataPath + <span class="string">"!/assets/"</span> + filename;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            path = Application.dataPath + <span class="string">"/config/"</span> + filename;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取不同平台的持久化数据存储路径</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="filename"&gt;</span>文件名<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">GetPersistentFilePath</span>(<span class="params"><span class="keyword">string</span> filename</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">string</span> filepath = Application.persistentDataPath + <span class="string">"/"</span> + filename;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_IPHONE</span></span><br><span class="line">        <span class="comment">// Set file flag to be excluded from iCloud/iTunes backup.</span></span><br><span class="line">        UnityEngine.iOS.Device.SetNoBackupFlag(filepath);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> filepath;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h3><ol><li><a href="http://blog.csdn.net/ynnmnm/article/details/52253674" target="_blank" rel="noopener">Unity3D各平台Application.xxxPath的路径</a></li><li><a href="http://www.cnblogs.com/murongxiaopifu/p/4199541.html" target="_blank" rel="noopener">Unity3D移动平台动态读取外部文件全解析</a></li><li><a href="http://www.tuicool.com/articles/IN7RZfz" target="_blank" rel="noopener">Unity各种路径</a></li><li><a href="https://docs.unity3d.com/ScriptReference/Application.html" target="_blank" rel="noopener">Unity官方文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Unity中的路径变量&quot;&gt;&lt;a href=&quot;#一、Unity中的路径变量&quot; class=&quot;headerlink&quot; title=&quot;一、Unity中的路径变量&quot;&gt;&lt;/a&gt;一、Unity中的路径变量&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Application.dataPath
      
    
    </summary>
    
      <category term="技术笔记" scheme="http://davidsheh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Unity3D" scheme="http://davidsheh.github.io/tags/Unity3D/"/>
    
  </entry>
  
  <entry>
    <title>uFrame插件导入报错</title>
    <link href="http://davidsheh.github.io/2016/12/06/uFrame%E6%8F%92%E4%BB%B6%E5%AF%BC%E5%85%A5%E6%8A%A5%E9%94%99/"/>
    <id>http://davidsheh.github.io/2016/12/06/uFrame插件导入报错/</id>
    <published>2016-12-06T06:29:18.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近想研究一下uFrame插件，于是从AssetStore下载了最新的uFrame插件。下载后导入到Unity是两个版本的unitypackage包，分别是uFrame-1.5.1r2和uFrame-1.6.3r1。网上简单查了一下，说两个版本差别还是挺大的，新版本不能向前兼容。</p><p><strong>一、挡路的狗（Bug）</strong></p><hr><p>我最后选择了最新版本，双击后导入，导入完成后，控制台出现如下错误：<br><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/uframe_1.jpg" alt="Error1.png"><br>一大堆错误的详细信息就不一一列出了，第一个错误的详细信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assets/uFrame/MVVM/Framework/Editor/Templates/uFrameTemplates.cs(144,48): error CS0246: The type or namespace name `UGUIExtensions&apos; could not be found. Are you missing a using directive or an assembly reference?</span><br></pre></td></tr></table></figure></p><p>分析了一下，发现是UGUIExtensions这个类因为某个原因没找到，然后，我直接用VS的全局搜索整个解决方案。最后，发现UGUIBindings.cs这个脚本中的UGUIExtensions类被宏命令屏蔽了，因为我使用的Unity版本是5.3.4f1，而UGUIBindings.cs这个脚本的第一行<code>#if UNITY_4_6 || UNITY_5_0 || UNITY_5_1 || UNITY_5_2</code>直接不支持5.3.4f1，所以解决办法就是直接在第一行末尾追加<code>|| UNITY_5_3</code>。<br>改完保存编译后，果然没错了。本来以为可以开始好好研究了，然而并非如此。</p><p><strong>二、拦路虎（Exception）</strong></p><hr><p>当我导入ExampleProject案例工程的unitypackage后，一切正常没有报错，接着，我选择Window -&gt; uFrameDesigner打开uFrame的可视化编辑器后，疯狂的抛出如下异常：<br><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/uframe_2.jpg" alt="Error2.png"></p><p>异常详细信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">UnityException: Texture &apos;Header3&apos; is not readable, the texture memory can not be accessed from scripts. You can make the texture readable in the Texture Import Settings.</span><br><span class="line">UnityEngine.Texture2D.GetPixels32 () (at C:/buildslave/unity/build/artifacts/generated/common/runtime/TextureBindings.gen.cs:336)</span><br><span class="line">Invert.Common.TexturesExtensions.CutTextureBottomBorder (UnityEngine.Texture2D texture, Int32 cutSize) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner.Unity/ElementDesignerStyles.cs:1998)</span><br><span class="line">Invert.Core.GraphDesigner.Unity.Schemas.UnityNodeStyleSchema.ConstructHeaderImage (Boolean expanded, Color color, System.String iconName) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner.Unity/Schemas/UnityNodeStyleSchema.cs:57)</span><br><span class="line">Invert.Core.GraphDesigner.Schemas.impl.NodeStyleSchema.GetHeaderImage (Boolean expanded, Color color, System.String iconName) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner/Schemas/impl/NodeStyleSchema.cs:176)</span><br><span class="line">Invert.Core.GraphDesigner.HeaderDrawer.Draw (IPlatformDrawer platform, Single scale) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner/Drawers/impl/HeaderDrawer.cs:97)</span><br><span class="line">Invert.Core.GraphDesigner.DiagramNodeDrawer.DrawChildren (IPlatformDrawer platform, Single scale) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner/Drawers/impl/DiagramNodeDrawer.cs:356)</span><br><span class="line">Invert.Core.GraphDesigner.DiagramNodeDrawer.Draw (IPlatformDrawer platform, Single scale) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner/Drawers/impl/DiagramNodeDrawer.cs:292)</span><br><span class="line">Invert.Core.GraphDesigner.GenericNodeDrawer`2[TData,TViewModel].Draw (IPlatformDrawer platform, Single scale) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner/Drawers/impl/DiagramNodeDrawer.cs:64)</span><br><span class="line">Invert.Core.GraphDesigner.DiagramDrawer.Draw (IPlatformDrawer platform, Single scale) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner/Drawers/impl/DiagramDrawer.cs:146)</span><br><span class="line">Invert.Core.GraphDesigner.DesignerWindow.DrawDiagram (IPlatformDrawer drawer, Vector2 scrollPosition, Single scale, Rect diagramRect) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner/Windows/DesignerWindow.cs:349)</span><br><span class="line">Invert.Core.GraphDesigner.DesignerWindow.Draw (IPlatformDrawer drawer, Single width, Single height, Vector2 scrollPosition, Single scale) (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner/Windows/DesignerWindow.cs:256)</span><br><span class="line">Invert.Core.GraphDesigner.Unity.ElementsDesigner.OnGUI () (at D:/Invert/uFrameGit/uFrameTools/Invert.Core.GraphDesigner.Unity/ElementsDesigner.cs:256)</span><br><span class="line">System.Reflection.MonoMethod.Invoke (System.Object obj, BindingFlags invokeAttr, System.Reflection.Binder binder, System.Object[] parameters, System.Globalization.CultureInfo culture) (at /Users/builduser/buildslave/mono/build/mcs/class/corlib/System.Reflection/MonoMethod.cs:222)</span><br></pre></td></tr></table></figure></p><p>这时，uFrame的编辑器窗口也是卡死状态。通过分析报错信息发现，是因为一个名为Header3的图片为非可读的，所以报错了。找到Header3图片，然后修改图片格式如下：</p><p><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/uframe_3.jpg" alt="Image Setting.png"></p><p>修改完后所有的都正常了。正在我得意的以为可以好好开始研究一下案例的时候，现实总是残酷的。。。</p><p><strong>三、死耗子（Error）</strong></p><hr><p>当我选择第一个场景双击打开点击运行后，发现报了如下错误：</p><p><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/uframe_4.jpg" alt="Error3.png"><br>详细信息就不贴了，第一个问题很明显，就是相应的场景没有添加进Build Settings，反正也不知道场景的添加顺序，我就直接把案例工程中的所有场景都添加进Build Settings。然后，重新运行就都正常了。终于可以开开心心的研究uFrame了</p><blockquote><p>uFrame-1.5.1r2导入后也有很多错误，不过我懒得研究了。我喜欢用新版的，我是一个喜新厌旧的人。对uFrame-1.5.1r2感兴趣的人可以自己研究一下。</p></blockquote><hr><blockquote><p>如果本文有错误之处还请帮忙指出。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近想研究一下uFrame插件，于是从AssetStore下载了最新的uFrame插件。下载后导入到Unity是两个版本的unitypackage包，分别是uFrame-1.5.1r2和uFrame-1.6.3r1。网上简单查了一下，说两个版本差别还是挺大的，新版本不能向前
      
    
    </summary>
    
      <category term="技术笔记" scheme="http://davidsheh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Unity3D" scheme="http://davidsheh.github.io/tags/Unity3D/"/>
    
      <category term="uFrame" scheme="http://davidsheh.github.io/tags/uFrame/"/>
    
  </entry>
  
  <entry>
    <title>Unity插件之Unity调用C#编译的DLL</title>
    <link href="http://davidsheh.github.io/2016/11/15/Unity%E6%8F%92%E4%BB%B6%E4%B9%8BUnity%E8%B0%83%E7%94%A8C_Sharp%E7%BC%96%E8%AF%91%E7%9A%84DLL/"/>
    <id>http://davidsheh.github.io/2016/11/15/Unity插件之Unity调用C_Sharp编译的DLL/</id>
    <published>2016-11-15T05:58:02.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Unity插件分为两种：托管插件（Managed Plugins）和本地插件（Native Plugins）。本文先来说说Unity中的托管插件，本地插件的文章留到下一篇文章再说。<br>有时候我们会有这样的需求：给第三方公司提供Unity插件，而又不希望第三方看到具体代码，这时就可以将核心代码编译成dll文件供第三方调用。或者说，同一个公司多个项目都用到某个模块，则可以把该模块封装成dll，方便在不同项目之间共用和维护。</p><blockquote><p>关于dll加密的问题，以后有机会了可以考虑写点东西分享出来。</p></blockquote><p><strong>一、创建DLL</strong></p><hr><p>打开VS，选择文件 -&gt; 新建 -&gt; 项目后打开新建项目对话框。接着操作如下：</p><p><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/unity_csharp_dll_1.jpg" alt="新建项目.png"></p><p>点击确定后，编写如下代码：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyLib</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">GetBlogName</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Sheh伟伟的个人博客"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TimeSpan <span class="title">GetBlogTime</span>(<span class="params">DateTime time</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (time - DateTime.Parse(<span class="string">"2016/11/14"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后生成dll文件，操作如下图：</p><p><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/unity_csharp_dll_2.jpg" alt="build.png"></p><blockquote><p>提示：也可以用MonoDeveloper创建并生成dll，至于操作步骤可以查看<a href="https://docs.unity3d.com/Manual/UsingDLL.html" target="_blank" rel="noopener">官网手册</a>。</p></blockquote><p><strong>二、导入DLL</strong></p><hr><p>将MyLib项目目录下的bin/Debug目录下的MyLib.dll文件拷贝到Unity项目的Plugins目录下。这时，Unity控制台报Unhandled Exception: System.Reflection.ReflectionTypeLoadException: The classes in the module cannot be loaded的错误，报错详细信息如下：</p><p><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/unity_csharp_dll_3.jpg" alt="error.png"></p><p>这是因为我用的Unity版本是5.3.4f1，支持的.NET Framework的版本为3.5。而我创建的MyLib项目的默认.NET Framework 3.5版本为4.5.2。<br>选择项目，然后右键选择属性 -&gt; 应用程序，将目标框架改为 .NET Framework 3.5或以下 ，如下图：</p><p><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/unity_csharp_dll_4.jpg" alt=""><br>接着重新生成一下dll文件，重新导入到Unity就行了。</p><p><strong>三、调用DLL</strong></p><hr><p>在Unity新建一个TestDll的脚本，并挂到主摄像机上，脚本代码如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> MyLib; <span class="comment">// 导入dll</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDll</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> blogUrl = <span class="string">"https://davidsheh.github.io/"</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">string</span> myBlog = <span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;:&#123;1&#125;"</span>, MyClass.GetBlogName(), blogUrl);</span><br><span class="line">        Debug.Log(myBlog);</span><br><span class="line"></span><br><span class="line">        TimeSpan span = MyClass.GetBlogTime(DateTime.Now);</span><br><span class="line">        Debug.Log(<span class="string">"写这篇博客到现在的时间间隔："</span> + span.TotalDays);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，调用Dll中的方法一定要使用using语句引入导入到unity中的dll类库。</p><p><strong>四、导入Unity DLL</strong></p><hr><p>怎么导入Unity原生类库呢？别急，接下来就说说怎么在自定义的dll类库中调用Unity中的类。<br>首先选中项目，接着右键选择添加 -&gt; 引用后，弹出引用管理器，如下图：<br><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/unity_csharp_dll_5.jpg" alt="添加引用.png"></p><p>在应用管理器界面点击浏览按钮，找到UnityEngine.dll文件点击确认按钮导入，如下图所示：</p><p><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/unity_csharp_dll_6.jpg" alt="引用管理器.png"></p><blockquote><p>Unity类库在Mac上的路径为<code>Applications/Unity.app/Contents/Frameworks/Managed/UnityEngine.dll</code>；在Windows上的路径为<code>Program Files\Unity\Editor\Data\Managed\UnityEngine.dll</code>。</p></blockquote><p>接着，将项目中无用的类库都移除掉，只保留用到的System和UnityEngine两个类库，如下图：<br><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/unity_csharp_dll_7.jpg" alt="引用.png"></p><p>然后，修改MyClass脚本，代码如下：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyLib</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">GetBlogName</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Sheh伟伟的个人博客"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TimeSpan <span class="title">GetBlogTime</span>(<span class="params">DateTime time</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (time - DateTime.Parse(<span class="string">"2016/11/13"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateCube</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            GameObject go = GameObject.CreatePrimitive(PrimitiveType.Cube);</span><br><span class="line">            <span class="keyword">int</span> random = UnityEngine.Random.Range(<span class="number">-5</span>, <span class="number">5</span>);</span><br><span class="line">            go.transform.position = <span class="keyword">new</span> Vector3(random, random, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码编写完成后，重新生成一下dll，然后导入到Unity中，接着修改Unity脚本TesDll，具体代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> MyLib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDll</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> blogUrl = <span class="string">"https://davidsheh.github.io/"</span>;</span><br><span class="line">    <span class="keyword">string</span> myBlog;</span><br><span class="line">    <span class="keyword">double</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        myBlog = <span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;:&#123;1&#125;"</span>, MyClass.GetBlogName(), blogUrl);</span><br><span class="line">        Debug.Log(myBlog);</span><br><span class="line"></span><br><span class="line">        TimeSpan span = MyClass.GetBlogTime(DateTime.Now);</span><br><span class="line">        time = span.TotalDays;</span><br><span class="line">        Debug.Log(<span class="string">"写这篇博客到现在的时间间隔："</span> + time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        GUILayout.Label(myBlog);</span><br><span class="line">        GUILayout.Label(time.ToString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(GUILayout.Button(<span class="string">"Create Cube"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            MyClass.CreateCube();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后的效果图如下：<br><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/unity_csharp_dll_8.jpg" alt="效果图.png"></p><blockquote><p>源代码放在了群共享中，想要源码的可以加群：253999688</p></blockquote><p><strong>四、参考资料</strong></p><hr><p><a href="https://docs.unity3d.com/Manual/UsingDLL.html" target="_blank" rel="noopener">Managed Plugins</a></p><hr><blockquote><p>如果本文有错误之处还请帮忙指出。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Unity插件分为两种：托管插件（Managed Plugins）和本地插件（Native Plugins）。本文先来说说Unity中的托管插件，本地插件的文章留到下一篇文章再说。&lt;br&gt;有时候我们会有这样的需求：给第三方公司提供Unity插件，而又不希望第三方看到具体代码
      
    
    </summary>
    
      <category term="技术笔记" scheme="http://davidsheh.github.io/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C#" scheme="http://davidsheh.github.io/tags/C/"/>
    
      <category term="Unity3D" scheme="http://davidsheh.github.io/tags/Unity3D/"/>
    
  </entry>
  
  <entry>
    <title>最好用的Unity版本控制工具</title>
    <link href="http://davidsheh.github.io/2016/11/03/%E6%9C%80%E5%A5%BD%E7%94%A8%E7%9A%84Unity%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/"/>
    <id>http://davidsheh.github.io/2016/11/03/最好用的Unity版本控制工具/</id>
    <published>2016-11-03T13:14:33.000Z</published>
    <updated>2018-01-20T08:18:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>自从来到现在的公司，负责Unity组开发以来，尝试了各种版本控制工具。从一开始的TortoiseSVN，到后来为了追求逼格使用Git，尝试了Github客户端和SourceTree，发现都有各种不爽。最后，发现还是Unity的亲儿子Asset Asset Server最好使，服务器配置傻瓜化，还集成到了Unity编辑器。</p><p><strong>一、Asset Server安装</strong></p><hr><p>去<a href="https://unity3d.com/cn/unity/team-license" target="_blank" rel="noopener">Unity官网</a>下载Unity资源服务器，如下图：</p><p><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/unity_assetserver_1.jpg" alt=""><br>Windows版下载后安装很简单，安装过程中会弹出的账号密码对话框，如下图：</p><p><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/unity_assetserver_2.jpg" alt=""><br>填写完账号密码后，会弹出控制面板，如下图：</p><p><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/unity_assetserver_3.jpg" alt=""><br>Asset Server启动起来了就可以关掉，程序会在后台继续运行。</p><p><strong>二、Asset Server配置</strong></p><hr><p>用Unity在服务器电脑上新建一个空的项目，然后选择Edit -&gt; Project Settings -&gt; Editor打开Editor Settings，Version Control项选择Asset Server，如下图：<br><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/unity_assetserver_4.jpg" alt=""></p><p>接着选择Window -&gt; Version Control打开Version Control，如下图：<br><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/unity_assetserver_5.jpg" alt=""></p><p>点击Administration按钮，然后在ServerAddress中输入localhost，接着输入用户名和密码，点击Connect。如下图：<br><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/unity_assetserver_6.jpg" alt=""></p><p>点击界面右边的Create按钮创建一个项目，然后就在Server视图的左下角会显示创建的项目。选中该项目，然后点击New User按钮创建允许访问的成员的信息，成员创建好了后，还必须勾选，没有勾选的不能访问该项目。如下图：<br><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/unity_assetserver_7.jpg" alt=""></p><p>到此，服务器配置就完成了。只要知道服务器的IP地址和Asset Server的用户名密码就可以在其他电脑上管理资源服务器。</p><p><strong>三、连接Asset Server</strong></p><hr><p>服务器配置完了，那么项目的其他成员如何连接服务器进行代码同步呢？<br>项目的其他成员可以在自己电脑上先建一个空项目，然后将Version Control也设置成Asset Server，接着选择Window -&gt; Version Control打开Server面板。点击Connection按钮，然后输入Server的IP地址和为改成员创建的用户名密码，点击Show Projects或者输入Project Name后，接着点击Connect，这样就连接上了服务器。如下图：<br><img src="https://raw.githubusercontent.com/DavidSheh/MarkdownPictures/master/pictures/unity_assetserver_8.jpg" alt=""></p><p>时间紧迫，就写这么多吧，以后有必要再接着写代码的同步流程以及代码的对比工具。</p><p><strong>四、参考资料</strong></p><hr><ol><li><a href="https://docs.unity3d.com/Manual/SettinguptheAssetServer.html" target="_blank" rel="noopener">Setting up the Asset Server</a></li><li><a href="https://docs.unity3d.com/Manual/AssetServer.html" target="_blank" rel="noopener">Asset Server (Team License)</a></li></ol><blockquote><p>如果本文有错误之处还请帮忙指出。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自从来到现在的公司，负责Unity组开发以来，尝试了各种版本控制工具。从一开始的TortoiseSVN，到后来为了追求逼格使用Git，尝试了Github客户端和SourceTree，发现都有各种不爽。最后，发现还是Unity的亲儿子Asset Asset Server最好使
      
    
    </summary>
    
      <category term="开发工具" scheme="http://davidsheh.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Unity3D" scheme="http://davidsheh.github.io/tags/Unity3D/"/>
    
  </entry>
  
</feed>
